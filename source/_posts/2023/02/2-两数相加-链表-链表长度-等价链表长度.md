---
title: 2. 两数相加 | 链表 | 链表长度 | 等价链表长度
date: 2023-02-13 00:23:03
categories: 算法刷题记录
tags:
- leetcode
- 力扣
- 算法
---

### 题目

[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

### 思路

总体上可以分为两类，迭代和递归

1. 迭代
   迭代链表在边界判断上具有许多方式，这里选择将两条链表看成是**相等长度**的，利用两个变量，`dummy`，`p` 记录节点位置，在内部实现保证迭代不出错即可
   - 将两条链表视为相等长度，但是实际过程中，需要判断链表是否已经遍历到头，也就是两个 `if`
   - 两条链表对应节点的 `val` 相加后再次存入
   - 两个 `if` 保证其链表不会遍历出错，而 `dummy`，`p` 记录对应的节点，最终如果有 `carry` 则新建 `node` 节点
   - 理解 `while` 和 两个 `if` 之间的转换
2. 递归
   待完善

### 代码


```ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    // case 1
    if (l1 === null && l2 === null) return null;

    let p1 = l1, p2 = l2, dummy: ListNode = new ListNode(), p: ListNode = new ListNode();
    let carry = 0;

    while (p1 !== null || p2 !== null) {
        const n1 = p1 === null ? 0 : p1.val;
        const n2 = p2 === null ? 0 : p2.val;
        const num = n1 + n2 + carry;
        carry = Math.floor(num / 10); // JavaScript不是整除
		
        // 实际过程中判断链表是否遍历到头，在遍历的过程中更新头节点和尾节点
        if (p1 !== null) {
            dummy.next = l1;
            p = p1
            p1.val = num % 10;
            p1 = p1.next
        }

        if (p2 !== null) {
            dummy.next = l2;
            p = p2;
            p2.val = num % 10;
            p2 = p2.next;
        }
    }

    if (carry !== 0) {
        p.next = new ListNode(carry)
    }

    return dummy.next;
};
```

### 其他

[2. 两数相加 | 链表长度_一抹阳光&的博客-CSDN博客](https://blog.csdn.net/qq_45759413/article/details/129095739?csdn_share_tail={"type"%3A"blog"%2C"rType"%3A"article"%2C"rId"%3A"129095739"%2C"source"%3A"qq_45759413"})
