<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Az">


    <meta name="subtitle" content="Welcome!">



    <meta name="keywords" content="blog luckydog Withx">


<title>rust: 内部可变性的 Cell 与 RefCell | Az&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    


<link rel="stylesheet" href="/fonts/custom/iconfont.css">



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">I&#39;m Az</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">I&#39;m Az</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">rust: 内部可变性的 Cell 与 RefCell</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Az</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">2024.05.19&nbsp;&nbsp;00:00:59</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/rust/">rust</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="内部可变性的-Cell-与-RefCell"><a href="#内部可变性的-Cell-与-RefCell" class="headerlink" title="内部可变性的 Cell 与 RefCell"></a>内部可变性的 Cell 与 RefCell</h2><p>Rust 通过严格的规则来保证所有权和借用的正确性，这带来安全提升的同时，损失了灵活性，比如结构体可变必须要求结构体所有字段可变。</p>
<p>这是由于 Rust 的 mutable 特性，一个结构体中的字段，要么全都是 immutable，要么全部是 mutable，<strong>不支持针对部分字段进行设置</strong>。<br>比如，在一个 struct 中，可能只有个别的字段需要修改，其他字段并不需要修改，为了一个字段而将整个 struct 变为 <code>&amp;mut</code> 是不合理的。</p>
<p>rust 提供实现了<strong>内部可变性</strong> Cell 和 RefCell 解决这类问题，通过<strong>内部可变性</strong>可以实现 struct 部分字段可变，而不用将整个 struct 设置为 mutable。</p>
<blockquote>
<p>内部可变性的实现是因为 Rust 使用了 unsafe 来做到这一点，但是对于使用者来说，这些都是透明的，因为这些不安全代码都被封装到了安全的 API 中。<br>简而言之，<strong>可以在拥有不可变引用的同时修改目标数据</strong>。</p>
</blockquote>
<h3 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h3><p>Cell 和 RefCell 在功能上没有区别，区别在于 <code>Cell&lt;T&gt;</code> 适用于 T 实现 Copy 特征的情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  use std::cell::Cell;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s_cell</span> = Cell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = s_cell.<span class="title function_ invoke__">get</span>(); <span class="comment">// 获取内部数据</span></span><br><span class="line">s_cell.<span class="title function_ invoke__">set</span>(<span class="string">&quot;Hi&quot;</span>); <span class="comment">// 不可变引用直接修改内部数据</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s_cell:?&#125;, &#123;s&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码展示了 Cell 的基本用法，有几点值得注意：</p>
<ul>
<li>“Hello World” 是 <code>&amp;str</code> 类型，它实现了 Copy 特征</li>
<li>get 用来取值，set 用来设置新值</li>
</ul>
<p>取到值保存在 s 变量后，还能同时进行修改，这个违背了 Rust 的借用规则，但是由于实现了内部可变性的结构体 Cell 的存在，可以优雅地做到用不可变引用修改目标数据。</p>
<p>Cell 适用于实现 Copy 的类型，如果尝试在 Cell 中存放 String，编译器会立刻报错，这是因为 <code>String</code> 没有实现 Copy 特征：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = Cell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;asdf&quot;</span>)); 错误，<span class="type">String</span>没有实现<span class="built_in">Copy</span>特征</span><br></pre></td></tr></table></figure>

<p>如果是自定义的结构体实现，会发现 safe 代码中不能实现在拥有不可变引用的情况下修改数据。因为这与方法接收者的类型不一致，不可变引用不能调用可变引用的方法（点操作符的隐式转换）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCell</span>&lt;T: <span class="built_in">Copy</span>&gt; &#123;</span><br><span class="line">    value: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span>&gt; MyCell&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(v: T) <span class="punctuation">-&gt;</span> MyCell&lt;T&gt; &#123;</span><br><span class="line">        MyCell &#123; value: v &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, v: T) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_cell</span> = MyCell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">my_cell.<span class="title function_ invoke__">set</span>(<span class="string">&quot;Hi&quot;</span>); 错误，set函数 `<span class="title function_ invoke__">set</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, v: T)` 要求接收者是可变引用 `<span class="keyword">self</span>: &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>`，而此时的 `my_cell` 是一个不可变引用。</span><br></pre></td></tr></table></figure>

<h4 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h4><p>Cell 通过内部的 <code>get set</code> 方法完成数据的获取和替换，即 <code>get</code> 提供不可变引用功能（读），<code>get set</code> 提供可变引用（读写）</p>
<h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h3><p>在实际开发中，程序操作的更多是一个复杂数据类型，如多字段深层结构体。Cell 适用于 实现了 Copy 特征的类型，显然当复杂类型没有实现 Copy 时就需要另外一个内部可变性的工具来代替 Cell。<br>rust 针对复杂数据类型（未实现 Copy）提供实现了内部可变性的 <code>RefCell</code>。</p>
<p><strong>RefCell 的功能是通过 unsafe 操作，为一个类型（变量&#x2F;值）对外提供该类型的不可变引用和可变引用，无论这个类型（变量&#x2F;值）是否可变</strong>。由于是 unsafe 的实现，不受借用规则限制。</p>
<p>对外暴露的不可变引用和可变引用操作是<strong>有限制</strong>的，必须要符合借用规则。<br>RefCell 关注点在为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，这里是 unsafe 的实现，不受借用规则限制。<br>接收不可变引用和可变引用的变量不属于 RefCell 的关注点，它们依然要符合借用规则，以保证 RefCell 智能指针的正常运行。<br>RefCell 会在内部记录不可变引用（borrow 方法）和可变引用（borrow_mut 方法）的使用次数，通过<strong>使用次数来判断此时是否符合借用规则</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **RefCell 的功能是通过 unsafe 操作，为一个类型（变量/值）对外提供该类型的不可变引用和可变引用，无论这个类型（变量/值）是否可变**。</span></span><br><span class="line"><span class="comment">// RefCell 会在内部记录不可变引用（borrow）和可变引用（borrow_mut）的使用次数，通过使用次数来判断此时是否符合借用规则</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow</span>(); <span class="comment">// RefCell 记录一次不可变引用，不可变引用是1，可变引用是0，符合借用规则，正常运行</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow</span>(); <span class="comment">// RefCell 记录一次不可变引用，不可变引用是2，可变引用是0，符合借用规则，正常运行</span></span><br><span class="line"><span class="comment">// let s2 = s.borrow_mut(); // RefCell 记录一次可变引用，不可变引用是2，可变引用是1，此时会报错，因为不能同时存在不可变引用和可变引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow_mut</span>(); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行</span></span><br><span class="line"><span class="comment">// let s2 = s.borrow_mut(); // RefCell 记录一次可变引用，不可变引用是0，可变引用是2，此时会报错，因为不能同时存在多个可变引用（一个可变引用周期内存在另外一个可变引用）</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">*s.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">*s.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>也就是 RefCell 实际上<strong>没有解决可变引用和引用可以共存的问题</strong>。<br>它的关注点在于为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，这里是 <strong>unsafe</strong> 的实现，不受借用规则限制。<br>所以 RefCell 只是绕过了编译期的错误，将报错从编译期推迟到运行时，从编译器错误变成了 panic 异常。</p>
<h4 id="为什么需要-RefCell？"><a href="#为什么需要-RefCell？" class="headerlink" title="为什么需要 RefCell？"></a>为什么需要 RefCell？</h4><p>既然没有解决问题，为什么还需要 RefCell？这是因为复杂类型的不可变与可变性。<br>由于 Rust 的 mutable 特性，一个结构体中的字段，要么全都是 immutable，要么全部是 mutable，<strong>不支持针对部分字段进行设置</strong>。<br>比如，在一个 struct 中，可能只有个别的字段需要修改，其他字段并不需要修改，为了一个字段而将整个 struct 变为 <code>&amp;mut</code> 是不合理的。</p>
<p>而 RefCell 通过 unsafe 操作，可以为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，只需要接收的变量遵守借用规则就不会出现运行时错误。</p>
<p>这意味着可以<strong>通过 RefCell 让一个结构体既有不可变字段，也有可变字段</strong>，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 RefCell，让一个结构体既有不可变字段，也有可变字段</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: RefCell&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">    name: RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;L&quot;</span>)),</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// p.age = 22; 错误的，如果需要age可更改，需要p是可变的。</span></span><br><span class="line">*p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;M&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">*p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;N&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;p:?&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于大型的复杂程序，可以选择使用 RefCell 来让事情简化。例如在 Rust 编译器的 ctxt 结构体中有大量的 RefCell 类型的 map 字段，主要的原因是：这些 map 会被分散在各个地方的代码片段所广泛使用或修改。由于这种分散在各处的使用方式，导致了管理可变和不可变成为一件非常复杂的任务（甚至不可能），你很容易就碰到编译器抛出来的各种错误。而且 RefCell 的运行时错误在这种情况下也变得非常有用：一旦有人做了不正确的使用，代码会 panic，然后告诉我们哪些借用冲突了。</p>
<p>总之，当有一个复杂类型，既有可变又有不可变，又或者需要被到处使用和修改然后导致借用关系难以管理时，都可以优先考虑使用 RefCell。</p>
<h4 id="RefCell-总结"><a href="#RefCell-总结" class="headerlink" title="RefCell 总结"></a>RefCell 总结</h4><ul>
<li>RefCell 适用 Copy 和非 Copy 类型，一般来说 Copy 类型可直接选择 Cell</li>
<li>RefCell 只是绕过编译期的借用规则，程序运行期没有绕过</li>
<li>RefCell 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时</li>
<li>使用 RefCell 时，<code>borrow</code> 和 <code>borrow_mut</code> 提供不可变引用和可变引用不能违背借用规则，否则会导致运行期的 panic</li>
<li>RefCell 通过 unsafe 操作，可以为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，由于是 unsafe 操作，编译时期 <code>borrow(不可变借用)</code> 和 <code>borrow_mut(可变借用)</code> 方法内部实现不受借用规则的限制，所以编译不会报错。但是两个方法的接收者变量不是 unsafe 操作，接收者会受到借用规则的限制，RefCell 智能指针在运行时会记录不可变借用和可变借用的次数，如果方法接收者变量不符合借用规则，则会 panic。</li>
</ul>
<h3 id="选择-Cell-还是-RefCell"><a href="#选择-Cell-还是-RefCell" class="headerlink" title="选择 Cell 还是 RefCell"></a>选择 Cell 还是 RefCell</h3><ul>
<li>RefCell 适用 Copy 和非 Copy 类型，一般来说 Copy 类型可直接选择 Cell</li>
<li>Cell 通过内部的 <code>get set</code> 方法完成数据的获取和替换，即 <code>get</code> 提供不可变引用功能（读），<code>get set</code> 提供可变引用（读写）</li>
<li>RefCell 通过 unsafe 操作，可以为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，由于是 unsafe 操作，编译时期 <code>borrow(不可变借用)</code> 和 <code>borrow_mut(可变借用)</code> 方法内部实现不受借用规则的限制，所以编译不会报错。但是两个方法的接收者变量不是 unsafe 操作，接收者会受到借用规则的限制，RefCell 智能指针在运行时会记录不可变借用和可变借用的次数，如果方法接收者变量不符合借用规则，则会 panic。</li>
<li>Cell 没有额外的性能损耗，RefCell 有一点运行期开销，原因是它包含了一个字节大小的“借用状态”指示器，该指示器在每次运行时借用时都会被修改，进而产生一点开销。</li>
</ul>
<p>总之，当需要使用内部可变性时，首选 Cell，只有类型没有实现 Copy 特征时，再选择 RefCell。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code snipet 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = Cell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span> = &amp;x;</span><br><span class="line">x.<span class="title function_ invoke__">set</span>(<span class="number">2</span>);</span><br><span class="line">y.<span class="title function_ invoke__">set</span>(<span class="number">3</span>);</span><br><span class="line">z.<span class="title function_ invoke__">set</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">get</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// code snipet 2 编译失败，原因是不能对基础类型取引用</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span> = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">*y = <span class="number">3</span>;</span><br><span class="line">*z = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure>

<h3 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h3><p>Cell 与 RefCell 具有内部可变性，何为内部可变性？简单来说，<strong>对一个不可变的值进行可变借用</strong>。具体到 Cell 和 RefCell：</p>
<ul>
<li>Cell 通过内部的 <code>get set</code> 方法完成数据的获取和替换，即 <code>get</code> 提供不可变引用功能（读），<code>get set</code> 提供可变引用（读写）</li>
<li>RefCell 通过 unsafe 操作，可以为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，由于是 unsafe 操作，编译时期 <code>borrow(不可变借用)</code> 和 <code>borrow_mut(可变借用)</code> 方法内部实现不受借用规则的限制，所以编译不会报错。但是两个方法的接收者变量不是 unsafe 操作，接收者会受到借用规则的限制，RefCell 智能指针在运行时会记录不可变借用和可变借用的次数，如果方法接收者变量不符合借用规则，则会 panic。</li>
</ul>
<p>内部可变性并不符合 Rust 的基本借用规则：<strong>不能对一个不可变的值进行可变借用</strong>，这会破坏 Rust 的安全性保证。<br>这是因为当值不可变时，可能会有多个不可变的引用指向它，此时若将其中一个修改为可变的，会造成可变引用与不可变引用共存的情况，这可能会造成未定义的行为。</p>
<p>相反，可以对一个可变值进行不可变借用，根据借用规则只允许一个借用存在，所以当值可变时，最多只会有一个可变引用指向它，将其修改为不可变，那么最终依然是只有一个不可变的引用指向它。</p>
<p>Rust 的借用规则是内存安全的保证基石，但是有些场景遵守借用规则会非常麻烦，比如由于 Rust 的 mutable 特性，一个结构体中的字段，要么全都是 immutable，要么全部是 mutable，<strong>不支持针对部分字段进行设置</strong>。</p>
<p>比如；</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 RefCell，让一个结构体既有不可变字段，也有可变字段</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: RefCell&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">    name: RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;L&quot;</span>)),</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// p.age = 22; 错误的，如果需要age可更改，需要p是可变的。</span></span><br><span class="line">*p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;M&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">*p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;N&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;p:?&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果需要修改 age 则需要将整个 Person 设置为可变，这种行为不合理。</p>
<p>又比如为自定义结构体实现外部特征，外部特征的方法接收者为 <code>self: &amp;Self</code> 时：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在外部库中的特征，不能直接修改</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: <span class="type">String</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的数据结构和实现（消息队列结构体）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MsgQueue</span> &#123;</span><br><span class="line">    msg_cache: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自定义数据结构实现外部特征</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MsgQueue</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.msg_cache.<span class="title function_ invoke__">push</span>(msg) <span class="comment">// 报错，因为接收者 self 的类型是不可变引用，不能通过不可变引用修改值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为接收者 self 的类型是不可变引用，<strong>不能通过不可变引用修改值</strong>，所以上述代码编译就会报错。<br>并且由于实现的是<strong>外部特征，不能直接修改方法签名</strong>，此时就依靠 <code>RefCell</code> 的内部可变性为不可变值提供可变引用，进而修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在外部库中的特征，不能直接修改</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: <span class="type">String</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的数据结构和实现（消息队列结构体），用 RefCell 为一个无论是否可变的类型（变量/值），**对外提供该类型的不可变引用和可变引用**</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MsgQueue</span> &#123;</span><br><span class="line">    msg_cache: RefCell&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自定义数据结构实现外部特征</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MsgQueue</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: <span class="type">String</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译正常，虽然接收者 self 的类型是不可变引用，但 msg_cache 通过内部可变性提供了可变引用。</span></span><br><span class="line">        <span class="comment">// 此外，运行正常，RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则正常运行。</span></span><br><span class="line">        <span class="keyword">self</span>.msg_cache.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 RefCell 为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，解决了 <code>&amp;self</code> 不能通过不可变引用改变值的问题。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当遇到需要通过不可变引用修改数据，或者需要被到处使用和修改然后导致借用关系难以管理时，就可以考虑内部可变性的 Cell 和 RefCell。</p>
<h3 id="内部可变性注意事项"><a href="#内部可变性注意事项" class="headerlink" title="内部可变性注意事项"></a>内部可变性注意事项</h3><p>Cell 与 RefCell 的可变借用行为并不完全一致，这是由于存储的数据类型不一样决定的：<br>Cell 和 RefCell 都是智能指针，用一个栈上的新空间存储被管理的值，不同的是 Cell 存储 Copy 类型的值，而 RefCell 存储的是非 Copy 类型的栈上指针信息（通过栈上指针信息管理堆上实际数据）。</p>
<p>这种结构决定 Cell 和 RefCell 两者一个相同点和一个不同点：</p>
<ul>
<li>相同点：<strong>Cell 和 RefCell 存储被管理值的空间地址是不发生改变的</strong>，即存储值的空间地址不变，但地址对应的空间所存储的内容可以改变。<br>这就是为什么称为内部可变性而不是整体可变的原因。再深层研究会发现，如果整体可变，意味着空间大小不确定，就会违反 rust 不允许直接使用动态尺寸类型的规定。<br>这个性质决定了 Cell 不能存储不同的类型，而 RefCell 得通过指针引用的形式（固定尺寸）才能指向不同的类型（因为转换成固定尺寸类型，这些类型也可能会丢失部分信息的，参考不定长转换章节）。</li>
<li>不同点：可变借用行为不完全一致：Cell 不会改变原有变量的值，而 RefCell 会改变原有变量的值</li>
</ul>
<p><strong>相同点</strong></p>
<p>相同点有一个经典的例子：<code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 和 <code>RefCell&lt;Rc&lt;T&gt;&gt;</code>。</p>
<ul>
<li><code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 类型是一个通过 Rc 可供多个变量引用，通过 RefCell 可提供不可变&#x2F;可变借用的高级类型，也就是每个该类型的变量都可单独读写真实数据。</li>
<li><code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 类型也是一个内部可变性的高级类型，不仅可以提供不可变&#x2F;可变借用和无需手动管理复杂的生命周期，**<code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 还能通过 <code>Rc</code> 智能指针可以指向 T 类型的不同实例**，<code>RefCell&lt;T&gt;</code> 只能指向 T 类型的一个实例，因为这是内部可变性，而不是整体可变。</li>
</ul>
<p>由于内部可变性的限制，存储被管理值的空间地址是不发生改变的。<code>RefCell&lt;T&gt;</code> 只能指向同一数据地址，而通过 <code>Rc</code> 智能指针，<code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 解决了这个问题，可以指向同一类型的不同的实例。</p>
<p><strong>不同点</strong></p>
<p>用于 Copy 的 Cell，Cell 不会修改原有变量的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  use std::cell::Cell;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;num);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_cell</span> = Cell::<span class="title function_ invoke__">new</span>(num);</span><br><span class="line">num_cell.<span class="title function_ invoke__">set</span>(<span class="number">18</span>); <span class="comment">// Copy 不会修改原有变量的值</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;num_cell:?&#125;, &#123;num&#125;&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;num);</span><br></pre></td></tr></table></figure>

<p>用于非 Copy 的 RefCell，RefCell 的内部可变性是指当前<strong>变量&#x2F;值的空间存储的内容发生改变</strong>的行为，RefCell 会改变原有变量的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = Person &#123;</span><br><span class="line">    name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>),</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;p);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p_cell</span> = RefCell::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> p);</span><br><span class="line">p_cell.<span class="title function_ invoke__">borrow_mut</span>().name = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, p);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;p);</span><br></pre></td></tr></table></figure>

<h3 id="Rc-x2F-Arc-RefCell-的组合使用"><a href="#Rc-x2F-Arc-RefCell-的组合使用" class="headerlink" title="Rc&#x2F;Arc + RefCell 的组合使用"></a>Rc&#x2F;Arc + RefCell 的组合使用</h3><p>可以将所有权、借用规则和这些智能指针做一个对比：</p>
<table>
<thead>
<tr>
<th>Rust 规则</th>
<th>智能指针带来的额外规则</th>
</tr>
</thead>
<tbody><tr>
<td>一个数据只有一个所有者</td>
<td>Rc&#x2F;Arc 让一个数据可以拥有多个所有者</td>
</tr>
<tr>
<td>要么多个不可变借用，要么一个可变借用</td>
<td>RefCell 实现编译期可变、不可变引用共存</td>
</tr>
<tr>
<td>违背规则导致编译错误</td>
<td>违背规则导致运行时 panic</td>
</tr>
</tbody></table>
<p><code>Rc/Arc</code> 和 <code>RefCell</code> 合理结合，可以解决 Rust 中严苛的所有权和借用规则带来的某些场景下难使用的问题，甚至某些时候可以达到其他带 GC 的高级语言的程度。</p>
<ul>
<li>Rc&#x2F;Arc 智能指针通过引用计数（不可变引用）在符合借用规则的情况下实现一个值可以被多个变量访问。实现原理是：<strong>利用结构体存储底层数据的地址和引用次数</strong>，底层数据（实际类型数据）存放在堆上，结构体（胖指针，智能指针）存储在栈上作为管理信息数据管理实际类型数据。</li>
<li>RefCell 通过内部 unsafe 操作实现数据的可变性，为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rc与RefCell的结合使用，可以让rust变得像其他高级语言一样使用变量/值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>)));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">s1.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; ❌&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">s1.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; 2&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s:?&#125;&quot;</span>);</span><br><span class="line">*s2.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s:?&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>两者的结合流程认识 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>：</p>
<ul>
<li>RefCell 为一个无论是否可变的类型（变量&#x2F;值）提供不可变引用和可变引用，让数据减少借用规则的影响，让数据更容易被改变</li>
<li>Rc&#x2F;Arc 为一个类型提供简化的生命周期管理（回收资源），让 rust 的变量达到传统 GC 语言指针引用的便捷<br>Rc&#x2F;Arc 结合 RefCell 后功能上可以看成<strong>减少手动管理生命周期（回收资源）的步骤，并且可以随时获取不可变引用和可变引用的类型</strong>，即能达到传统带 GC 语言变量的程度。</li>
</ul>
<h4 id="性能损耗"><a href="#性能损耗" class="headerlink" title="性能损耗"></a>性能损耗</h4><p>功能上 Rc&#x2F;Arc 与 RefCell 的结合可以极大的降低生命周期管理和借用规则的复杂性，并且在性能上，这个组合也是非常高的。<br>大致相当于没有线程安全版本的 C++ std::shared_ptr 指针，事实上，C++ 这个指针的主要开销也在于原子性这个<strong>并发原语</strong>上，毕竟线程安全在哪个语言中开销都不小。</p>
<h4 id="内存损耗"><a href="#内存损耗" class="headerlink" title="内存损耗"></a>内存损耗</h4><p>Rc&#x2F;Arc 与 RefCell 的结合相当于以下结构体，从对内存的影响来看，仅仅多分配了三个 usize&#x2F;isize，并没有其它额外的负担。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// Rc 数据</span></span><br><span class="line">    strong_count: <span class="type">usize</span>,</span><br><span class="line">    weak_count: <span class="type">usize</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Refcell 数据</span></span><br><span class="line">    borrow_count: <span class="type">isize</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包裹的数据</span></span><br><span class="line">    item: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPU-损耗"><a href="#CPU-损耗" class="headerlink" title="CPU 损耗"></a>CPU 损耗</h4><p>从 CPU 来看，损耗如下：</p>
<ul>
<li>对 Rc<T> 解引用是免费的（编译期自动转换），但是 <code>*</code> 带来的间接取值并不免费</li>
<li>克隆 Rc<T> 需要将当前的引用计数跟 0 和 usize::Max 进行一次比较，然后将计数值加 1</li>
<li>释放（drop） Rc<T> 需要将计数值减 1， 然后跟 0 进行一次比较</li>
<li>对 RefCell 进行不可变借用，需要将 isize 类型的借用计数加 1，然后跟 0 进行比较</li>
<li>对 RefCell 的不可变借用进行释放，需要将 isize 减 1</li>
<li>对 RefCell 的可变借用大致流程跟上面差不多，但是需要先跟 0 比较，然后再减 1</li>
<li>对 RefCell 的可变借用进行释放，需要将 isize 加 1（存疑：为什么不是减 1）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://course.rs/advance/smart-pointer/cell-refcell.html#cpu-%E6%8D%9F%E8%80%97">https://course.rs/advance/smart-pointer/cell-refcell.html#cpu-%E6%8D%9F%E8%80%97</a></p>
<p>其实这些细节不必过于关注，只要知道 CPU 消耗也非常低，甚至编译器还会对此进行进一步优化！</p>
<h4 id="CPU-缓存-Miss"><a href="#CPU-缓存-Miss" class="headerlink" title="CPU 缓存 Miss"></a>CPU 缓存 Miss</h4><p>唯一需要担心的可能就是这种组合数据结构对于 CPU 缓存是否亲和，这个我们证明，只能提出来存在这个可能性，最终的性能影响还需要在实际场景中进行测试。</p>
<p>总之，分析这两者组合的性能还挺复杂的，大概总结下：</p>
<ul>
<li>从表面来看，它们带来的内存和 CPU 损耗都不大，但是由于 Rc 额外的引入了一次间接取值（<code>*</code>），在少数场景下可能会造成性能上的显著损失</li>
<li>CPU 缓存可能也不够亲和</li>
</ul>
<h3 id="过-Cell-from-mut-解决借用冲突"><a href="#过-Cell-from-mut-解决借用冲突" class="headerlink" title="过 Cell::from_mut 解决借用冲突"></a>过 Cell::from_mut 解决借用冲突</h3><p>使用迭代器时，如果恰巧碰上需要修改迭代器内的数据，就会遇到两种情况，这两种情况都不能通过借用规则的检查：</p>
<ul>
<li>不可变引用与可变引用一起使用：<code>iter()</code> 与 修改迭代器数据</li>
<li>可变引用与可变引用一起使用：<code>iter_mut()</code> 与 修改迭代器数据</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|x| **x &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// nums[i] = *num; 错误的，不能同时使用可变引用与不可变引用</span></span><br><span class="line">    <span class="comment">// i += 1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">filter</span>(|x| **x &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// nums[i] = *num; 错误的，不能同时使用多个可变借用</span></span><br><span class="line">    <span class="comment">// i += 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于迭代器出现的这两个场景，多个不可变引用与不可引用和可变引用同时使用的问题，可以<strong>通过索引解决</strong>，即不使用迭代器就不会出现问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">0</span>..nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">if</span> (nums[j] &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是使用索引就违背迭代器的初衷了，毕竟迭代器会让代码更加简洁。此时可以使用 <code>from_mut</code> 方法来解决这个问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用索引不符合迭代器的初衷，迭代器能够简化代码</span></span><br><span class="line"><span class="comment">// 此时可以通过 `Cell` 解决这个问题，因此 Cell 可以提供 set get 方法设置数据。</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// cell_slice 是一个 Cell 的引用类型，内部元素是切片</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">nums_slice</span> = &amp;<span class="keyword">mut</span> nums[..];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">cell_slice</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// as_slice() 方法返回的是一个不可变的切片，这意味着返回的切片不能被修改，也就是nums不能被修改。</span></span><br><span class="line"><span class="comment">// let cell_slice_ref = Cell::from_mut(&amp;mut nums.as_slice());</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 内部元素是切片引用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">cell_slice_ref</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums.<span class="title function_ invoke__">as_slice</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 nums 中的元素变为 Cell 类型，就能够访问和设置元素数据</span></span><br><span class="line"><span class="comment">// 手动声明形式</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice_nums</span> = <span class="built_in">vec!</span>[Cell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">2</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">3</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">4</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cell::from_mut 与 Cell::as_slice_of_cells 结合生成，两种写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">cell_slice</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice_cell</span> = Cell::<span class="title function_ invoke__">as_slice_of_cells</span>(cell_slice);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice_cell</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]).<span class="title function_ invoke__">as_slice_of_cells</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> slice_cell.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|x| (**x).<span class="title function_ invoke__">get</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    slice_cell[i].<span class="title function_ invoke__">set</span>(num.<span class="title function_ invoke__">get</span>()); <span class="comment">// 通过slice_cell改变nums的数据，避免直接修改nums让不可变引用和可变引用同时存在，导致借用规则检查失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;nums:?&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="内部可变性的-Drop-的流程认识，与-Rc-和-Arc-对比"><a href="#内部可变性的-Drop-的流程认识，与-Rc-和-Arc-对比" class="headerlink" title="内部可变性的 Drop 的流程认识，与 Rc 和 Arc 对比"></a>内部可变性的 Drop 的流程认识，与 Rc 和 Arc 对比</h3><p>在 Rc&#x2F;Arc 中，rust 通过**引用计数 (<code>reference counting</code>)**来简化不可变引用对应值的 Drop 实现。<br>在 Cell&#x2F;RefCell 中，rust 又是通过什么来维护 Drop 的流程？<br>Cell&#x2F;RefCell 的 Drop 流程很简单，与 rust 普通的堆上值是一样的释放流程。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Cell 与 RefCell 带来了内部可变性这个重要特性，将借用规则的检查从编译期推迟到运行期，但是这个检查并不能被绕过，RefCell 在运行期的报错会造成 panic。</li>
<li>RefCell 适用于编译器误报或者一个引用被在多个代码中使用、修改以至于难于管理借用关系时，还有就是需要内部可变性时。</li>
<li>从性能上看，RefCell 由于是非线程安全的，因此无需保证原子性，性能虽然有一点损耗，但是依然非常好，而 Cell 则完全不存在任何额外的性能损耗。</li>
<li>Rc 跟 RefCell 结合使用可以实现多个所有者共享同一份数据，非常好用，但是潜在的性能损耗也要考虑进去，建议对于热点代码使用时，做好 benchmark。</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//  use std::cell::Cell;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s_cell</span> = Cell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = s_cell.<span class="title function_ invoke__">get</span>(); <span class="comment">// 获取内部数据</span></span><br><span class="line">    s_cell.<span class="title function_ invoke__">set</span>(<span class="string">&quot;Hi&quot;</span>); <span class="comment">// 不可变引用直接修改内部数据</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s_cell:?&#125;, &#123;s&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyCell</span>&lt;T: <span class="built_in">Copy</span>&gt; &#123;</span><br><span class="line">        value: T,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span>&gt; MyCell&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>(v: T) <span class="punctuation">-&gt;</span> MyCell&lt;T&gt; &#123;</span><br><span class="line">            MyCell &#123; value: v &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">set</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, v: T) &#123;</span><br><span class="line">            <span class="keyword">self</span>.value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_cell</span> = MyCell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="comment">// my_cell.set(&quot;Hi&quot;); 错误，set函数 `set(&amp;mut self, v: T)` 要求接收者是可变引用 `self: &amp;mut Self`，而此时的 `my_cell` 是一个不可变引用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// **RefCell 的功能是通过 unsafe 操作，为一个类型（变量/值）对外提供该类型的不可变引用和可变引用，无论这个类型（变量/值）是否可变**。</span></span><br><span class="line">    <span class="comment">// RefCell 会在内部记录不可变引用（borrow）和可变引用（borrow_mut）的使用次数，通过使用次数来判断此时是否符合借用规则</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow</span>(); <span class="comment">// RefCell 记录一次不可变引用，不可变引用是1，可变引用是0，符合借用规则，正常运行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow</span>(); <span class="comment">// RefCell 记录一次不可变引用，不可变引用是2，可变引用是0，符合借用规则，正常运行</span></span><br><span class="line">                         <span class="comment">// let s2 = s.borrow_mut(); // RefCell 记录一次可变引用，不可变引用是2，可变引用是1，此时会报错，因为不能同时存在不可变引用和可变引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow_mut</span>(); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行</span></span><br><span class="line">                             <span class="comment">// let s2 = s.borrow_mut(); // RefCell 记录一次可变引用，不可变引用是0，可变引用是2，此时会报错，因为不能同时存在多个可变引用（一个可变引用周期内存在另外一个可变引用）</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = s.<span class="title function_ invoke__">borrow_mut</span>(); <span class="comment">// 给出原始数据的可变引用</span></span><br><span class="line">    *s2 = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;s2); <span class="comment">// 运行成功，无论是编译器还是运行时，都是符合rust的借用规则的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s_ref</span> = RefCell::<span class="title function_ invoke__">new</span>(s);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(s_ref); <span class="comment">// 释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 RefCell，让一个结构体既有不可变字段，也有可变字段</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        name: RefCell&lt;<span class="type">String</span>&gt;,</span><br><span class="line">        age: <span class="type">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;L&quot;</span>)),</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// p.age = 22; 错误的，如果需要age可更改，需要p是可变的。</span></span><br><span class="line">    *p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;M&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">    *p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;N&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;p:?&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rc与RefCell的结合使用，可以让rust变得像其他高级语言一样使用变量/值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    s1.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; ❌&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">    s1.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; 2&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s:?&#125;&quot;</span>);</span><br><span class="line">    *s2.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s:?&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器时，如果恰巧碰上需要修改迭代器内的数据，就会遇到两种情况：</span></span><br><span class="line">    <span class="comment">// 不可变引用与可变引用一起使用 iter() 与 修改迭代器数据</span></span><br><span class="line">    <span class="comment">// 可变引用与可变引用一起使用 iter_mut() 与 修改迭代器数据</span></span><br><span class="line">    <span class="comment">// 这两种情况都不能通过借用规则的检查</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|x| **x &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// nums[i] = *num; 错误的，不能同时使用可变引用与不可变引用</span></span><br><span class="line">        <span class="comment">// i += 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">filter</span>(|x| **x &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// nums[i] = *num; 错误的，不能同时使用多个可变借用</span></span><br><span class="line">        <span class="comment">// i += 1;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于迭代器出现的这两个场景，多个不可变引用与不可引用和可变引用同时使用的问题，可以通过索引来解决</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">0</span>..nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">if</span> (nums[j] &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用索引不符合迭代器的初衷，迭代器能够简化代码</span></span><br><span class="line">    <span class="comment">// 此时可以通过 `Cell` 解决这个问题，因此 Cell 可以提供 set get 方法设置数据。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="comment">// cell_slice 是一个 Cell 的引用类型，内部元素是切片</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nums_slice</span> = &amp;<span class="keyword">mut</span> nums[..];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cell_slice</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as_slice() 方法返回的是一个不可变的切片，这意味着返回的切片不能被修改，也就是nums不能被修改。</span></span><br><span class="line">    <span class="comment">// let cell_slice_ref = Cell::from_mut(&amp;mut nums.as_slice());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 内部元素是切片引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cell_slice_ref</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums.<span class="title function_ invoke__">as_slice</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 nums 中的元素变为 Cell 类型，就能够访问和设置元素数据</span></span><br><span class="line">    <span class="comment">// 手动声明形式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice_nums</span> = <span class="built_in">vec!</span>[Cell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">2</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">3</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">4</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cell::from_mut 与 Cell::as_slice_of_cells 结合生成，两种写法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cell_slice</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice_cell</span> = Cell::<span class="title function_ invoke__">as_slice_of_cells</span>(cell_slice);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice_cell</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]).<span class="title function_ invoke__">as_slice_of_cells</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> slice_cell.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|x| (**x).<span class="title function_ invoke__">get</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        slice_cell[i].<span class="title function_ invoke__">set</span>(num.<span class="title function_ invoke__">get</span>()); <span class="comment">// 通过slice_cell改变nums的数据，避免直接修改nums让不可变引用和可变引用同时存在，导致借用规则检查失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;nums:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Az</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2024/05/18/canvas-measureText-%E5%87%BD%E6%95%B0%E4%B8%8E%E7%9C%81%E7%95%A5%E5%8F%B7/">canvas: measureText 函数与省略号</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
  <div class="copyright">
    <span>© Az | Powered by Hexo & Chic</span>
  </div>
</footer>

    </div>
</body>

</html>