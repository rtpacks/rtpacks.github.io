<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Az">


    <meta name="subtitle" content="Welcome!">



    <meta name="keywords" content="blog luckydog Withx">


<title>rust: unsafe：unsafe superpowers | Az&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    


<link rel="stylesheet" href="/fonts/custom/iconfont.css">



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">I&#39;m Az</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">I&#39;m Az</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">rust: unsafe：unsafe superpowers</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Az</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">2024.07.02&nbsp;&nbsp;17:58:32</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Rust/">Rust</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="unsafe：unsafe-superpowers"><a href="#unsafe：unsafe-superpowers" class="headerlink" title="unsafe：unsafe superpowers"></a>unsafe：unsafe superpowers</h2><p>五种超能力（unsafe superpowers）：</p>
<ul>
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全 trait</li>
<li>访问 union 的字段</li>
</ul>
<h3 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h3><p>裸指针(raw pointer，又称原生指针) 在功能上跟引用类似，它需要显式地注明可变性。<br>但是裸指针又和引用有所不同，裸指针有两种形式: <code>*const T</code> 和 <code>*mut T</code>，代表不可变和可变。<br><code>*</code> 操作符常见的含义是用于解引用，但是在裸指针 <code>*const T</code> 和 <code>*mut</code> 中，<code>*</code> 只是类型名称的一部分，并没有解引用的含义。</p>
<p>截至目前，已经有三种类似指针的概念：<strong>引用、智能指针和裸指针</strong>。裸指针与引用、智能指针不同：</p>
<ul>
<li>可以绕过 Rust 的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针</li>
<li>不能保证指向的内存是合法的</li>
<li>可以是 null</li>
<li>没有实现任何自动的回收 (drop)</li>
</ul>
<p>使用裸指针可以创建两个可变指针都指向同一个数据，如果使用安全的 Rust 是无法做到这一点的，因为违背了借用规则。<br>因此虽然裸指针可以绕过借用规则，但是由此带来的数据竞争问题，需要程序员着重处理。</p>
<p>总之，裸指针跟 C 指针是非常像的，使用它需要以牺牲安全性为前提，但获得了更好的性能，也可以跟其它语言或硬件打交道。</p>
<h4 id="基于引用创建裸指针"><a href="#基于引用创建裸指针" class="headerlink" title="基于引用创建裸指针"></a>基于引用创建裸指针</h4><p>需要注意：<strong>基于引用创建裸指针是安全的行为，而解引用裸指针才是不安全的行为</strong>。即基于引用创建裸指针时不需要 unsafe，解引用时才需要。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于引用创建裸指针是安全的行为，解引用裸指针才是不安全的</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_ptr</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>; <span class="comment">// 创建裸指针是安全的</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_mutptr1</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>; <span class="comment">// 创建可变的裸指针，与不可变裸指针存储是一样的地址，但语义上是区分的</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_mutptr2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>; <span class="comment">// 裸指针是可以创建多个可变的</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// *num_ptr = 4;</span></span><br><span class="line">    *num_mutptr1 = <span class="number">4</span>;</span><br><span class="line">    *num_mutptr2 = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;num = &#123;&#125;, num_ptr = &#123;:p&#125;, num_mutptr1 = &#123;:p&#125;, num_mutptr2 = &#123;:p&#125;&quot;</span>,</span><br><span class="line">    num, num_ptr, num_mutptr1, num_mutptr2</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="基于智能指针创建裸指针"><a href="#基于智能指针创建裸指针" class="headerlink" title="基于智能指针创建裸指针"></a>基于智能指针创建裸指针</h4><p>与基于引用创建裸指针很类似，基于智能指针创建裸指针是安全的，解引用才是不安全的行为。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于智能指针创建裸指针</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_box</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_box_ptr</span> = &amp;*num_box <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_box_mutptr</span> = &amp;<span class="keyword">mut</span> *num_box <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// *num_box_ptr = 4;</span></span><br><span class="line">    *num_box_mutptr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;num_box = &#123;&#125;, num_box_ptr = &#123;:p&#125;, num_box_mutptr = &#123;:p&#125;&quot;</span>,</span><br><span class="line">    num_box, num_box_ptr, num_box_mutptr</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="基于内存地址创建裸指针"><a href="#基于内存地址创建裸指针" class="headerlink" title="基于内存地址创建裸指针"></a>基于内存地址创建裸指针</h4><p>基于一个内存地址来创建裸指针，可以想像这种行为是相当危险的。试图使用任意的内存地址往往是一种未定义的行为(undefined behavior)，因为该内存地址有可能存在值，也有可能没有。<br>同时编译器也有可能会优化这段代码，会造成没有任何内存访问发生，甚至程序还可能发生段错误(segmentation fault)。</p>
<p>正常项目几乎不会基于内存地址创建裸指针的做法。</p>
<h3 id="调用-unsafe-函数或方法"><a href="#调用-unsafe-函数或方法" class="headerlink" title="调用 unsafe 函数或方法"></a>调用 unsafe 函数或方法</h3><p>unsafe 函数从外表上来看跟普通函数并无区别，唯一的区别就是它需要使用 unsafe fn 来进行定义。<br>这种定义方式是为了告诉调用者：当调用此函数时需要注意它的相关需求，因为 Rust 无法担保调用者在使用该函数时能满足它所需的一切需求。</p>
<p>在编写 unsafe 函数时，有一点需要注意：<br>unsafe 函数体中无需使用 unsafe 语句块，unsafe 函数自身就是一个 unsafe 语句块，但一个函数包含了 unsafe 代码不代表需要将整个函数都定义为 unsafe fn。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">gen_unsafe</span>() &#123;</span><br><span class="line">    <span class="comment">// 基于智能指针创建裸指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_box</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_box_ptr</span> = &amp;*num_box <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_box_mutptr</span> = &amp;<span class="keyword">mut</span> *num_box <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="comment">// *num_box_ptr = 4;</span></span><br><span class="line">    *num_box_mutptr = <span class="number">4</span>; <span class="comment">// unsafe函数中无需unsafe语句块</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;gen_unsafe: num_box = &#123;&#125;, num_box_ptr = &#123;:p&#125;, num_box_mutptr = &#123;:p&#125;&quot;</span>,</span><br><span class="line">        num_box, num_box_ptr, num_box_mutptr</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">gen_unsafe</span>() &#125;</span><br></pre></td></tr></table></figure>

<h3 id="安全抽象包裹-unsafe-代码"><a href="#安全抽象包裹-unsafe-代码" class="headerlink" title="安全抽象包裹 unsafe 代码"></a>安全抽象包裹 unsafe 代码</h3><p>一个函数包含了 unsafe 代码不代表需要将整个函数都定义为 unsafe fn。事实上，在标准库中有大量的安全函数，它们内部都包含了 unsafe 代码块，例如 split_at_mut。</p>
<p>需求：将一个数组分成两个切片，且每一个切片都要求是可变的。类似这种需求在安全 Rust 中是很难实现的，因为要对同一个数组做两个可变借用，这不符合借用规则。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], mid: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    (&amp;<span class="keyword">mut</span> slice[..mid], &amp;<span class="keyword">mut</span> slice[mid..]) <span class="comment">// 出现多个可变借用，不符合 rust 的借用规则，编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 unsafe 绕过借用规则</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全抽象包裹 unsafe 代码，即将一个unsafe语句块放在安全的rust中</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(_slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], point: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = _slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(point &lt; len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = _slice.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="comment">// (&amp;mut _slice[..point], &amp;mut _slice[point..]) 出现多个可变借用，不符合 rust 的借用规则，编译失败</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 从可变裸指针获取可变引用</span></span><br><span class="line">        (</span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr, point),</span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="title function_ invoke__">add</span>(point), len - point),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">split_at_mut</span>(&amp;<span class="keyword">mut</span> arr, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>有几点需要注意：<br>as_mut_ptr 会返回指向 slice 首地址的裸指针 <code>*mut i32</code><br>slice::from_raw_parts_mut 方法通过指针和长度来创建一个新的切片，是一个 unsafe 方法。简单来说，该切片的初始地址是 ptr，长度为 point<br>ptr.add(point) 可以获取第二个切片的初始地址，是一个 unsafe 方法。由于切片中的元素是 i32 类型，每个元素都占用了 4 个字节的内存大小，因此不能简单的用 <code>ptr + mid</code> 来作为初始地址，而应该使用 <code>ptr + 4 * mid</code>，但是这种使用方式并不安全，因此 .add 方法是最佳选择</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全抽象包裹 unsafe 代码，即将一个unsafe语句块放在安全的rust中</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(_slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], point: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = _slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(point &lt; len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = _slice.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="comment">// (&amp;mut _slice[..point], &amp;mut _slice[point..]) 出现多个可变借用，不符合 rust 的借用规则，编译失败</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 从可变裸指针获取可变引用</span></span><br><span class="line">        (</span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr, point), <span class="comment">// from_raw_parts_mut 通过指针和长度来创建一个新的切片，是一个unsafe方法</span></span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="title function_ invoke__">add</span>(point), len - point), <span class="comment">// ptr.add(point) 可以获取第二个切片的初始地址，是一个unsafe方法</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">split_at_mut</span>(&amp;<span class="keyword">mut</span> arr, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h3 id="FFI-外部函数接口"><a href="#FFI-外部函数接口" class="headerlink" title="FFI 外部函数接口"></a>FFI 外部函数接口</h3><p>FFI（Foreign Function Interface）外部函数接口是用来与其它语言进行交互的接口设计，但并不是所有语言都称为 FFI。例如在 Java 中称之为 JNI（Java Native Interface）。</p>
<p>FFI 之所以存在是现实中很多代码库都是由不同语言编写的，如果需要使用某个库，但它是由其它语言编写的，往往只有几个选择：</p>
<ul>
<li>对该库进行重写或者移植</li>
<li>独立的服务调用（HTTP，gRPC）</li>
<li>使用 FFI</li>
</ul>
<p>在大部分情况下，重写或移植程序需要花费大量的时间和精力，独立的服务调用可能不满足时延，此时 FFI 就是最佳选择。<br>并且，在将其他语言的代码重构为 Rust 时，先将相关代码引入到 Rust 项目中，然后逐步重构，是一个非常不错的渐进式过程。</p>
<p>涉及到不同语言的交互，无法确定这个行为是否安全，因此 rust 的 FFI 需要 unsafe 的支持才能绕过编译器的审查，达到正常编译的目的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C 语言的代码定义在了 extern 代码块中， 而 extern 必须使用 unsafe 才能进行进行调用，原因在于其它语言的代码并不会强制执行 Rust 的规则，因此 Rust 无法对这些代码进行检查，最终还是要靠开发者自己来保证代码的正确性和程序的安全性。</p>
<blockquote>
<p>阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/ch19-01-unsafe-rust.html#%E4%BD%BF%E7%94%A8-extern-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E4%BB%A3%E7%A0%81">https://rustwiki.org/zh-CN/book/ch19-01-unsafe-rust.html#使用-extern-函数调用外部代码</a></li>
</ul>
</blockquote>
<h4 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h4><p><strong>应用二进制接口 ABI (Application Binary Interface) 定义了如何在汇编层面来调用该函数</strong>。</p>
<p>在 extern “C” 代码块列出想要调用的外部函数的签名。其中 “C” 定义了外部函数所使用的 ABI。在所有 ABI 中，C 语言的是最常见的。</p>
<h4 id="其它语言调用-Rust-函数"><a href="#其它语言调用-Rust-函数" class="headerlink" title="其它语言调用 Rust 函数"></a>其它语言调用 Rust 函数</h4><p>FFI 支持 rust 调用其他语言，也支持其他语言调用 rust。方法是使用 extern 来创建一个接口，其它语言可以通过该接口来调用相关的 Rust 函数。</p>
<p>供其他语言调用的 FFI 语法与调用其他语言的 FFI 有所不同，调用其他语言使用 extern 语句块，供其他语言调用是在函数定义时加上 extern 关键字。<br>除了加上 extern 关键字外，还需要加上 <code>#[no_mangle]</code> 注解，它的作用是告诉 Rust 编译器不要乱改函数的名称。</p>
<blockquote>
<p>Mangling：rust 编译时可能需要修改函数的名称，目的是为了让名称包含更多的信息，这样其它的编译部分就能从该名称获取相应的信息，这种修改会导致函数名变得相当不可读，并且使原函数名称失效。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_from_c</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Just called a Rust function from C!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问或修改可变静态变量"><a href="#访问或修改可变静态变量" class="headerlink" title="访问或修改可变静态变量"></a>访问或修改可变静态变量</h3><p>在之前的全局变量章节中有介绍。</p>
<h3 id="unsafe-特征"><a href="#unsafe-特征" class="headerlink" title="unsafe 特征"></a>unsafe 特征</h3><p>之所以会有 unsafe 的特征，是因为该特征至少有一个方法包含有编译器无法验证的内容。unsafe 的特征并不常见，已接触的只有 Send。<br>unsafe 特征需要使用 unsafe impl 实现方法，unsafe impl 通知编译器，程序相应的正确性由程序员保证。</p>
<p>阅读：<a target="_blank" rel="noopener" href="https://course.rs/advance/unsafe/superpowers.html#%E5%AE%9E%E7%8E%B0-unsafe-%E7%89%B9%E5%BE%81">https://course.rs/advance/unsafe/superpowers.html#实现-unsafe-特征</a></p>
<h3 id="访问-union-中的字段"><a href="#访问-union-中的字段" class="headerlink" title="访问 union 中的字段"></a>访问 union 中的字段</h3><p>union 主要用于跟 C 代码进行交互，访问 union 的字段是不安全的，因为 Rust 无法保证当前存储在 union 实例中的数据类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">MyUnion</span> &#123;</span><br><span class="line">    f1: <span class="type">u32</span>,</span><br><span class="line">    f2: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>union 的使用方式与结构体很相似，但是 union 的所有字段都共享同一个存储空间，意味着往 union 的某个字段写入值，会导致其它字段的值会被覆盖。</p>
<h3 id="实用工具库"><a href="#实用工具库" class="headerlink" title="实用工具库"></a>实用工具库</h3><p>unsafe 和 FFI 在 Rust 的使用场景中是相当常见，因此社区已经开发出一些实用的工具，可以改善相应的开发体验。这一部分可以在开发中尝试不同的工具。</p>
<h4 id="rust-bindgen-和-cbindgen"><a href="#rust-bindgen-和-cbindgen" class="headerlink" title="rust-bindgen 和 cbindgen"></a>rust-bindgen 和 cbindgen</h4><p>对于 FFI 调用来说，保证接口的正确性是非常重要的，这两个库可以帮我们自动生成相应的接口。<br>其中 rust-bindgen 用于生成在 Rust 中访问 C 的代码，而 cbindgen 则相反，用于生成在 C 中访问 Rust 的代码。</p>
<h4 id="cxx"><a href="#cxx" class="headerlink" title="cxx"></a>cxx</h4><p>如果需要跟 C++ 代码交互，则推荐使用 cxx，它提供了双向的调用，最大的优点就是安全，无需使用 unsafe 语句块。</p>
<h4 id="Miri"><a href="#Miri" class="headerlink" title="Miri"></a>Miri</h4><p>miri 可以生成 Rust 的中间层表示 MIR，它可以帮助检查常见的未定义行为(UB &#x3D; Undefined Behavior)，例如</p>
<ul>
<li>内存越界检查和内存释放后再使用(use-after-free)</li>
<li>使用未初始化的数据</li>
<li>数据竞争</li>
<li>内存对齐问题</li>
</ul>
<p>可以通过 rustup component add miri 来安装它，并通过 cargo miri 来使用，同时还可以使用 cargo miri test 来运行测试代码。<br>但需要注意的是，它只能帮助识别被执行代码路径的风险，那些未被执行到的代码是没办法被识别的。</p>
<h4 id="Prusti"><a href="#Prusti" class="headerlink" title="Prusti"></a>Prusti</h4><p>prusti 需要自己来构建一个证明，然后通过它证明代码中的不变量是正确被使用的，当在安全代码中使用不安全的不变量时，就会非常有用。<br>阅读：<a target="_blank" rel="noopener" href="https://viperproject.github.io/prusti-dev/user-guide/">https://viperproject.github.io/prusti-dev/user-guide/</a></p>
<h4 id="Clippy"><a href="#Clippy" class="headerlink" title="Clippy"></a>Clippy</h4><p>官方的 clippy 检查器提供了有限的 unsafe 支持，虽然不多但是至少有一定帮助。例如 missing_safety_docs 检查可以帮助检查哪些 unsafe 函数遗漏了文档。<br>需要注意的是：Rust 编译器并不会默认开启所有检查，可以调用 rustc -W help 来看看最新的信息。</p>
<h4 id="模糊测试-fuzz-testing"><a href="#模糊测试-fuzz-testing" class="headerlink" title="模糊测试(fuzz testing)"></a>模糊测试(fuzz testing)</h4><p>在 Rust Fuzz Book 中列出了一些 Rust 可以使用的模糊测试方法。同时还可以使用 rutenspitz 这个过程宏来测试有状态的代码，例如数据结构。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>unsafe 只应该用于仅限的五种场景，其它场景应该坚决的使用安全的代码。<br>总之，能不使用 unsafe 一定不要使用，就算使用也要控制好边界，让范围尽可能的小，只有真的需要 unsafe 的代码才应该包含其中, 而不是将无关代码也纳入进来。</p>
<h3 id="进一步学习"><a href="#进一步学习" class="headerlink" title="进一步学习"></a>进一步学习</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/">https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/</a></li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 基于引用创建裸指针是安全的行为，解引用裸指针才是不安全的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_ptr</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>; <span class="comment">// 创建裸指针是安全的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_mutptr1</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>; <span class="comment">// 创建可变的裸指针，与不可变裸指针存储是一样的地址，但语义上是区分的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_mutptr2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>; <span class="comment">// 裸指针是可以创建多个可变的</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// *num_ptr = 4;</span></span><br><span class="line">        *num_mutptr1 = <span class="number">4</span>;</span><br><span class="line">        *num_mutptr2 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;num = &#123;&#125;, num_ptr = &#123;:p&#125;, num_mutptr1 = &#123;:p&#125;, num_mutptr2 = &#123;:p&#125;&quot;</span>,</span><br><span class="line">        num, num_ptr, num_mutptr1, num_mutptr2</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于智能指针创建裸指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_box</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_box_ptr</span> = &amp;*num_box <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_box_mutptr</span> = &amp;<span class="keyword">mut</span> *num_box <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// *num_box_ptr = 4;</span></span><br><span class="line">        *num_box_mutptr = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;num_box = &#123;&#125;, num_box_ptr = &#123;:p&#125;, num_box_mutptr = &#123;:p&#125;&quot;</span>,</span><br><span class="line">        num_box, num_box_ptr, num_box_mutptr</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">gen_unsafe</span>() &#123;</span><br><span class="line">        <span class="comment">// 基于智能指针创建裸指针</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_box</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num_box_ptr</span> = &amp;*num_box <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num_box_mutptr</span> = &amp;<span class="keyword">mut</span> *num_box <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">        <span class="comment">// *num_box_ptr = 4;</span></span><br><span class="line">        *num_box_mutptr = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;gen_unsafe: num_box = &#123;&#125;, num_box_ptr = &#123;:p&#125;, num_box_mutptr = &#123;:p&#125;&quot;</span>,</span><br><span class="line">            num_box, num_box_ptr, num_box_mutptr</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">gen_unsafe</span>() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全抽象包裹 unsafe 代码，即将一个unsafe语句块放在安全的rust中</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(_slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], point: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = _slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(point &lt; len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ptr</span> = _slice.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">        <span class="comment">// (&amp;mut _slice[..point], &amp;mut _slice[point..]) 出现多个可变借用，不符合 rust 的借用规则，编译失败</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// 从可变裸指针获取可变引用</span></span><br><span class="line">            (</span><br><span class="line">                slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr, point), <span class="comment">// from_raw_parts_mut 通过指针和长度来创建一个新的切片，是一个unsafe方法</span></span><br><span class="line">                slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="title function_ invoke__">add</span>(point), len - point), <span class="comment">// ptr.add(point) 可以获取第二个切片的初始地址，是一个unsafe方法</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">split_at_mut</span>(&amp;<span class="keyword">mut</span> arr, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FFI</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs</span>(-<span class="number">3</span>)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Az</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Rust/"># Rust</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/07/06/rust-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/">rust: 内联汇编</a>
            
            
            <a class="next" rel="next" href="/2024/07/01/rust-unsafe%EF%BC%9Aunsafe-%E7%9A%84%E4%BD%9C%E7%94%A8/">rust: unsafe：unsafe 的作用</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
  <div class="copyright">
    <span>© Az | Powered by Hexo & Chic</span>
  </div>
</footer>

    </div>
</body>

</html>