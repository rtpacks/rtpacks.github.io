<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Az">


    <meta name="subtitle" content="Welcome!">



    <meta name="keywords" content="blog luckydog Withx">


<title>rust: async 异步编程：Future 特征与任务调度 | Az&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    


<link rel="stylesheet" href="/fonts/custom/iconfont.css">



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">I&#39;m Az</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">I&#39;m Az</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">rust: async 异步编程：Future 特征与任务调度</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Az</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">2024.07.13&nbsp;&nbsp;00:16:30</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Rust/">Rust</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="async-异步编程：Future-特征与任务调度"><a href="#async-异步编程：Future-特征与任务调度" class="headerlink" title="async 异步编程：Future 特征与任务调度"></a>async 异步编程：Future 特征与任务调度</h2><blockquote>
<p>本节难度高，需要细细斟酌</p>
</blockquote>
<p>Future 是一个能<strong>产出值的异步计算</strong>(值可能为空，例如 <code>()</code>)。它是异步函数的返回值和被执行的关键，异步函数则是异步编程的核心，所以 Future 特征是 Rust 异步编程的核心。</p>
<p>通常获取一个状态有两种方式：定时轮询、事件触发。定时轮询非常简单，设置好循环及时间间隔即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// let status = fetchStatus();</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">status</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> status &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件通知往往与回调相关，更简单来说，<strong>函数是可以当作参数传递的</strong>，外部传入一个回调函数，当内部执行完成&#x2F;错误时调用回调函数，此时由内部通知外部，外部就可以获取内部的状态。<br>rust 中 Future 设计的非常巧妙，采用是事件通知的方式以便提高效率，这与 JavaScript 的 DOM 事件触发非常相似：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Poll</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ready</span>(T),</span><br><span class="line">    Pending,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">SimpleFuture</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, wake: <span class="title function_ invoke__">fn</span>()) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>fn()</code> 是一个函数指针类型，表示一个不带参数且不返回值的函数，类似的形式有 <code>fn(i32) -&gt; i32</code> <code>fn(&amp;str) -&gt; String </code> 等。</p>
</blockquote>
<p>Future 是惰性的，需要在 poll 函数调用后才会真正执行，同时 poll 只会获取异步任务执行的状态，对异步任务执行流程和结果没有任何影响。</p>
<p>当前 poll 函数执行时获取的状态有两种：</p>
<ul>
<li>Future 可以被完成，则会返回 Poll::Ready(result)</li>
<li>Future 仍在执行，则返回 <code>Poll::Pending</code>，并且安排一个 wake 回调函数：当未来 Future 准备好进一步执行时，该回调函数会被调用，接着管理该 Future 的执行器(例如 block_on 函数)收到信息会再次调用 poll 方法，此时 Future 就可以继续执行了。</li>
</ul>
<p>这种 “事件通知 -&gt; 执行” 的方式可以精确的执行该 Future，要比定时轮询所有 Future 来的高效。</p>
<p>以一个从 socket 读取数据的场景为例：</p>
<ul>
<li>如果有数据，可以直接读取数据并返回 Poll::Ready(data)</li>
<li>如果没有数据，Future 会被阻塞且不会再继续执行，此时它会注册一个 wake 函数，当 socket 数据准备好时，该函数将被调用以通知执行器 Future 已经准备好，可以继续执行，然后执行器再次调用 poll 获取状态。</li>
</ul>
<p>伪代码流程：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SocketRead</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    socket: &amp;<span class="symbol">&#x27;a</span> Socket,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SimpleFuture</span> <span class="keyword">for</span> <span class="title class_">SocketRead</span>&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, wake: <span class="title function_ invoke__">fn</span>()) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.socket.<span class="title function_ invoke__">has_data_to_read</span>() &#123;</span><br><span class="line">            <span class="comment">// socket有数据，写入buffer中并返回</span></span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(<span class="keyword">self</span>.socket.<span class="title function_ invoke__">read_buf</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// socket中还没数据，注册一个`wake`函数，当数据可用时，该函数会被调用，</span></span><br><span class="line">            <span class="comment">// 然后当前Future的执行器会再次调用`poll`方法，此时就可以读取到数据</span></span><br><span class="line">            <span class="keyword">self</span>.socket.<span class="title function_ invoke__">set_readable_callback</span>(wake);</span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Future，无需开发者手动管理轮询逻辑，在数据未准备好前注册 wake 函数并返回 <code>Poll::Pedning</code> 状态。<br>执行器暂停当前 Future 的执行，等数据准备好时，socket 内部调用注册的 wake 回调函数通知执行器可以运行当前的 Future，运行后获取 <code>Poll::Ready</code> 状态，表示可以结束。</p>
<p>注意，当前 Future 是有一个数据可以表达任务状态的，如 <code>socket.has_data_to_read</code>，也就是 poll Future 后获取的状态信息来源于当前 Future 某个数据表达的状态。<br>简单来说：<strong>Future 一定要有一个能表达任务状态的数据</strong>，这样执行器在 poll Future 时才知道对 Future 的操作是等待 <code>Poll::Pedning</code> 还是结束 <code>Poll::Ready</code>。</p>
<p>这种由执行器调度执行，回调函数作为通信触发的方式，能为 IO 密集型带来极高的并发量，并且可以做到无内存分配的状态机即无需手动管理执行状态和维护相关的同步信息。</p>
<p>一个 Future 可以在内部管理多个子 Future，并发执行但统一结束：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个 Future 可以管理多个子 Future，使其并发执行。之所以可以并发，是因为两个子 Future 的轮询可以交替进行，一个阻塞另一个就可以立刻执行，反之亦然</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Join</span>&lt;FutureA, FutureB&gt; &#123;</span><br><span class="line">    <span class="comment">// 结构体的每个字段都包含一个 Future，可以运行直到完成，等到当前 Future 完成后，字段会被设置为 `None`. 这样 Future 完成后就不会再被轮询</span></span><br><span class="line">    a: <span class="type">Option</span>&lt;FutureA&gt;,</span><br><span class="line">    b: <span class="type">Option</span>&lt;FutureB&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;FutureA, FutureB&gt; SimpleFuture <span class="keyword">for</span> <span class="title class_">Join</span>&lt;FutureA, FutureB&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    FutureA: SimpleFuture&lt;Output = ()&gt;,</span><br><span class="line">    FutureB: SimpleFuture&lt;Output = ()&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, wake: <span class="title function_ invoke__">fn</span>()) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="comment">// 尝试去完成一个 Future `a`，等到当前 Future 完成后，字段会被设置为 `None`. 这样 Future 完成后就不会再被轮询</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(a) = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.a &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Poll</span>::<span class="title function_ invoke__">Ready</span>(()) = a.<span class="title function_ invoke__">poll</span>(wake) &#123;</span><br><span class="line">                <span class="keyword">self</span>.a.<span class="title function_ invoke__">take</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试去完成一个 Future `b`，等到当前 Future 完成后，字段会被设置为 `None`. 这样 Future 完成后就不会再被轮询</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(b) = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.b &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Poll</span>::<span class="title function_ invoke__">Ready</span>(()) = b.<span class="title function_ invoke__">poll</span>(wake) &#123;</span><br><span class="line">                <span class="keyword">self</span>.b.<span class="title function_ invoke__">take</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.a.<span class="title function_ invoke__">is_none</span>() &amp;&amp; <span class="keyword">self</span>.b.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">            <span class="comment">// 两个 Future都已完成 - 可以成功地统一返回</span></span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 至少还有一个 Future 没有完成任务，因此返回 `Poll::Pending`。当该 Future 再次准备好时，通过调用`wake()`函数来继续执行</span></span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Future 管理子 Future 需要注意一点：避免 Future 完成后被再次执行的情况，这里通过 Option 实现，将已完成的 Future 从 Some 变为 None。</p>
<p>除了并发执行外，使用 Future 管理子 Future 也可以实现串行执行，并发执行和串行执行是最基础的使用 Future 特征表达异步控制流。</p>
<p>在实际场景中，通知外部的方式不会像 wake 函数这么简单，想象一下在一个成百上千的 Tcp 连接（Future）中，<br><strong>所有的 Future 共享一个 waker</strong>，如果 wake 不携带数据，执行器就不能确定是哪个 Future 应该被唤醒并 poll。<br>为了能区分由不同 Future wake 触发的信息，需要一个能携带数据的通信方式。</p>
<p>rust 通过 Context 和 Waker 的组合，每个 Future 在注册其 wake 函数时，可以将自身的信息存储在 Waker 中。当 wake 被调用时，Future 的自身信息会被传递给执行器，从而使执行器能够正确识别并调度特定的 Future。</p>
<p>futures 库中 Future 特征的定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Future</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="comment">// 相比较 SimpleFuture，futures 中的 Future 特征主要由两点不同</span></span><br><span class="line">    <span class="comment">// 1. `self` 是 `Pin&lt;&amp;mut Self&gt;`，而不是 `&amp;mut self`</span></span><br><span class="line">    <span class="comment">// 2. `wake: fn()` 修改为 `cx: &amp;mut Context&lt;&#x27;_&gt;`:</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Waker-唤醒任务"><a href="#Waker-唤醒任务" class="headerlink" title="Waker 唤醒任务"></a>Waker 唤醒任务</h3><p>正常情况下，Future 是一个耗时任务，在第一次被 poll 时通常还未完成。此时 Future 就需要在自身再次准备好被执行时，借助 Waker 通知执行器，让执行器再次调度执行 Future 自身。</p>
<p>为了简化实现以及降低理解成本，可以新开一个线程，利用线程休眠模拟 Future 的异步任务（例如网络请求），线程休眠中代表 Future 的异步任务正在执行，线程休眠结束代表 Future 的异步任务运行结束，可以通知执行器调用 poll，以便 Future 被执行。</p>
<p>在之前的 SimpleFuture 中有一个注意点：<br><strong>Future 一定要有一个能表达任务状态的数据</strong>，这样执行器在 poll Future 时才知道对 Future 的操作是等待 <code>Poll::Pedning</code> 还是结束 <code>Poll::Ready</code>。</p>
<p>根据这个注意点，TimeFuture 需要一个状态用来标识 TimeFuture 的异步任务是否完成，这个状态又是由新线程的休眠状态决定，所以 TimeFuture 要与新线程共享这份数据。<br>同时由于是在不同线程间共享状态，需要考虑所有权和并发状态，即需要使用 Arc 和 Mutex 两个工具。</p>
<p><strong>整体流程如下：</strong></p>
<p>新线程与 TimeFuture 共享一个状态，TimeFuture 根据这个状态标识 TimeFuture 的异步任务是否完成。<br>在生成 TimeFuture 时开始执行异步任务，当前案例中，异步任务就是新线程休眠。<br>线程休眠结束后修改与 TimeFuture 共享的状态数据并调用 wake，表示 Future 的异步任务执行结束，可以再次被 poll。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SharedState</span> &#123;</span><br><span class="line">    <span class="comment">// 异步任务是否已经结束（线程休眠是否已经结束）</span></span><br><span class="line">    completed: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TimeFuture 需要一个状态标识是否完成，这个状态是由休眠线程传递的，涉及到多线程需要使用 Arc，并且状态应该是带锁的，避免多线程数据访问问题</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TimeFuture</span> &#123;</span><br><span class="line">    shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">TimeFuture</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(</span><br><span class="line">        <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;,</span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">&#x27;_</span>&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> std::task::Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="comment">// poll 时检查任务状态，来确定是否可以结束当前 Future</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shared_state</span> = <span class="keyword">self</span>.shared_state.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> shared_state.completed &#123;</span><br><span class="line">            std::task::Poll::<span class="title function_ invoke__">Ready</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::task::Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码可以描述一个 Future 的运行逻辑，但还缺少三个步骤：</p>
<ol>
<li>Future 的创建</li>
<li>Future 执行异步任务（新线程休眠）</li>
<li>Future 执行完异步任务（线程休眠）后让执行器再次 poll 当前 Future</li>
</ol>
<p>创建 Future 和 Future 执行异步任务</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Future 运行异步任务的逻辑</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TimeFuture</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(duration: Duration) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shared_state</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(SharedState &#123; completed: <span class="literal">false</span> &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_shared_state</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;shared_state);</span><br><span class="line">        <span class="comment">// 用线程休眠模拟异步任务</span></span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(duration);</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex</span> = _shared_state.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="comment">// 修改异步任务状态，模拟网络结束连接或IO关闭等场景。</span></span><br><span class="line">            <span class="comment">// Future 一定要有一个表示执行异步任务状态的数据，这样才能让执行器在 Poll 当前 Future 时知道该结束 `Poll::Ready` 还是等待 `Poll::Pending`</span></span><br><span class="line">            mutex.completed = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Self</span> &#123; shared_state &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，异步任务结束后需要调用 wake 让当前 Future 被再次 poll 执行，wake 应该来自哪？在什么时候、以及怎么注册 wake？<br>其实很简单，在 Future 特征定义中，poll 函数 <code>fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#39;_&gt;) -&gt; Poll&lt;Self::Output&gt;;</code> 的 <code>cx: &amp;mut Context&lt;&#39;_&gt;</code> 就是注册、和外部调用的 wake 的来源。</p>
<p>wake 注册就是将 wake 传递给外部，用 wake 关联当前 Future 的过程，而让外部调用 wake 函数就是在让执行器再次 poll wake 关联的 Future 的过程。<br><code>cx: &amp;mut Context&lt;&#39;_&gt;</code> 中的 wake 指向的作用域就包含当前 Future 对应的信息，供外部调用时就可以让执行器正确识别并调度当前特定的 Future。</p>
<blockquote>
<p>每个 Future 在注册其 wake 函数时，将自身的信息存储在 Waker 中。<strong>当 wake 被调用时 Future 的自身信息会被传递给执行器</strong>，从而使执行器能够正确识别并调度特定的 Future。</p>
</blockquote>
<p>因此，第三步骤其实是当前 Future 被 poll 执行时将 wake 存储起来，然后外部在异步任务结束后，调用 wake 函数让执行器正确识别 Future 并再次 poll 当前 Future 的过程。</p>
<p><strong>注意：这里的外部是指当前线程外。</strong></p>
<p>SharedState 增加存储 waker：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用线程休眠模拟异步任务，如网络请求</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FutureStatus</span> &#123;</span><br><span class="line">    init,</span><br><span class="line">    pending,</span><br><span class="line">    completed,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SharedState</span> &#123;</span><br><span class="line">    <span class="comment">// 异步任务的状态</span></span><br><span class="line">    status: FutureStatus,</span><br><span class="line">    <span class="comment">// 当前 Future 被 poll 执行时将 wake 存储起来，然后外部在异步任务结束后，调用 wake 函数让执行器正确识别 Future 并再次 poll 当前 Future</span></span><br><span class="line">    waker: <span class="type">Option</span>&lt;std::task::Waker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poll Future 时存储 waker，此时才开始执行异步任务，这也是为什么 future 被称为是惰性的，因为只有在第一次 poll 后才会开始执行。在编写 Future 时也需要注意应将异步任务放在第一次 poll 中执行。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TimeFuture 需要一个状态标识是否完成，这个状态是由休眠线程传递的，涉及到多线程需要使用 Arc，并且状态应该是带锁的，避免多线程数据访问问题</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TimeFuture</span> &#123;</span><br><span class="line">    shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现 Future poll 的逻辑</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">TimeFuture</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(</span><br><span class="line">        <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;,</span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">&#x27;_</span>&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> std::task::Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="comment">// poll 时检查任务状态，来确定是否可以结束当前 Future</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shared_state</span> = <span class="keyword">self</span>.shared_state.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">match</span> shared_state.status &#123;</span><br><span class="line">            FutureStatus::init =&gt; &#123;</span><br><span class="line">                <span class="comment">// 选择每次都`clone`的原因是： `TimerFuture`可以在执行器的不同任务间移动，如果只克隆一次，</span></span><br><span class="line">                <span class="comment">// 那么获取到的`waker`可能已经被篡改并指向了其它任务，最终导致执行器运行了错误的任务</span></span><br><span class="line">                shared_state.waker = <span class="title function_ invoke__">Some</span>(cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">clone</span>());</span><br><span class="line">                shared_state.status = FutureStatus::pending;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">_shared_state</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.shared_state);</span><br><span class="line">                <span class="comment">// 用线程休眠模拟异步任务</span></span><br><span class="line">                thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">                    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">6</span>));</span><br><span class="line">                    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex</span> = _shared_state.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    <span class="comment">// 修改异步任务状态，模拟网络结束连接或IO关闭等场景。</span></span><br><span class="line">                    <span class="comment">// Future 一定要有一个表示执行异步任务状态的数据，这样才能让执行器在 Poll 当前 Future 时知道该结束 `Poll::Ready` 还是等待 `Poll::Pending`</span></span><br><span class="line">                    mutex.status = FutureStatus::completed;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 在异步任务结束后，调用 poll Future 的 waker</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(waker) = mutex.waker.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                        waker.<span class="title function_ invoke__">wake</span>()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                std::task::Poll::Pending</span><br><span class="line">            &#125;</span><br><span class="line">            FutureStatus::pending =&gt; std::task::Poll::Pending,</span><br><span class="line">            FutureStatus::completed =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;completed&quot;</span>);</span><br><span class="line">                std::task::Poll::<span class="title function_ invoke__">Ready</span>(())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Future 生成</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TimeFuture</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shared_state</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(SharedState &#123;</span><br><span class="line">            status: FutureStatus::init,</span><br><span class="line">            waker: <span class="literal">None</span>,</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Self</span> &#123; shared_state &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，一个简单的 TimeFuture 就已创建成功，测试代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">futures::executor::<span class="title function_ invoke__">block_on</span>(TimeFuture::<span class="title function_ invoke__">new</span>());</span><br></pre></td></tr></table></figure>

<h3 id="执行器-Executor"><a href="#执行器-Executor" class="headerlink" title="执行器 Executor"></a>执行器 Executor</h3><p>Rust 的 Future 是惰性的，只有被 poll 后才会开始执行，rust poll Future 一般有两种方式：</p>
<ul>
<li>在 async 函数中使用 .await 来调用另一个 async 函数，这个方式只能解决 async 内部的问题，因为 <code>.await</code> 只允许用在 async 函数中。因此这种方式不能在非 async 函数中<strong>阻塞等待 async 函数的完成</strong>，也就可能导致 async 函数的 Future 还未开始执行，当前的非 async 函数就已经退出函数栈。</li>
<li>执行器 executor 会管理一批 Future (最外层的 async 函数)，然后通过不停地 poll 推动它们直到完成。最开始，执行器会先 poll 一次 Future ，然后不会再主动去 poll，而是等待 Future 通过调用 wake 函数来通知它可以继续，它才会继续去 poll。这种 wake 通知然后 poll 的方式会不断重复，直到 Future 完成。</li>
</ul>
<p>在 <code>TimeFuture</code> 的实现测试中，使用的就是执行器 poll Future。执行器会不断 poll Future 直至结束。下面来构建一个自己的执行器，用来运行自定义的 <code>TimeFuture</code>。</p>
<h4 id="构建执行器"><a href="#构建执行器" class="headerlink" title="构建执行器"></a>构建执行器</h4><blockquote>
<p>这里将每个步骤描述的比较详细，如果只需要了解，可以看：<a target="_blank" rel="noopener" href="https://course.rs/advance/async/future-excuting.html#%E6%89%A7%E8%A1%8C%E5%99%A8-executor">https://course.rs/advance/async/future-excuting.html#执行器-executor</a></p>
</blockquote>
<p>在 rust 中，执行器是<strong>不停地 poll 推动 Future 获取状态，直到 Future 完成</strong>。需要注意的是，执行器会先 poll 一次 Future，然后不会再主动去 poll，而是等待 Future 通过调用 wake 函数来通知执行器可以继续，执行器才会继续去 poll。</p>
<p>观察原有的 TimeFuture 实现，会发现 TimeFuture 不会自动触发，并且在被动触发后只会在异步任务结束时触发一次 wake。<br>这与执行器会先 poll 一次 Future，然后等待 Future 调用 wake 来通知执行器可以继续，形成执行器不停的 poll Future 的场景还少了两点：</p>
<ol>
<li>执行器需要主动触发一次 Future</li>
<li>Future 需要不断地触发 wake，达到执行器不停的 poll Future 的目的</li>
</ol>
<p>rust 通过维护一个消息通道（channel）来实现执行器 Executor 的调度执行，这其中的逻辑与 JavaScript 的事件循环队列非常类似。<br>这里通过同步消息通道，简单实现一个 Executor，具体划分为：</p>
<ul>
<li>执行器 <code>Executor</code> 作为通道的接收者 Receiver，如果有 Future 进入消息通道，Executor 就开始执行 Future，如果消息通道为空，则阻塞当前函数。</li>
<li>创建者 <code>Spawner</code> 作为发送者 Transmitter，将创建 Future 并将其发送到消息通道中，触发执行器 <code>Executor</code> 去 poll Future。</li>
</ul>
<p><strong>对于当前 Future 缺少的两个点</strong></p>
<p>第一点：执行器 Executor 主动触发 poll 一次 Future。<br>这一点很容易实现，模拟流程：创建者（发送者）创建 Future，然后将 Future 发送到消息通道，接收者（执行器）接收，然后主动 poll 一次 Future。</p>
<p>第二点：Future 需要不断地触发 wake，达到执行器不停的 poll Future 的目的。<br>这一点的实现并不简单，有两种方式可以不断地触发 wake：</p>
<ol>
<li>没有任务调度系统，任务状态由 Future 自身管理。Future 在被第一次 poll 后，主动调用 wake，触发 poll。</li>
<li>有任务调度系统，任务状态由 Executor 管理，可操控性大，Future 也不会引入无关的逻辑。</li>
</ol>
<p>第一种方式，没有任务调度系统，任务状态由 Future 自身管理，很明显可控性不大，如想要根据某个条件切换，Future 的 poll 逻辑耦合度很大：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">impl Future for TimeFuture &#123;</span><br><span class="line">    type Output = ();</span><br><span class="line"></span><br><span class="line">    fn poll(</span><br><span class="line">        self: Pin&lt;&amp;mut Self&gt;,</span><br><span class="line">        cx: &amp;mut std::task::Context&lt;&#x27;_&gt;,</span><br><span class="line">    ) -&gt; std::task::Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        shared_state.waker = Some(cx.waker().clone());</span><br><span class="line"><span class="addition">+       shared_state.waker.wake();</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return match shared_state.status &#123;</span><br><span class="line">             ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式，有任务调度系统，由 Executor 调度管理，可操控性大，Future 的 poll 函数也不会引入无关的逻辑。分析流程：</p>
<ol>
<li>构建一个消息任务队列，生成执行器（接收者）和创建者（发送者）。</li>
<li>执行器从消息通道中阻塞性的接收 Future，当 Future 状态未完成时，会默认调用(第 1 次或第 N+1 次) Future 的 poll 函数获取 Future 状态。</li>
<li>如果 Future 未完成，为了让执行器不停的 poll Future，要将 Future <strong>重新发送到消息通道</strong>中，这样就会重复 2 步骤，让执行器再次 poll Future。</li>
</ol>
<blockquote>
<p>为什么要使用任务队列来存储待执行的 Future?<br>在使用 rust 提供的执行器时，提到过 Future 的执行方式：“事件通知 -&gt; 执行” 的方式可以精确的执行该 Future，要比定时轮询所有 Future 来的高效。<br>使用任务队列，就是为了提高效率。</p>
</blockquote>
<p>构建消息通道，生成执行器（接收者）和创建者（发送者），伪代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过同步消息通道模拟 Executor 调度流程</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FutureChannel</span>(Spawner, Executor);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FutureChannel</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(size);</span><br><span class="line">        <span class="title function_ invoke__">Self</span>(Spawner &#123; task_sender: tx &#125;, Executor &#123; task_queue: rx &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行器从消息通道中阻塞性的接收 Future，当 Future 状态为未完成时，调用 Future 的 poll 函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">// 一个Future一般只会在一个线程中执行，不需要 Mutex，但是编译器无法知道`Future`只会在一个线程内被修改，并不会被跨线程修改。</span></span><br><span class="line">    <span class="comment">// 因此需要使用`Mutex`来满足编译器对线程安全的校验，如果是生产级的执行器实现，不会使用`Mutex`，因为会带来性能上的开销，取而代之的是使用`UnsafeCell`</span></span><br><span class="line">    task_queue: Receiver&lt;Arc&lt;Mutex&lt;BoxFuture&lt;<span class="symbol">&#x27;static</span>, ()&gt;&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// Executor 作为消息通道的接收者，可以从消息通道中取出需要被 poll 的 Future</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(future) = <span class="keyword">self</span>.task_queue.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex_future</span> = future.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> mutex_future.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(context).<span class="title function_ invoke__">is_pending</span>() &#123;</span><br><span class="line">                <span class="comment">// 重新放回任务队列</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，在实现的代码中存在两个问题：</p>
<ol>
<li>缺少 Future 特征 poll 函数的参数 Context，也就是类似 SimpleFuture 特征中用于唤起功能的 wake 函数，wake 函数怎么让 Future 重新放回消息通道</li>
<li>缺少发送者，无法将 Future 重新放回消息通道中</li>
</ol>
<p>以上两点都是在解决怎么将 Future 重新放回消息通道，解决这个问题是自定义执行器的关键。</p>
<p>分析以上信息，可以得到两个重点：</p>
<ol>
<li>如果一个 Future 被 Executor poll 后需要重新放入任务队列，那么 Executor 在 poll Future 时必须要拿到发送者，才可以将 Future 重新放入任务队列</li>
<li>如果调用 wake 函数后需要将 Future 重新放入任务队列，需要拿到发送者与 Future，才可以将 Future 重新放入任务队列</li>
</ol>
<p>执行器在外部将 Future 再次放入任务队列的形式，也可以统一到调用 wake 将 Future 放入任务队列的形式上。</p>
<p>以上两个问题其实比较好解决，但是比较绕。将 Future 与发送者关联起来形成新的结构体 FutureWrapper，将新的结构体发送到任务队列，这样执行器拿到的 Future 都是带有发送者的 FutureWrapper。</p>
<p>在 rust 的 waker 的介绍中，有这么一段描述：<br>每个 Future 在注册其 wake 函数时，可以将自身的信息存储在 Waker 中。当 wake 被调用时，Future 的自身信息会被传递给执行器，从而使执行器能够正确识别并调度特定的 Future。</p>
<p>这一段描述的就是将 Future 与发送者关联，并结合 Waker 的过程。因此，刚开始这句话并不是特别准确：</p>
<blockquote>
<p>wake 注册就是将 wake 传递给外部，用 wake 关联当前 Future 的过程，而让外部调用 wake 函数就是在让执行器再次 poll wake 关联的 Future 的过程。</p>
</blockquote>
<p>修改消息通道发送的数据类型，构建发送者和接收者(执行器)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过同步消息通道模拟 Executor 调度流程</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FutureChannel</span>(Spawner, Executor);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FutureChannel</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(size);</span><br><span class="line">        <span class="title function_ invoke__">Self</span>(Spawner &#123; task_sender: tx &#125;, Executor &#123; task_queue: rx &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FutureWrapper</span> &#123;</span><br><span class="line">    future: Mutex&lt;<span class="type">Option</span>&lt;BoxFuture&lt;<span class="symbol">&#x27;static</span>, ()&gt;&gt;&gt;,</span><br><span class="line">    task_sender: SyncSender&lt;Arc&lt;FutureWrapper&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Spawner</span> &#123;</span><br><span class="line">    task_sender: SyncSender&lt;Arc&lt;FutureWrapper&gt;&gt;, <span class="comment">// 发送 FutureWrapper</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Spawner</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">spawn</span>(&amp;<span class="keyword">self</span>, future: <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = ()&gt; + <span class="symbol">&#x27;static</span> + <span class="built_in">Send</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">future</span> = future.<span class="title function_ invoke__">boxed</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">wrapper</span> = FutureWrapper &#123;</span><br><span class="line">            future: Mutex::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Some</span>(future)),</span><br><span class="line">            task_sender: <span class="keyword">self</span>.task_sender.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 将 Future 发送到任务通道中</span></span><br><span class="line">        <span class="keyword">self</span>.task_sender</span><br><span class="line">            .<span class="title function_ invoke__">send</span>(Arc::<span class="title function_ invoke__">new</span>(wrapper))</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;任务队列已满&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    task_queue: Receiver&lt;Arc&lt;FutureWrapper&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// Executor 作为消息通道的接收者，可以从消息通道中取出需要被 poll 的 Future</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(wrapper) = <span class="keyword">self</span>.task_queue.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex_future</span> = wrapper.future.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> future) = mutex_future.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> future.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(cx).<span class="title function_ invoke__">is_pending</span>() &#123;</span><br><span class="line">                    <span class="comment">// Future 未完成时，将 Future 再次放入任务队列中</span></span><br><span class="line">                    wrapper.task_sender.<span class="title function_ invoke__">send</span>(wrapper.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor 中已经可以拿到发送者，并将携带 Future 的 FutureWrapper 重新发送到任务队列，剩下一个问题，如何统一到调用 wake 将 Future 放入任务队列，它能使用在两方面：</p>
<ul>
<li>在 poll 函数内部调用 wake，将 Future 重新放入任务队列</li>
<li>在 执行器中调用 wake，外部调用也能将 Future 放入任务队列</li>
</ul>
<p>SimpleFuture 的 wake 和 Future 的 Context 都属于唤起作用，即将 Future 重新放入消息通道中，不同的是 Context 携带了数据。<br>其实，Waker 和 wake 函数并不是高深的魔法，Waker 是存储信息对象，wake 函数是一个触发操作，功能是将 Future 重新发送到消息队列中，阻塞等待的 Executor 就会接收并自动执行 Future。</p>
<blockquote>
<p>注意：虽然发送者和接收者是生成消息通道时产生的，但是这并不意味发送者和接收者不能进入消息通道，创建消息通道其实是创建了三个数据结构，发送者、接收者、消息通道。</p>
</blockquote>
<p>现在任务队列的数据类型变为 <code>FutureWrapper</code>，它携带了 Future 和发送者，如果再让他实现一个操作 wake，利用自身的发送者将自身的 Future 发送到消息通道中，那么问题就可以解决了。</p>
<p>定义一个 MyWaker 特征，提供 wake 方法，能将自身重新发送到任务队列中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">MyWaker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wake</span>(<span class="keyword">self</span>: &amp;Arc&lt;<span class="keyword">Self</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyWaker</span> <span class="keyword">for</span> <span class="title class_">FutureWrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wake</span>(<span class="keyword">self</span>: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        <span class="comment">// 利用自己的发送者，将自己重新发送到任务队列中</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cloned</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">self</span>.task_sender.<span class="title function_ invoke__">send</span>(cloned).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;任务队列已满&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// Executor 作为消息通道的接收者，可以从消息通道中取出需要被 poll 的 Future</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(wrapper) = <span class="keyword">self</span>.task_queue.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex_future</span> = wrapper.future.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> future) = mutex_future.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> future.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(cx).<span class="title function_ invoke__">is_pending</span>() &#123;</span><br><span class="line">                    <span class="comment">// Future 未完成时，将 Future 再次放入任务队列中</span></span><br><span class="line">                    <span class="comment">// wrapper.task_sender.send(wrapper.clone());</span></span><br><span class="line">                    <span class="comment">// MyWaker::wake(&amp;wrapper)</span></span><br><span class="line">                    wrapper.<span class="title function_ invoke__">wake</span>();</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以看成是 Waker 与 Executor 的交互可以使 Executor 不停的 poll Future。虽然 poll 包含 waker 的 Context 参数还未完全生成，但整体的触发和实现都体现了。</p>
<p>生成完整的 Context 包含许多细节，这里利用 futures 提供的 ArcWaker 简化搭建简单可用的执行器这个过程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FutureWrapper</span> &#123;</span><br><span class="line">    future: Mutex&lt;<span class="type">Option</span>&lt;BoxFuture&lt;<span class="symbol">&#x27;static</span>, ()&gt;&gt;&gt;,</span><br><span class="line">    task_sender: SyncSender&lt;Arc&lt;FutureWrapper&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ArcWake</span> <span class="keyword">for</span> <span class="title class_">FutureWrapper</span> &#123;</span><br><span class="line">    <span class="comment">// arc_self 参数形式，FutureWrapper 的实例是无法直接调用的，需要参数为 self 才允许</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wake_by_ref</span>(arc_self: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cloned</span> = arc_self.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        arc_self.task_sender.<span class="title function_ invoke__">send</span>(cloned).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;任务队列已满&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Spawner</span> &#123;</span><br><span class="line">    task_sender: SyncSender&lt;Arc&lt;FutureWrapper&gt;&gt;, <span class="comment">// 发送 FutureWrapper</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Spawner</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">spawn</span>(&amp;<span class="keyword">self</span>, future: <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = ()&gt; + <span class="symbol">&#x27;static</span> + <span class="built_in">Send</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">future</span> = future.<span class="title function_ invoke__">boxed</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">wrapper</span> = FutureWrapper &#123;</span><br><span class="line">            future: Mutex::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Some</span>(future)),</span><br><span class="line">            task_sender: <span class="keyword">self</span>.task_sender.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 将 Future 发送到任务通道中</span></span><br><span class="line">        <span class="keyword">self</span>.task_sender</span><br><span class="line">            .<span class="title function_ invoke__">send</span>(Arc::<span class="title function_ invoke__">new</span>(wrapper))</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;任务队列已满&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    task_queue: Receiver&lt;Arc&lt;FutureWrapper&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// Executor 作为消息通道的接收者，可以从消息通道中取出需要被 poll 的 Future</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(wrapper) = <span class="keyword">self</span>.task_queue.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex_future</span> = wrapper.future.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 需要take()，获取到future才能poll，future没有完成，就要放回去。当future完成了，触发waker，wake的时候会将task再次发送到channel，这时候executor再次收到task，再去poll future，future不是pending了，就不再放回task。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> future) = mutex_future.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                <span class="comment">// 生成关联的 waker</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">waker</span> = futures::task::<span class="title function_ invoke__">waker_ref</span>(&amp;wrapper);</span><br><span class="line">                <span class="comment">// 生成对应的 Context</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">context</span> = &amp;<span class="keyword">mut</span> Context::<span class="title function_ invoke__">from_waker</span>(&amp;*waker);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// `BoxFuture&lt;T&gt;`是`Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send + &#x27;static&gt;&gt;`的类型别名</span></span><br><span class="line">                <span class="comment">// 通过调用`as_mut`方法，可以将上面的类型转换成`Pin&lt;&amp;mut dyn Future + Send + &#x27;static&gt;`</span></span><br><span class="line">                <span class="keyword">if</span> future.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(context).<span class="title function_ invoke__">is_pending</span>() &#123;</span><br><span class="line">                    <span class="comment">// Future 未完成时，将 Future 再次放入任务队列中</span></span><br><span class="line">                    *mutex_future = <span class="title function_ invoke__">Some</span>(future);</span><br><span class="line">                    <span class="comment">// 不断轮询的实现</span></span><br><span class="line">                    wrapper</span><br><span class="line">                        .task_sender</span><br><span class="line">                        .<span class="title function_ invoke__">send</span>(wrapper.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">                        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;任务队列已满&quot;</span>);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意，使用 take 将元素取出后，原有位置就不会有该元素了。因此在 Future 未完成前，还需要把他放回原位置。<br>如果希望执行器不断轮询 Future，可以将 Future 再次发送到任务队列中。</p>
<p>测试自定义执行器</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试自定义的执行器，将 FutureChannel 改名为 TaskChannel 更合适，结构时不能用类型别名作为构造器</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TaskChannel</span> = FutureChannel;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">FutureChannel</span>(spawner, executor) = TaskChannel::<span class="title function_ invoke__">new</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">spawner.<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;howdy!&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建定时器Future，并等待它完成</span></span><br><span class="line">    TimeFuture::<span class="title function_ invoke__">new</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// drop 掉发送者，这样接收者在接收信息时，如果收到通道关闭的信息，就会主动关闭，避免一直阻塞主线程</span></span><br><span class="line"><span class="title function_ invoke__">drop</span>(spawner);</span><br><span class="line"><span class="comment">// 运行执行器直到任务队列为空</span></span><br><span class="line"><span class="comment">// 任务运行后，会先打印`howdy!`, 暂停2秒，接着打印 `done!`</span></span><br><span class="line">executor.<span class="title function_ invoke__">run</span>();</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Poll</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ready</span>(T),</span><br><span class="line">        Pending,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">trait</span> <span class="title class_">SimpleFuture</span> &#123;</span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, wake: <span class="title function_ invoke__">fn</span>()) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Socket 伪代码流程</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * pub struct SocketRead&lt;&#x27;a&gt; &#123;</span></span><br><span class="line"><span class="comment">     *     socket: &amp;&#x27;a Socket,</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * impl SimpleFuture for SocketRead&lt;&#x27;_&gt; &#123;</span></span><br><span class="line"><span class="comment">     *     type Output = Vec&lt;u8&gt;;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; &#123;</span></span><br><span class="line"><span class="comment">     *         if self.socket.has_data_to_read() &#123;</span></span><br><span class="line"><span class="comment">     *             // socket有数据，写入buffer中并返回</span></span><br><span class="line"><span class="comment">     *             Poll::Ready(self.socket.read_buf())</span></span><br><span class="line"><span class="comment">     *         &#125; else &#123;</span></span><br><span class="line"><span class="comment">     *             // socket中还没数据</span></span><br><span class="line"><span class="comment">     *             // 注册一个`wake`函数，当数据可用时，该函数会被调用，</span></span><br><span class="line"><span class="comment">     *             // 然后当前Future的执行器会再次调用`poll`方法，此时就可以读取到数据</span></span><br><span class="line"><span class="comment">     *             self.socket.set_readable_callback(wake);</span></span><br><span class="line"><span class="comment">     *             Poll::Pending</span></span><br><span class="line"><span class="comment">     *         &#125;</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个 Future 可以管理多个子 Future，使其并发执行。之所以可以并发，是因为两个子 Future 的轮询可以交替进行，一个阻塞另一个就可以立刻执行，反之亦然</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Join</span>&lt;FutureA, FutureB&gt; &#123;</span><br><span class="line">        <span class="comment">// 结构体的每个字段都包含一个 Future，可以运行直到完成，等到当前 Future 完成后，字段会被设置为 `None`. 这样 Future 完成后就不会再被轮询</span></span><br><span class="line">        a: <span class="type">Option</span>&lt;FutureA&gt;,</span><br><span class="line">        b: <span class="type">Option</span>&lt;FutureB&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;FutureA, FutureB&gt; SimpleFuture <span class="keyword">for</span> <span class="title class_">Join</span>&lt;FutureA, FutureB&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        FutureA: SimpleFuture&lt;Output = ()&gt;,</span><br><span class="line">        FutureB: SimpleFuture&lt;Output = ()&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, wake: <span class="title function_ invoke__">fn</span>()) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">            <span class="comment">// 尝试去完成一个 Future `a`，等到当前 Future 完成后，字段会被设置为 `None`. 这样 Future 完成后就不会再被轮询</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(a) = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.a &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Poll</span>::<span class="title function_ invoke__">Ready</span>(()) = a.<span class="title function_ invoke__">poll</span>(wake) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.a.<span class="title function_ invoke__">take</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试去完成一个 Future `b`，等到当前 Future 完成后，字段会被设置为 `None`. 这样 Future 完成后就不会再被轮询</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(b) = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.b &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Poll</span>::<span class="title function_ invoke__">Ready</span>(()) = b.<span class="title function_ invoke__">poll</span>(wake) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.b.<span class="title function_ invoke__">take</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.a.<span class="title function_ invoke__">is_none</span>() &amp;&amp; <span class="keyword">self</span>.b.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">                <span class="comment">// 两个 Future都已完成 - 可以成功地统一返回</span></span><br><span class="line">                Poll::<span class="title function_ invoke__">Ready</span>(())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 至少还有一个 Future 没有完成任务，因此返回 `Poll::Pending`。当该 Future 再次准备好时，通过调用`wake()`函数来继续执行</span></span><br><span class="line">                Poll::Pending</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用线程休眠模拟异步任务，如网络请求</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">FutureStatus</span> &#123;</span><br><span class="line">        init,</span><br><span class="line">        pending,</span><br><span class="line">        completed,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SharedState</span> &#123;</span><br><span class="line">        <span class="comment">// 异步任务的状态</span></span><br><span class="line">        status: FutureStatus,</span><br><span class="line">        <span class="comment">// 当前 Future 被 poll 执行时将 wake 存储起来，然后外部在异步任务结束后，调用 wake 函数让执行器正确识别 Future 并再次 poll 当前 Future</span></span><br><span class="line">        waker: <span class="type">Option</span>&lt;std::task::Waker&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TimeFuture 需要一个状态标识是否完成，这个状态是由休眠线程传递的，涉及到多线程需要使用 Arc，并且状态应该是带锁的，避免多线程数据访问问题</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TimeFuture</span> &#123;</span><br><span class="line">        shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现 Future poll 的逻辑</span></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">TimeFuture</span> &#123;</span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">poll</span>(</span><br><span class="line">            <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;,</span><br><span class="line">            cx: &amp;<span class="keyword">mut</span> std::task::Context&lt;<span class="symbol">&#x27;_</span>&gt;,</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> std::task::Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">            <span class="comment">// poll 时检查任务状态，来确定是否可以结束当前 Future</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shared_state</span> = <span class="keyword">self</span>.shared_state.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">match</span> shared_state.status &#123;</span><br><span class="line">                FutureStatus::init =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 选择每次都`clone`的原因是： `TimerFuture`可以在执行器的不同任务间移动，如果只克隆一次，</span></span><br><span class="line">                    <span class="comment">// 那么获取到的`waker`可能已经被篡改并指向了其它任务，最终导致执行器运行了错误的任务</span></span><br><span class="line">                    shared_state.waker = <span class="title function_ invoke__">Some</span>(cx.<span class="title function_ invoke__">waker</span>().<span class="title function_ invoke__">clone</span>());</span><br><span class="line">                    shared_state.status = FutureStatus::pending;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">_shared_state</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>.shared_state);</span><br><span class="line">                    <span class="comment">// 用线程休眠模拟异步任务</span></span><br><span class="line">                    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">                        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">                        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex</span> = _shared_state.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                        <span class="comment">// 修改异步任务状态，模拟网络结束连接或IO关闭等场景。</span></span><br><span class="line">                        <span class="comment">// Future 一定要有一个表示执行异步任务状态的数据，这样才能让执行器在 Poll 当前 Future 时知道该结束 `Poll::Ready` 还是等待 `Poll::Pending`</span></span><br><span class="line">                        mutex.status = FutureStatus::completed;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在异步任务结束后，调用 poll Future 的 waker</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(waker) = mutex.waker.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                            <span class="built_in">println!</span>(<span class="string">&quot;wake call&quot;</span>);</span><br><span class="line">                            waker.<span class="title function_ invoke__">wake</span>()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    std::task::Poll::Pending</span><br><span class="line">                &#125;</span><br><span class="line">                FutureStatus::pending =&gt; std::task::Poll::Pending,</span><br><span class="line">                FutureStatus::completed =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;completed&quot;</span>);</span><br><span class="line">                    std::task::Poll::<span class="title function_ invoke__">Ready</span>(())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Future 生成</span></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">TimeFuture</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">shared_state</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(SharedState &#123;</span><br><span class="line">                status: FutureStatus::init,</span><br><span class="line">                waker: <span class="literal">None</span>,</span><br><span class="line">            &#125;));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Self</span> &#123; shared_state &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// futures::executor::block_on(TimeFuture::new());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过同步消息通道模拟 Executor 调度流程</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FutureChannel</span>(Spawner, Executor);</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">FutureChannel</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(size);</span><br><span class="line">            <span class="title function_ invoke__">Self</span>(Spawner &#123; task_sender: tx &#125;, Executor &#123; task_queue: rx &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FutureWrapper</span> &#123;</span><br><span class="line">        future: Mutex&lt;<span class="type">Option</span>&lt;BoxFuture&lt;<span class="symbol">&#x27;static</span>, ()&gt;&gt;&gt;,</span><br><span class="line">        task_sender: SyncSender&lt;Arc&lt;FutureWrapper&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现简单的 waker</span></span><br><span class="line">    <span class="comment">// trait MyWaker &#123;</span></span><br><span class="line">    <span class="comment">//     fn wake(self: &amp;Arc&lt;Self&gt;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// impl MyWaker for FutureWrapper &#123;</span></span><br><span class="line">    <span class="comment">//     fn wake(self: &amp;Arc&lt;Self&gt;) &#123;</span></span><br><span class="line">    <span class="comment">//         // 利用自己的发送者，将自己重新发送到任务队列中</span></span><br><span class="line">    <span class="comment">//         let cloned = self.clone();</span></span><br><span class="line">    <span class="comment">//         self.task_sender.send(cloned).expect(&quot;任务队列已满&quot;)</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">ArcWake</span> <span class="keyword">for</span> <span class="title class_">FutureWrapper</span> &#123;</span><br><span class="line">        <span class="comment">// arc_self 参数形式，FutureWrapper 的实例是无法直接调用的，需要参数为 self 才允许</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">wake_by_ref</span>(arc_self: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">cloned</span> = arc_self.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">            arc_self.task_sender.<span class="title function_ invoke__">send</span>(cloned).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;任务队列已满&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[derive(Clone)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Spawner</span> &#123;</span><br><span class="line">        task_sender: SyncSender&lt;Arc&lt;FutureWrapper&gt;&gt;, <span class="comment">// 发送 FutureWrapper</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Spawner</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">spawn</span>(&amp;<span class="keyword">self</span>, future: <span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = ()&gt; + <span class="symbol">&#x27;static</span> + <span class="built_in">Send</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">future</span> = future.<span class="title function_ invoke__">boxed</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">wrapper</span> = FutureWrapper &#123;</span><br><span class="line">                future: Mutex::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Some</span>(future)),</span><br><span class="line">                task_sender: <span class="keyword">self</span>.task_sender.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 将 Future 发送到任务通道中</span></span><br><span class="line">            <span class="keyword">self</span>.task_sender</span><br><span class="line">                .<span class="title function_ invoke__">send</span>(Arc::<span class="title function_ invoke__">new</span>(wrapper))</span><br><span class="line">                .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;任务队列已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">        task_queue: Receiver&lt;Arc&lt;FutureWrapper&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">// Executor 作为消息通道的接收者，可以从消息通道中取出需要被 poll 的 Future</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(wrapper) = <span class="keyword">self</span>.task_queue.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutex_future</span> = wrapper.future.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 需要take()，获取到future才能poll，future没有完成，就要放回去。当future完成了，触发waker，wake的时候会将task再次发送到channel，这时候executor再次收到task，再去poll future，future不是pending了，就不再放回task。</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> future) = mutex_future.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                    <span class="comment">// 生成关联的 waker</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">waker</span> = futures::task::<span class="title function_ invoke__">waker_ref</span>(&amp;wrapper);</span><br><span class="line">                    <span class="comment">// 生成对应的 Context</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">context</span> = &amp;<span class="keyword">mut</span> Context::<span class="title function_ invoke__">from_waker</span>(&amp;*waker);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// `BoxFuture&lt;T&gt;`是`Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send + &#x27;static&gt;&gt;`的类型别名</span></span><br><span class="line">                    <span class="comment">// 通过调用`as_mut`方法，可以将上面的类型转换成`Pin&lt;&amp;mut dyn Future + Send + &#x27;static&gt;`</span></span><br><span class="line">                    <span class="keyword">if</span> future.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">poll</span>(context).<span class="title function_ invoke__">is_pending</span>() &#123;</span><br><span class="line">                        <span class="comment">// Future 未完成时，将 Future 再次放入任务队列中</span></span><br><span class="line">                        *mutex_future = <span class="title function_ invoke__">Some</span>(future);</span><br><span class="line">                        wrapper</span><br><span class="line">                            .task_sender</span><br><span class="line">                            .<span class="title function_ invoke__">send</span>(wrapper.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">                            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;任务队列已满&quot;</span>);</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试自定义的执行器，将 FutureChannel 改名为 TaskChannel 更合适，结构时不能用类型别名作为构造器</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">TaskChannel</span> = FutureChannel;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">FutureChannel</span>(spawner, executor) = TaskChannel::<span class="title function_ invoke__">new</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    spawner.<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;howdy!&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建定时器Future，并等待它完成</span></span><br><span class="line">        TimeFuture::<span class="title function_ invoke__">new</span>().<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// drop 掉发送者，这样接收者在接收信息时，如果收到通道关闭的信息，就会主动关闭，避免一直阻塞主线程</span></span><br><span class="line">    <span class="comment">// drop(spawner);</span></span><br><span class="line">    <span class="comment">// 运行执行器直到任务队列为空</span></span><br><span class="line">    <span class="comment">// 任务运行后，会先打印`howdy!`, 暂停2秒，接着打印 `done!`</span></span><br><span class="line">    executor.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Az</span>
                    </p>
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Rust/"># Rust</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/07/22/ts-Record-definition/">ts: Record definition</a>
            
            
            <a class="next" rel="next" href="/2024/07/10/rust-async-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/">rust: async 异步编程：概念介绍</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
  <div class="copyright">
    <span>© Az | Powered by Hexo & Chic</span>
  </div>
</footer>

    </div>
</body>

</html>