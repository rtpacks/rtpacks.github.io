<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>net: socket、websocket、http</title>
      <link href="/2024/07/07/net-socket%E3%80%81websocket%E3%80%81http/"/>
      <url>/2024/07/07/net-socket%E3%80%81websocket%E3%80%81http/</url>
      
        <content type="html"><![CDATA[<h2 id="socket、websocket、http"><a href="#socket、websocket、http" class="headerlink" title="socket、websocket、http"></a>socket、websocket、http</h2><p>互联网分 5 层：物理层，链路层，网络层，传输层，应用层。常用的TCP, UDP 属于传输层，HTTP, WEBSOCKET 属于应用层。</p><p>如果不想用 HTTP WS 这些协议通信，可以基于 TCP, UDP 创建 socket，服务器和客户端使用自定义协议进行通信，比如消息体里什么字段代表什么意思。HTTP, WS 可以视为已经封装好的 SOCKET 应用协议。</p><p>WS 与 HTTP 的关系：WS 在创建连接时使用了 HTTP，连接后的通信就与 HTTP 无关了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: Macro 宏编程</title>
      <link href="/2024/07/04/rust-Macro-%E5%AE%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/07/04/rust-Macro-%E5%AE%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Macro-宏编程"><a href="#Macro-宏编程" class="headerlink" title="Macro 宏编程"></a>Macro 宏编程</h2><p>宏在 Rust 中无处不在。在 Rust 中宏分为两大类：声明式宏( declarative macros ) macro_rules! 和三种过程宏( procedural macros )。</p><h3 id="宏和函数的区别"><a href="#宏和函数的区别" class="headerlink" title="宏和函数的区别"></a>宏和函数的区别</h3><p><a href="https://course.rs/advance/macro.html#%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">https://course.rs/advance/macro.html#宏和函数的区别</a></p><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><p>暂时不学习，等有需求时再阅读：<a href="https://course.rs/advance/macro.html#macro-%E5%AE%8F%E7%BC%96%E7%A8%8B">https://course.rs/advance/macro.html#macro-宏编程</a></p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: unsafe：内联汇编</title>
      <link href="/2024/07/03/rust-unsafe%EF%BC%9A%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
      <url>/2024/07/03/rust-unsafe%EF%BC%9A%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h2 id="unsafe：内联汇编"><a href="#unsafe：内联汇编" class="headerlink" title="unsafe：内联汇编"></a>unsafe：内联汇编</h2><p>暂时不学，阅读：<a href="https://course.rs/advance/unsafe/inline-asm.html#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96">https://course.rs/advance/unsafe/inline-asm.html#内联汇编</a></p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: unsafe：unsafe superpowers</title>
      <link href="/2024/07/02/rust-unsafe%EF%BC%9Aunsafe-superpowers/"/>
      <url>/2024/07/02/rust-unsafe%EF%BC%9Aunsafe-superpowers/</url>
      
        <content type="html"><![CDATA[<h2 id="unsafe：unsafe-superpowers"><a href="#unsafe：unsafe-superpowers" class="headerlink" title="unsafe：unsafe superpowers"></a>unsafe：unsafe superpowers</h2><p>五种超能力（unsafe superpowers）：</p><ul><li>解引用裸指针</li><li>调用不安全的函数或方法</li><li>访问或修改可变静态变量</li><li>实现不安全 trait</li><li>访问 union 的字段</li></ul><h3 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h3><p>裸指针(raw pointer，又称原生指针) 在功能上跟引用类似，它需要显式地注明可变性。<br>但是裸指针又和引用有所不同，裸指针有两种形式: <code>*const T</code> 和 <code>*mut T</code>，代表不可变和可变。<br><code>*</code> 操作符常见的含义是用于解引用，但是在裸指针 <code>*const T</code> 和 <code>*mut</code> 中，<code>*</code> 只是类型名称的一部分，并没有解引用的含义。</p><p>截至目前，已经有三种类似指针的概念：<strong>引用、智能指针和裸指针</strong>。裸指针与引用、智能指针不同：</p><ul><li>可以绕过 Rust 的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针</li><li>不能保证指向的内存是合法的</li><li>可以是 null</li><li>没有实现任何自动的回收 (drop)</li></ul><p>使用裸指针可以创建两个可变指针都指向同一个数据，如果使用安全的 Rust 是无法做到这一点的，因为违背了借用规则。<br>因此虽然裸指针可以绕过借用规则，但是由此带来的数据竞争问题，需要程序员着重处理。</p><p>总之，裸指针跟 C 指针是非常像的，使用它需要以牺牲安全性为前提，但获得了更好的性能，也可以跟其它语言或硬件打交道。</p><h4 id="基于引用创建裸指针"><a href="#基于引用创建裸指针" class="headerlink" title="基于引用创建裸指针"></a>基于引用创建裸指针</h4><p>需要注意：<strong>基于引用创建裸指针是安全的行为，而解引用裸指针才是不安全的行为</strong>。即基于引用创建裸指针时不需要 unsafe，解引用时才需要。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于引用创建裸指针是安全的行为，解引用裸指针才是不安全的</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_ptr</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>; <span class="comment">// 创建裸指针是安全的</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_mutptr1</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>; <span class="comment">// 创建可变的裸指针，与不可变裸指针存储是一样的地址，但语义上是区分的</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_mutptr2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>; <span class="comment">// 裸指针是可以创建多个可变的</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// *num_ptr = 4;</span></span><br><span class="line">    *num_mutptr1 = <span class="number">4</span>;</span><br><span class="line">    *num_mutptr2 = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;num = &#123;&#125;, num_ptr = &#123;:p&#125;, num_mutptr1 = &#123;:p&#125;, num_mutptr2 = &#123;:p&#125;&quot;</span>,</span><br><span class="line">    num, num_ptr, num_mutptr1, num_mutptr2</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="基于智能指针创建裸指针"><a href="#基于智能指针创建裸指针" class="headerlink" title="基于智能指针创建裸指针"></a>基于智能指针创建裸指针</h4><p>与基于引用创建裸指针很类似，基于智能指针创建裸指针是安全的，解引用才是不安全的行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于智能指针创建裸指针</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_box</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_box_ptr</span> = &amp;*num_box <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_box_mutptr</span> = &amp;<span class="keyword">mut</span> *num_box <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// *num_box_ptr = 4;</span></span><br><span class="line">    *num_box_mutptr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;num_box = &#123;&#125;, num_box_ptr = &#123;:p&#125;, num_box_mutptr = &#123;:p&#125;&quot;</span>,</span><br><span class="line">    num_box, num_box_ptr, num_box_mutptr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="基于内存地址创建裸指针"><a href="#基于内存地址创建裸指针" class="headerlink" title="基于内存地址创建裸指针"></a>基于内存地址创建裸指针</h4><p>基于一个内存地址来创建裸指针，可以想像这种行为是相当危险的。试图使用任意的内存地址往往是一种未定义的行为(undefined behavior)，因为该内存地址有可能存在值，也有可能没有。<br>同时编译器也有可能会优化这段代码，会造成没有任何内存访问发生，甚至程序还可能发生段错误(segmentation fault)。</p><p>正常项目几乎不会基于内存地址创建裸指针的做法。</p><h3 id="调用-unsafe-函数或方法"><a href="#调用-unsafe-函数或方法" class="headerlink" title="调用 unsafe 函数或方法"></a>调用 unsafe 函数或方法</h3><p>unsafe 函数从外表上来看跟普通函数并无区别，唯一的区别就是它需要使用 unsafe fn 来进行定义。<br>这种定义方式是为了告诉调用者：当调用此函数时需要注意它的相关需求，因为 Rust 无法担保调用者在使用该函数时能满足它所需的一切需求。</p><p>在编写 unsafe 函数时，有一点需要注意：<br>unsafe 函数体中无需使用 unsafe 语句块，unsafe 函数自身就是一个 unsafe 语句块，但一个函数包含了 unsafe 代码不代表需要将整个函数都定义为 unsafe fn。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">gen_unsafe</span>() &#123;</span><br><span class="line">    <span class="comment">// 基于智能指针创建裸指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_box</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_box_ptr</span> = &amp;*num_box <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_box_mutptr</span> = &amp;<span class="keyword">mut</span> *num_box <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="comment">// *num_box_ptr = 4;</span></span><br><span class="line">    *num_box_mutptr = <span class="number">4</span>; <span class="comment">// unsafe函数中无需unsafe语句块</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;gen_unsafe: num_box = &#123;&#125;, num_box_ptr = &#123;:p&#125;, num_box_mutptr = &#123;:p&#125;&quot;</span>,</span><br><span class="line">        num_box, num_box_ptr, num_box_mutptr</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">gen_unsafe</span>() &#125;</span><br></pre></td></tr></table></figure><h3 id="安全抽象包裹-unsafe-代码"><a href="#安全抽象包裹-unsafe-代码" class="headerlink" title="安全抽象包裹 unsafe 代码"></a>安全抽象包裹 unsafe 代码</h3><p>一个函数包含了 unsafe 代码不代表需要将整个函数都定义为 unsafe fn。事实上，在标准库中有大量的安全函数，它们内部都包含了 unsafe 代码块，例如 split_at_mut。</p><p>需求：将一个数组分成两个切片，且每一个切片都要求是可变的。类似这种需求在安全 Rust 中是很难实现的，因为要对同一个数组做两个可变借用，这不符合借用规则。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], mid: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    (&amp;<span class="keyword">mut</span> slice[..mid], &amp;<span class="keyword">mut</span> slice[mid..]) <span class="comment">// 出现多个可变借用，不符合 rust 的借用规则，编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 unsafe 绕过借用规则</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全抽象包裹 unsafe 代码，即将一个unsafe语句块放在安全的rust中</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(_slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], point: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = _slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(point &lt; len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = _slice.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="comment">// (&amp;mut _slice[..point], &amp;mut _slice[point..]) 出现多个可变借用，不符合 rust 的借用规则，编译失败</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 从可变裸指针获取可变引用</span></span><br><span class="line">        (</span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr, point),</span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="title function_ invoke__">add</span>(point), len - point),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">split_at_mut</span>(&amp;<span class="keyword">mut</span> arr, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>有几点需要注意：<br>as_mut_ptr 会返回指向 slice 首地址的裸指针 <code>*mut i32</code><br>slice::from_raw_parts_mut 方法通过指针和长度来创建一个新的切片，是一个 unsafe 方法。简单来说，该切片的初始地址是 ptr，长度为 point<br>ptr.add(point) 可以获取第二个切片的初始地址，是一个 unsafe 方法。由于切片中的元素是 i32 类型，每个元素都占用了 4 个字节的内存大小，因此不能简单的用 <code>ptr + mid</code> 来作为初始地址，而应该使用 <code>ptr + 4 * mid</code>，但是这种使用方式并不安全，因此 .add 方法是最佳选择</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全抽象包裹 unsafe 代码，即将一个unsafe语句块放在安全的rust中</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(_slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], point: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = _slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(point &lt; len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = _slice.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="comment">// (&amp;mut _slice[..point], &amp;mut _slice[point..]) 出现多个可变借用，不符合 rust 的借用规则，编译失败</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 从可变裸指针获取可变引用</span></span><br><span class="line">        (</span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr, point), <span class="comment">// from_raw_parts_mut 通过指针和长度来创建一个新的切片，是一个unsafe方法</span></span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="title function_ invoke__">add</span>(point), len - point), <span class="comment">// ptr.add(point) 可以获取第二个切片的初始地址，是一个unsafe方法</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">split_at_mut</span>(&amp;<span class="keyword">mut</span> arr, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="FFI-外部函数接口"><a href="#FFI-外部函数接口" class="headerlink" title="FFI 外部函数接口"></a>FFI 外部函数接口</h3><p>FFI（Foreign Function Interface）外部函数接口是用来与其它语言进行交互的接口设计，但并不是所有语言都称为 FFI。例如在 Java 中称之为 JNI（Java Native Interface）。</p><p>FFI 之所以存在是现实中很多代码库都是由不同语言编写的，如果需要使用某个库，但它是由其它语言编写的，往往只有几个选择：</p><ul><li>对该库进行重写或者移植</li><li>独立的服务调用（HTTP，gRPC）</li><li>使用 FFI</li></ul><p>在大部分情况下，重写或移植程序需要花费大量的时间和精力，独立的服务调用可能不满足时延，此时 FFI 就是最佳选择。<br>并且，在将其他语言的代码重构为 Rust 时，先将相关代码引入到 Rust 项目中，然后逐步重构，是一个非常不错的渐进式过程。</p><p>涉及到不同语言的交互，无法确定这个行为是否安全，因此 rust 的 FFI 需要 unsafe 的支持才能绕过编译器的审查，达到正常编译的目的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 语言的代码定义在了 extern 代码块中， 而 extern 必须使用 unsafe 才能进行进行调用，原因在于其它语言的代码并不会强制执行 Rust 的规则，因此 Rust 无法对这些代码进行检查，最终还是要靠开发者自己来保证代码的正确性和程序的安全性。</p><blockquote><p>阅读：</p><ul><li><a href="https://rustwiki.org/zh-CN/book/ch19-01-unsafe-rust.html#%E4%BD%BF%E7%94%A8-extern-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E4%BB%A3%E7%A0%81">https://rustwiki.org/zh-CN/book/ch19-01-unsafe-rust.html#使用-extern-函数调用外部代码</a></li></ul></blockquote><h4 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h4><p><strong>应用二进制接口 ABI (Application Binary Interface) 定义了如何在汇编层面来调用该函数</strong>。</p><p>在 extern “C” 代码块列出想要调用的外部函数的签名。其中 “C” 定义了外部函数所使用的 ABI。在所有 ABI 中，C 语言的是最常见的。</p><h4 id="其它语言调用-Rust-函数"><a href="#其它语言调用-Rust-函数" class="headerlink" title="其它语言调用 Rust 函数"></a>其它语言调用 Rust 函数</h4><p>FFI 支持 rust 调用其他语言，也支持其他语言调用 rust。方法是使用 extern 来创建一个接口，其它语言可以通过该接口来调用相关的 Rust 函数。</p><p>供其他语言调用的 FFI 语法与调用其他语言的 FFI 有所不同，调用其他语言使用 extern 语句块，供其他语言调用是在函数定义时加上 extern 关键字。<br>除了加上 extern 关键字外，还需要加上 <code>#[no_mangle]</code> 注解，它的作用是告诉 Rust 编译器不要乱改函数的名称。</p><blockquote><p>Mangling：rust 编译时可能需要修改函数的名称，目的是为了让名称包含更多的信息，这样其它的编译部分就能从该名称获取相应的信息，这种修改会导致函数名变得相当不可读，并且使原函数名称失效。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_from_c</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Just called a Rust function from C!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问或修改可变静态变量"><a href="#访问或修改可变静态变量" class="headerlink" title="访问或修改可变静态变量"></a>访问或修改可变静态变量</h3><p>在之前的全局变量章节中有介绍。</p><h3 id="unsafe-特征"><a href="#unsafe-特征" class="headerlink" title="unsafe 特征"></a>unsafe 特征</h3><p>之所以会有 unsafe 的特征，是因为该特征至少有一个方法包含有编译器无法验证的内容。unsafe 的特征并不常见，已接触的只有 Send。<br>unsafe 特征需要使用 unsafe impl 实现方法，unsafe impl 通知编译器，程序相应的正确性由程序员保证。</p><p>阅读：<a href="https://course.rs/advance/unsafe/superpowers.html#%E5%AE%9E%E7%8E%B0-unsafe-%E7%89%B9%E5%BE%81">https://course.rs/advance/unsafe/superpowers.html#实现-unsafe-特征</a></p><h3 id="访问-union-中的字段"><a href="#访问-union-中的字段" class="headerlink" title="访问 union 中的字段"></a>访问 union 中的字段</h3><p>union 主要用于跟 C 代码进行交互，访问 union 的字段是不安全的，因为 Rust 无法保证当前存储在 union 实例中的数据类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">MyUnion</span> &#123;</span><br><span class="line">    f1: <span class="type">u32</span>,</span><br><span class="line">    f2: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>union 的使用方式与结构体很相似，但是 union 的所有字段都共享同一个存储空间，意味着往 union 的某个字段写入值，会导致其它字段的值会被覆盖。</p><h3 id="实用工具库"><a href="#实用工具库" class="headerlink" title="实用工具库"></a>实用工具库</h3><p>unsafe 和 FFI 在 Rust 的使用场景中是相当常见，因此社区已经开发出一些实用的工具，可以改善相应的开发体验。这一部分可以在开发中尝试不同的工具。</p><h4 id="rust-bindgen-和-cbindgen"><a href="#rust-bindgen-和-cbindgen" class="headerlink" title="rust-bindgen 和 cbindgen"></a>rust-bindgen 和 cbindgen</h4><p>对于 FFI 调用来说，保证接口的正确性是非常重要的，这两个库可以帮我们自动生成相应的接口。<br>其中 rust-bindgen 用于生成在 Rust 中访问 C 的代码，而 cbindgen 则相反，用于生成在 C 中访问 Rust 的代码。</p><h4 id="cxx"><a href="#cxx" class="headerlink" title="cxx"></a>cxx</h4><p>如果需要跟 C++ 代码交互，则推荐使用 cxx，它提供了双向的调用，最大的优点就是安全，无需使用 unsafe 语句块。</p><h4 id="Miri"><a href="#Miri" class="headerlink" title="Miri"></a>Miri</h4><p>miri 可以生成 Rust 的中间层表示 MIR，它可以帮助检查常见的未定义行为(UB &#x3D; Undefined Behavior)，例如</p><ul><li>内存越界检查和内存释放后再使用(use-after-free)</li><li>使用未初始化的数据</li><li>数据竞争</li><li>内存对齐问题</li></ul><p>可以通过 rustup component add miri 来安装它，并通过 cargo miri 来使用，同时还可以使用 cargo miri test 来运行测试代码。<br>但需要注意的是，它只能帮助识别被执行代码路径的风险，那些未被执行到的代码是没办法被识别的。</p><h4 id="Prusti"><a href="#Prusti" class="headerlink" title="Prusti"></a>Prusti</h4><p>prusti 需要自己来构建一个证明，然后通过它证明代码中的不变量是正确被使用的，当在安全代码中使用不安全的不变量时，就会非常有用。<br>阅读：<a href="https://viperproject.github.io/prusti-dev/user-guide/">https://viperproject.github.io/prusti-dev/user-guide/</a></p><h4 id="Clippy"><a href="#Clippy" class="headerlink" title="Clippy"></a>Clippy</h4><p>官方的 clippy 检查器提供了有限的 unsafe 支持，虽然不多但是至少有一定帮助。例如 missing_safety_docs 检查可以帮助检查哪些 unsafe 函数遗漏了文档。<br>需要注意的是：Rust 编译器并不会默认开启所有检查，可以调用 rustc -W help 来看看最新的信息。</p><h4 id="模糊测试-fuzz-testing"><a href="#模糊测试-fuzz-testing" class="headerlink" title="模糊测试(fuzz testing)"></a>模糊测试(fuzz testing)</h4><p>在 Rust Fuzz Book 中列出了一些 Rust 可以使用的模糊测试方法。同时还可以使用 rutenspitz 这个过程宏来测试有状态的代码，例如数据结构。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>unsafe 只应该用于仅限的五种场景，其它场景应该坚决的使用安全的代码。<br>总之，能不使用 unsafe 一定不要使用，就算使用也要控制好边界，让范围尽可能的小，只有真的需要 unsafe 的代码才应该包含其中, 而不是将无关代码也纳入进来。</p><h3 id="进一步学习"><a href="#进一步学习" class="headerlink" title="进一步学习"></a>进一步学习</h3><ul><li><a href="https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/">https://blog.logrocket.com/unsafe-rust-how-and-when-not-to-use-it/</a></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 基于引用创建裸指针是安全的行为，解引用裸指针才是不安全的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_ptr</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>; <span class="comment">// 创建裸指针是安全的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_mutptr1</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>; <span class="comment">// 创建可变的裸指针，与不可变裸指针存储是一样的地址，但语义上是区分的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_mutptr2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>; <span class="comment">// 裸指针是可以创建多个可变的</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// *num_ptr = 4;</span></span><br><span class="line">        *num_mutptr1 = <span class="number">4</span>;</span><br><span class="line">        *num_mutptr2 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;num = &#123;&#125;, num_ptr = &#123;:p&#125;, num_mutptr1 = &#123;:p&#125;, num_mutptr2 = &#123;:p&#125;&quot;</span>,</span><br><span class="line">        num, num_ptr, num_mutptr1, num_mutptr2</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于智能指针创建裸指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_box</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_box_ptr</span> = &amp;*num_box <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_box_mutptr</span> = &amp;<span class="keyword">mut</span> *num_box <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// *num_box_ptr = 4;</span></span><br><span class="line">        *num_box_mutptr = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;num_box = &#123;&#125;, num_box_ptr = &#123;:p&#125;, num_box_mutptr = &#123;:p&#125;&quot;</span>,</span><br><span class="line">        num_box, num_box_ptr, num_box_mutptr</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">gen_unsafe</span>() &#123;</span><br><span class="line">        <span class="comment">// 基于智能指针创建裸指针</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num_box</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num_box_ptr</span> = &amp;*num_box <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num_box_mutptr</span> = &amp;<span class="keyword">mut</span> *num_box <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">        <span class="comment">// *num_box_ptr = 4;</span></span><br><span class="line">        *num_box_mutptr = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;gen_unsafe: num_box = &#123;&#125;, num_box_ptr = &#123;:p&#125;, num_box_mutptr = &#123;:p&#125;&quot;</span>,</span><br><span class="line">            num_box, num_box_ptr, num_box_mutptr</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">gen_unsafe</span>() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全抽象包裹 unsafe 代码，即将一个unsafe语句块放在安全的rust中</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(_slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], point: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = _slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(point &lt; len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ptr</span> = _slice.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">        <span class="comment">// (&amp;mut _slice[..point], &amp;mut _slice[point..]) 出现多个可变借用，不符合 rust 的借用规则，编译失败</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// 从可变裸指针获取可变引用</span></span><br><span class="line">            (</span><br><span class="line">                slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr, point), <span class="comment">// from_raw_parts_mut 通过指针和长度来创建一个新的切片，是一个unsafe方法</span></span><br><span class="line">                slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="title function_ invoke__">add</span>(point), len - point), <span class="comment">// ptr.add(point) 可以获取第二个切片的初始地址，是一个unsafe方法</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">split_at_mut</span>(&amp;<span class="keyword">mut</span> arr, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FFI</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">abs</span>(-<span class="number">3</span>)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: unsafe：unsafe 的作用</title>
      <link href="/2024/07/01/rust-unsafe%EF%BC%9Aunsafe-%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2024/07/01/rust-unsafe%EF%BC%9Aunsafe-%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="unsafe：unsafe-的作用"><a href="#unsafe：unsafe-的作用" class="headerlink" title="unsafe：unsafe 的作用"></a>unsafe：unsafe 的作用</h2><p>几乎每个语言都有 unsafe 关键字，但 rust 语言使用 unsafe 的原因可能与其它编程语言还有所不同。</p><p>rust 中 unsafe 的存在主要原因是 rust 的静态检查强大且严格保守，这会导致编译器在分析一段代码时，无法分析出它的所有正确性，从而拒绝这段代码，触发编译错误。<br>特别是当编译器配合所有权系统一起使用时，有个别问题是真的棘手和难以解决。</p><p>unsafe 存在的另一个原因是：它必须要存在。因为计算机底层的一些硬件就是不安全的，如果 Rust 只允许你做安全的操作，那一些任务就无法完成。</p><p>rust 编译器不仅强大且严格保守，而且编译检查也是很难绕过的。通常想要绕过，最常用的方法就是 unsafe 和 Pin，并且这俩还有一定的限制。</p><h3 id="unsafe-的五种超能力-（unsafe-superpowers）"><a href="#unsafe-的五种超能力-（unsafe-superpowers）" class="headerlink" title="unsafe 的五种超能力 （unsafe superpowers）"></a>unsafe 的五种超能力 （unsafe superpowers）</h3><p><strong>unsafe 不意味着块中的代码就一定是危险的或者必然导致内存安全问题</strong>，它只提供了<strong>五个不会被编译器检查内存安全的功能</strong>。<br>这意味着：unsafe 并不会关闭借用检查器或禁用任何其他 Rust 安全检查，例如在不安全代码中使用引用，它仍会受到编译器的检查。</p><p><strong>使用原则一</strong>：没必要用时就不要用，当有必要用时就大胆用，但是尽量控制好边界，让 unsafe 的范围尽可能小。<br>因为就算内存访问出错了，也能立刻意识到错误是在 unsafe 代码块中，而不需要花大量时间像无头苍蝇一样去寻找问题所在。<br>因此写代码时要尽量控制好 unsafe 的边界大小，越小的 unsafe 越容易定位。</p><p><strong>使用原则二</strong>：除了控制边界大小，另一个很常用的方式就是在 unsafe 代码块外包裹一层 safe 的 API，例如一个函数声明为 safe 的，然后在其内部有一块儿是 unsafe 代码。</p><p>五种超能力（unsafe superpowers）：</p><ul><li>解引用裸指针</li><li>调用不安全的函数或方法</li><li>访问或修改可变静态变量</li><li>实现不安全 trait</li><li>访问 union 的字段</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 转换和边界异常处理</title>
      <link href="/2024/06/30/rust-%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%BE%B9%E7%95%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2024/06/30/rust-%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%BE%B9%E7%95%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="转换和边界异常处理"><a href="#转换和边界异常处理" class="headerlink" title="转换和边界异常处理"></a>转换和边界异常处理</h2><p>Result 和 Option 在业务程序中很常见，并且通常还需要自定义错误类型以便快速定位问题。</p><h3 id="组合器"><a href="#组合器" class="headerlink" title="组合器"></a>组合器</h3><p>因为 Result 和 Option 类型很常见，但使用真实值时需要取出再判断，或者 Result 和 Option 互相转换，这些操作都显得比较琐碎，所以 rust 提供了一些组合器简化这些操作。<br>这些操作的功能与 JavaScript 的与或非 <code>|, ||, &amp;, &amp;&amp;, !</code> 的功能类似，可以返回某个值。</p><p>组合器不同于组合模式，组合器更多的是用于对返回结果的类型进行变换：例如使用 ok_or 将一个 Option 类型转换成 Result 类型。</p><blockquote><p>组合模式：将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。–GoF &lt;&lt;设计模式&gt;&gt;</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">id</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">id</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = id.<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;没有数据的错误信息&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, id.<span class="title function_ invoke__">unwrap</span>());</span><br></pre></td></tr></table></figure><h4 id="or-和-and"><a href="#or-和-and" class="headerlink" title="or 和 and"></a>or 和 and</h4><p>这两个方法会对两个 Option 表达式或两个 Result 表达式做逻辑组合，最终返回 Option 或 Result。</p><ul><li>or()，表达式按照顺序求值，若任何一个表达式的结果是 Some 或 Ok，则该值会立刻返回</li><li>and()，若两个表达式的结果都是 Some 或 Ok，则第二个表达式中的值被返回。若任何一个的结果是 None 或 Err ，则立刻返回。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// or 和 and</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">id1</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">id2</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;id1 or id2 = &#123;:?&#125;, id1 and id2 = &#123;:?&#125;, id2 or id1 = &#123;:?&#125;, id2 and id1 = &#123;:?&#125;&quot;</span>,</span><br><span class="line">    id1.<span class="title function_ invoke__">or</span>(id2),</span><br><span class="line">    id1.<span class="title function_ invoke__">and</span>(id2),</span><br><span class="line">    id2.<span class="title function_ invoke__">or</span>(id1),</span><br><span class="line">    id2.<span class="title function_ invoke__">and</span>(id1)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>除了 or 和 and 之外，Rust 还提供了异或 xor ，但是它只能应用在 Option 上，不能应用在 Result 上，因为不能对一个值和错误进行异或操。</p><h4 id="or-else-和-and-then"><a href="#or-else-和-and-then" class="headerlink" title="or_else() 和 and_then()"></a>or_else() 和 and_then()</h4><p>它们跟 or() 和 and() 类似，唯一的区别在于，它们的第二个表达式是一个返回 Option 或 Result 的闭包。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// or_else 或 and_then</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">id1</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">id2</span> = || <span class="literal">None</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">id3</span> = |_| <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 impl 不能作为直接作为普通变量的类型</span></span><br><span class="line"><span class="comment">// let id3: impl Fn() -&gt; Option&lt;i32&gt; = || None; error `impl Trait` is only allowed in arguments and return types</span></span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;id1.or_else(id2) = &#123;:?&#125;, id1.and_then(id3) = &#123;:?&#125;&quot;</span>,</span><br><span class="line">    id1.<span class="title function_ invoke__">or_else</span>(id2),</span><br><span class="line">    id1.<span class="title function_ invoke__">and_then</span>(id3)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter 用于对 Option 进行条件过滤：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter 用于对 Option 进行条件过滤</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">id1</span> = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">is_even</span> = |x: &amp;<span class="type">i32</span>| x % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;id1.filter(is_event) = &#123;:?&#125;&quot;</span>, id1.<span class="title function_ invoke__">filter</span>(is_even));</span><br></pre></td></tr></table></figure><h4 id="map-map-err-map-or-map-or-else"><a href="#map-map-err-map-or-map-or-else" class="headerlink" title="map, map_err, map_or, map_or_else"></a>map, map_err, map_or, map_or_else</h4><p>map 可以将 Some 中的值映射为另一个 Some，Ok 类似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">id1</span> = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mapFn</span> = |x: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;id1.map(mapFn) = &#123;:?&#125;&quot;</span>, id1.<span class="title function_ invoke__">map</span>(mapFn))</span><br></pre></td></tr></table></figure><p>如果需要对 Result 的 Err 的信息进行修改，就需要使用 map_err。</p><p>map_or 和 map_or_else 在 map 的基础上添加了一个默认值，区别是 map_or 给定指定类型的默认值，map_or_else 通过闭包提供默认值。</p><h4 id="ok-or-ok-or-else"><a href="#ok-or-ok-or-else" class="headerlink" title="ok_or ok_or_else"></a>ok_or ok_or_else</h4><p>ok_or 和 ok_or_else 都是将 Option 转换为 Result 的组合器，两者都接受一个 Err 默认参数，ok_or 直接给定类型参数，ok_or_else 通过闭包给定默认参数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">id</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">id</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = id.<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;没有数据的错误信息&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, id.<span class="title function_ invoke__">unwrap</span>());</span><br></pre></td></tr></table></figure><h3 id="自定义错误类型"><a href="#自定义错误类型" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h3><p>虽然标准库定义了大量的错误类型，但光使用这些错误类型往往是不够的。在业务场景中，往往会自定义相应的错误(异常)类型。<br>比如返回示例中常见的 JSON：<code>&#123; &quot;code&quot;: 50020, &quot;msg&quot;: &quot;fail&quot; &#125;</code>。</p><p>为了更好的定义错误类型，标准库中定义了一些可复用的特征，比如 <code>std::error::Error</code> 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="built_in">Debug</span>, Display&#125;;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Error</span>: <span class="built_in">Debug</span> + Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">source</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;(Error + <span class="symbol">&#x27;static</span>)&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当自定义类型实现该特征后，该类型就可以作为 Err 来使用。<br>实际上，rust 自定义错误类型非常简单，可以不实现 <code>std::error::Error</code>，只需要实现 Debug 和 Display 特征即可，这也就是说 source 方法是可选的。<br>同时 Debug 特征往往无需手动实现，可以通过 derive 来派生，即可以选择自定义 Debug，也可以选择 derive Debug 特征。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义错误</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    code: <span class="type">i32</span>,</span><br><span class="line">    msg: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为自定义错误实现 Display 特征</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(</span><br><span class="line">            f,</span><br><span class="line">            <span class="string">&quot;Display: AppError &#123;&#123; code: &#123;&#125;, message: &#123;&#125; &#125;&#125;, try again!&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.code, <span class="keyword">self</span>.msg</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为自定义错误实现 Debug 特征，也可以通过派生 Debug 实现</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::<span class="built_in">Debug</span> <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(</span><br><span class="line">            f,</span><br><span class="line">            <span class="string">&quot;Debug: AppError &#123;&#123; code: &#123;&#125;, message: &#123;&#125; &#125;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.code, <span class="keyword">self</span>.msg</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">produce_error</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AppError&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(AppError &#123;</span><br><span class="line">        code: <span class="number">404</span>,</span><br><span class="line">        msg: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Page not found&quot;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">produce_error</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(err) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, err),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No error&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，实现 Debug 和 Display 特征并不是作为 Err 使用的必要条件，把这两个特征实现和相应使用去除也不会报错。为自定义类型实现这两个特征的原因有二:</p><ul><li>错误打印输出后，才能有实际用处，而打印输出就需要实现这两个特征</li><li>可以将自定义错误转换成 Box<dyn std::error:Error> 特征对象，用来做归一化不同错误类型</li></ul><h3 id="From-特征，错误转换"><a href="#From-特征，错误转换" class="headerlink" title="From 特征，错误转换"></a>From 特征，错误转换</h3><p>在一个函数运行中可能会产生不同的错误，如何将这些错误转换成自定义类型的错误呢？rust 提供 <code>std::convert::From</code> 特征解决转换问题。<br>在生成 String 时经常使用到的 String::from 就是 <code>std::convert::From</code> 提供的功能。</p><blockquote><p><code>std::convert::From</code> 已在 std::prelude 中，无需手动导入。</p></blockquote><p>在错误的转换中，还有一点特别重要，<code>?</code> 可以自动将错误进行隐式的强制转换.</p><p>为自定义错误实现 From 特征，将多种错误类型转换成自定义错误类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为自定义错误实现 From 特征，将 io::Error 转换成自定义错误</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: io::Error) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        AppError &#123;</span><br><span class="line">            kind: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;io&quot;</span>),</span><br><span class="line">            msg: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(error.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为自定义错误实现 From 特征，将 num::ParseIntError 转换成自定义错误</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;num::ParseIntError&gt; <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: num::ParseIntError) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        AppError &#123;</span><br><span class="line">            kind: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;parse&quot;</span>),</span><br><span class="line">            msg: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(error.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gen_error</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AppError&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数标注返回AppError，有一点特别重要，? 可以将错误进行隐式的强制转换，将ParseIntError转换成 AppError</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span>: <span class="type">i32</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>).<span class="title function_ invoke__">parse</span>()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">gen_error</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No error&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归一化不同的错误类型"><a href="#归一化不同的错误类型" class="headerlink" title="归一化不同的错误类型"></a>归一化不同的错误类型</h3><p>系统运行时产生的错误不止一种，为了区分，往往会对这些不同的错误定义不同的错误类型。<br>这带来一个问题，函数运行时可能产生不同的错误类型，但函数的返回值类型只有一个，怎么统一不同的错误类型？</p><p>大概有三种方式：</p><ul><li>From 特征转换</li><li>Box&lt;dyn std::error::Error&gt;</li><li>第三方库</li></ul><h4 id="From-归一化"><a href="#From-归一化" class="headerlink" title="From 归一化"></a>From 归一化</h4><p>在 <code>std::convert::From</code> 特征转换错误中，介绍了将其他错误转换成自定义错误的过程，<code>std::convert::From</code> 就是一种归一化的方式。</p><p>From 特征转换的缺点是非常的繁琐，需要为自定义错误类型实现不同的 <code>From&lt;T&gt;</code> 特征后，才能转换成相应的特征对象。</p><h4 id="Box-lt-dyn-std-error-Error-gt"><a href="#Box-lt-dyn-std-error-Error-gt" class="headerlink" title="Box&lt;dyn std::error::Error&gt;"></a>Box&lt;dyn std::error::Error&gt;</h4><p>在标准库中，<code>std::error::Error</code> 是最基础的错误类型，大部分错误类型都能自动转换成 <code>std::error::Error</code>，自定义类型实现 Debug + Display 特征的主要原因也是为了能转换成 Error 的特征对象。</p><p>但是 <code>Box&lt;dyn Error&gt;</code> 会有一个问题，因为 <code>Result&lt;T, E&gt;</code> 中的 <code>E</code> 不限制类型，即 E 错误类型不要求一定要实现 <code>std::error::Error</code> 特征。<br>这样就无法用 <code>Box&lt;dyn Error&gt;</code> 代表所有的错误类型，因为自定义错误类型不一定是实现了 <code>std:error::Error</code> 的类型。</p><p>当然能用 <code>Box&lt;dyn Error&gt;</code> 特征对象的时候，还是尽量使用特征对象，因为 <code>Box&lt;dyn Error&gt;</code> 代码可读性还是比较高的。</p><h3 id="简化错误处理"><a href="#简化错误处理" class="headerlink" title="简化错误处理"></a>简化错误处理</h3><p>无论是自定义错误转换还是使用 <code>Box&lt;dyn Error&gt;</code> 都有一些小问题，通常情况下 <code>Box&lt;dyn Error&gt;</code> 可以满足需求，如果需要自定义转换错误，就可以使用第三方库。</p><h4 id="thiserror"><a href="#thiserror" class="headerlink" title="thiserror"></a>thiserror</h4><p>thiserror 可以简化自定义错误转换的过程，主要用到两点：</p><ul><li><code>#[error(错误的描述)]</code></li><li><code>#[from] Error</code> 指定自定义错误可以由某个错误转换</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 thiserror 简化自定义转换的逻辑</span></span><br><span class="line"><span class="meta">#[derive(thiserror::Error, Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ThisError</span> &#123;</span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;I/O error occurred&quot;</span>)]</span> <span class="comment">// #[error(错误的描述)]</span></span><br><span class="line">    IOError,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[error(<span class="string">&quot;ParseIntError occurred&quot;</span>)]</span></span><br><span class="line">    <span class="title function_ invoke__">ParseIntError</span>(<span class="meta">#[from]</span> num::ParseIntError), <span class="comment">// #[from] Error 指定自定义错误可以由某个错误转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gen_thiserror</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), ThisError&gt; &#123;</span><br><span class="line">    <span class="comment">// turbo fish,</span></span><br><span class="line">    <span class="comment">// ::&lt;T&gt; 用于显式指定泛型类型参数</span></span><br><span class="line">    <span class="comment">// ::&lt;T&gt;::() 是显式指定数据结构类型的泛型类型参数并调用改数据结构类型内部的函数或方法的组合语法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>).parse::&lt;<span class="type">i32</span>&gt;()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">gen_thiserror</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No Errror&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多操作可阅读：<a href="https://juejin.cn/post/7272005801081126968">https://juejin.cn/post/7272005801081126968</a></p><h4 id="anyhow"><a href="#anyhow" class="headerlink" title="anyhow"></a>anyhow</h4><blockquote><p>anyhow 和 thiserror 是同一个作者开发的，这里是作者关于 anyhow 和 thiserror 的原话：<br>如果想要设计自己的错误类型，同时给调用者提供具体的信息时，就使用 thiserror，例如在开发一个三方库代码时。<br>如果只想要简单，就使用 anyhow，它会接收所有的类型，例如在自己的应用服务中。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 anyhow 接收所有的错误类型</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gen_anyhowerror</span>() <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>).parse::&lt;<span class="type">i32</span>&gt;()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">gen_anyhowerror</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No Errror&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="error-chain"><a href="#error-chain" class="headerlink" title="error-chain"></a>error-chain</h4><p>使用 error-chain 的宏可以获得：Error 结构体，错误类型 ErrorKind 枚举 以及一个自定义的 Result 类型。<br>注意，默认情况下它会在当前作用域中生成这三个数据结构，可能会污染当前作用域。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//  Option 转换成 Result</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = id.<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;没有数据的错误信息&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, id.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// or 和 and</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id1</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id2</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;id1.or(id2) = &#123;:?&#125;, id1.and(id2) = &#123;:?&#125;, id2.or(id1) = &#123;:?&#125;, id2.and(id1) = &#123;:?&#125;&quot;</span>,</span><br><span class="line">        id1.<span class="title function_ invoke__">or</span>(id2),</span><br><span class="line">        id1.<span class="title function_ invoke__">and</span>(id2),</span><br><span class="line">        id2.<span class="title function_ invoke__">or</span>(id1),</span><br><span class="line">        id2.<span class="title function_ invoke__">and</span>(id1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// or_else 或 and_then</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id1</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id2</span> = || <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id3</span> = |_| <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意 impl 不能作为直接作为普通变量的类型</span></span><br><span class="line">    <span class="comment">// let id3: impl Fn() -&gt; Option&lt;i32&gt; = || None; error `impl Trait` is only allowed in arguments and return types</span></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;id1.or_else(id2) = &#123;:?&#125;, id1.and_then(id3) = &#123;:?&#125;&quot;</span>,</span><br><span class="line">        id1.<span class="title function_ invoke__">or_else</span>(id2),</span><br><span class="line">        id1.<span class="title function_ invoke__">and_then</span>(id3)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter 用于对 Option 进行条件过滤</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id1</span> = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_even</span> = |x: &amp;<span class="type">i32</span>| x % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;id1.filter(is_event) = &#123;:?&#125;&quot;</span>, id1.<span class="title function_ invoke__">filter</span>(is_even));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map 可以将 Some 中的值映射为另一个 Some，Ok 类似</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id1</span> = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mapFn</span> = |x: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">2</span> &#123;</span><br><span class="line">            <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;id1.map(mapFn) = &#123;:?&#125;&quot;</span>, id1.<span class="title function_ invoke__">map</span>(mapFn));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义错误</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">        kind: <span class="type">String</span>,</span><br><span class="line">        msg: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">            <span class="built_in">write!</span>(</span><br><span class="line">                f,</span><br><span class="line">                <span class="string">&quot;Display: AppError &#123;&#123; kind: &#123;&#125;, message: &#123;&#125; &#125;&#125;, try again!&quot;</span>,</span><br><span class="line">                <span class="keyword">self</span>.kind, <span class="keyword">self</span>.msg</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">fmt</span>::<span class="built_in">Debug</span> <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">            <span class="built_in">write!</span>(</span><br><span class="line">                f,</span><br><span class="line">                <span class="string">&quot;Debug: AppError &#123;&#123; kind: &#123;&#125;, message: &#123;&#125; &#125;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">self</span>.kind, <span class="keyword">self</span>.msg</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">produce_error</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AppError&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(AppError &#123;</span><br><span class="line">            kind: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">            msg: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Page not found&quot;</span>),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">produce_error</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, err),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No error&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为自定义错误实现 From 特征，将 io::Error 转换成自定义错误</span></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">from</span>(error: io::Error) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            AppError &#123;</span><br><span class="line">                kind: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;io&quot;</span>),</span><br><span class="line">                msg: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(error.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为自定义错误实现 From 特征，将 num::ParseIntError 转换成自定义错误</span></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">From</span>&lt;num::ParseIntError&gt; <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">from</span>(error: num::ParseIntError) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            AppError &#123;</span><br><span class="line">                kind: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;parse&quot;</span>),</span><br><span class="line">                msg: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(error.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">gen_error</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AppError&gt; &#123;</span><br><span class="line">        <span class="comment">// 函数标注返回AppError，有一点特别重要，? 可以将错误进行隐式的强制转换，将ParseIntError转换成 AppError</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num</span>: <span class="type">i32</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>).<span class="title function_ invoke__">parse</span>()?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">gen_error</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No error&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 thiserror 简化自定义转换的逻辑</span></span><br><span class="line">    <span class="meta">#[derive(thiserror::Error, Debug)]</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ThisError</span> &#123;</span><br><span class="line">        <span class="meta">#[error(<span class="string">&quot;I/O error occurred&quot;</span>)]</span> <span class="comment">// #[error(错误的描述)]</span></span><br><span class="line">        IOError,</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[error(<span class="string">&quot;ParseIntError occurred&quot;</span>)]</span></span><br><span class="line">        <span class="title function_ invoke__">ParseIntError</span>(<span class="meta">#[from]</span> num::ParseIntError), <span class="comment">// #[from] 指定自定义错误可以由某个错误转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">gen_thiserror</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), ThisError&gt; &#123;</span><br><span class="line">        <span class="comment">// turbo fish,</span></span><br><span class="line">        <span class="comment">// ::&lt;T&gt; 用于显式指定泛型类型参数</span></span><br><span class="line">        <span class="comment">// ::&lt;T&gt;::() 是显式指定数据结构类型的泛型类型参数并调用改数据结构类型内部的函数或方法的组合语法</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>).parse::&lt;<span class="type">i32</span>&gt;()?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">gen_thiserror</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No Errror&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 anyhow 接收所有的错误类型</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">gen_anyhowerror</span>() <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>).parse::&lt;<span class="type">i32</span>&gt;()?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">gen_anyhowerror</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No Errror&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 全局变量</title>
      <link href="/2024/06/27/rust-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
      <url>/2024/06/27/rust-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在一些场景，我们可能需要全局变量来简化状态共享的代码，包括全局 ID，全局数据存储等等。</p><p>全局变量是一种特殊的变量，在 rust 中相对复杂，但有一点可以肯定，全局变量的生命周期肯定是’static，但是不代表它需要用 static 来声明。</p><p>具体来说，全局变量分为编译期初始化和运行期初始化两种。</p><p><strong>常量与普通变量的区别</strong></p><ul><li>关键字是 const 而不是 let</li><li>定义常量必须指明类型（如 i32），不能省略</li><li>定义常量时变量的命名规则一般是全部大写</li><li>对于变量出现重复的定义(绑定)会发生变量遮盖，后面定义的变量会遮住前面定义的变量，常量则不允许出现重复的定义</li><li>常量可以在任意作用域进行定义，其生命周期贯穿整个程序的生命周期。编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址</li><li>编译期初始化常量的赋值只能是常量表达式&#x2F;数学表达式，也就是说必须是在编译期就能计算出的值，如果需要在运行时才能得出结果的值比如函数，则不能赋值给常量表达式。即常量的赋值不能在程序运行时通过配置实现。</li></ul><h3 id="编译期初始化"><a href="#编译期初始化" class="headerlink" title="编译期初始化"></a>编译期初始化</h3><p>大多数使用的全局变量都只需要在编译期初始化，例如静态配置、计数器、状态值等等。</p><h4 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h4><p>全局常量可以在程序任何一部分使用，如果它是定义在某个模块中，则需要引入对应的模块才能使用。全局常量很适合用作静态配置：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_ID: <span class="type">usize</span> =  <span class="type">usize</span>::MAX / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;最大的用户 ID = &#123;&#125;&quot;</span>, MAX_ID);</span><br></pre></td></tr></table></figure><p>常量可以在任意作用域中定义，编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址。</p><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>静态变量允许声明一个全局的变量，常用于全局数据统计，例如统计总请求数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> REQUEST_COUNT: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// 操作 static 类型的变量需要 unsafe 模块</span></span><br><span class="line">    <span class="comment">// 因为这种使用方式往往并不安全，当在多线程中同时去修改时，会不可避免的遇到脏数据</span></span><br><span class="line">    REQUEST_COUNT = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;REQUEST_COUNT = &#123;&#125;&quot;</span>, REQUEST_COUNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作 static 类型的变量需要 unsafe 作用域，因为这种使用方式往往并不安全，当在多线程中同时去修改时，会不可避免的遇到脏数据。</p><p>和常量相同，定义静态变量的时候必须赋值为在编译期就可以计算出的值(常量表达式&#x2F;数学表达式)，不能是运行时才能计算出的值(如函数)，即不能通过程序运行时再配置定义静态变量。</p><p>编译期初始化错误的案例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NAMES: Mutex&lt;<span class="type">String</span>&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Sunface, Jack, Allen&quot;</span>)); <span class="comment">// 错误，静态变量不能通过函数在编译期初始化</span></span><br></pre></td></tr></table></figure><h4 id="静态变量和常量的区别"><a href="#静态变量和常量的区别" class="headerlink" title="静态变量和常量的区别"></a>静态变量和常量的区别</h4><ul><li>静态变量不会被内联，在整个程序中，静态变量只有一个实例，所有的引用都会指向同一个地址</li><li>为了能在多线程中正常使用，存储在静态变量中的值必须要实现 Sync trait</li></ul><h4 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h4><p>原子类型是多线程共享数据的线程安全的最好方式之一：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子类型是共享状态最好的一种方式</span></span><br><span class="line"><span class="keyword">static</span> REQUEST_RECV: AtomicUsize = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        REQUEST_RECV.<span class="title function_ invoke__">fetch_add</span>(i, Ordering::SeqCst);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;REQUEST_RECV = &#123;&#125;&quot;</span>, REQUEST_RECV.<span class="title function_ invoke__">load</span>(Ordering::SeqCst));</span><br></pre></td></tr></table></figure><h3 id="运行期初始化"><a href="#运行期初始化" class="headerlink" title="运行期初始化"></a>运行期初始化</h3><p>为什么需要运行期初始化呢？常见的场景是：一个全局的动态配置，它在程序开始后，才加载数据进行初始化，最终可以让各个线程直接访问使用。</p><p>编译期初始化最大的限制是必须赋值为在编译期就可以计算出的值(常量表达式&#x2F;数学表达式)，不能是运行时才能计算出的值(如函数)：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NAMES: Mutex&lt;<span class="type">String</span>&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>)); <span class="comment">// 错误，静态变量不能通过函数在编译期初始化</span></span><br></pre></td></tr></table></figure><p>因为 Rust 的<strong>借用和生命周期规则的限制</strong>，如果需要在运行期初始化一个全局变量，就需要考虑 <code>lazy_static</code>、<code>Box::leak</code> 等方式。</p><h4 id="lazy-static"><a href="#lazy-static" class="headerlink" title="lazy_static"></a>lazy_static</h4><p>lazy_static 是社区提供的非常强大的宏，用于懒初始化静态变量，之前的静态变量都是在编译期初始化的，因此无法使用函数调用进行赋值，而 lazy_static 允许在运行期初始化静态变量！</p><p>lazy_static 宏，匹配的是 static ref，所以定义的静态变量都是不可变引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 lazy_static 在运行期初始化一个全局变量</span></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> NAMES: Mutex&lt;<span class="type">String</span>&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">names</span> = NAMES.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    names.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">    names.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;NAMES = &#123;:?&#125;&quot;</span>, NAMES.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br></pre></td></tr></table></figure><p>需要注意的是，lazy_static 直到运行到 main 中的第一行代码时，才进行初始化。<br>并且使用 lazy_static 在每次访问静态变量时，会有轻微的性能损失，因为其内部实现用了一个底层的并发原语 std::sync::Once，在每次访问该变量时，程序都会执行一次原子指令用于确认静态变量的初始化是否完成。</p><h4 id="Box-leak"><a href="#Box-leak" class="headerlink" title="Box::leak"></a>Box::leak</h4><p>在正常的生命周期中，rust 是不允许将一个只有局部生命周期的变量赋值给 <code>&#39;static</code> 全局的生命周期，因为这容易造成访问未定义的行为，非常不安全。</p><p>通过 <code>Box::leak</code> 将一个变量从内存中泄露，使其成为 <code>&#39;static</code> 生命周期，这样就可以赋值给 <code>&#39;static</code> 生命周期的全局变量，也就能达到在运行时初始化全局变量的目的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Box::leak 将变量从内存中泄露出去，使其成为 &#x27;static 的生命周期，这样就可以赋值给具有 &#x27;static 生命周期的全局变量，也就能达到在运行时初始化全局变量的目的</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    secret: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> CONFIG: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> Config&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">config</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Config &#123;</span><br><span class="line">    secret: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    CONFIG = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(config));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, CONFIG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数返回全局变量"><a href="#函数返回全局变量" class="headerlink" title="函数返回全局变量"></a>函数返回全局变量</h4><p>借助 Box::leak 通过借用和生命周期规则校验，将一个变量变为 <code>&#39;static</code>，保证与程序活的一样久即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数返回一个全局变量，借助 Box::leak 即可</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">init_static</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Config &#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Config &#123;</span><br><span class="line">        secret: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;None DO&quot;</span>),</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    CONFIG = <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">init_static</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, CONFIG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OnceCell-和-OnceLock"><a href="#OnceCell-和-OnceLock" class="headerlink" title="OnceCell 和 OnceLock"></a>OnceCell 和 OnceLock</h3><p>在 Rust 标准库中提供了实验性的 lazy::OnceCell 和 lazy::SyncOnceCell (在 Rust 1.70.0 版本及以上的标准库中，替换为稳定的 cell::OnceCell 和 sync::OnceLock)两种 Cell。<br>前者用于单线程，后者用于多线程，它们用来存储堆上的信息，并且具有最多只能赋值一次的特性。</p><p>阅读：<a href="https://course.rs/advance/global-variable.html#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84-oncecell">https://course.rs/advance/global-variable.html#标准库中的-oncecell</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>编译期初始化的全局变量，const 创建常量，static 创建静态变量，Atomic 创建原子类型</li><li>运行期初始化的全局变量，lazy_static 用于懒初始化，Box::leak 利用内存泄漏将一个变量的生命周期变为’static</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//  静态常量</span></span><br><span class="line">    <span class="keyword">const</span> MAX_ID: <span class="type">usize</span> = <span class="type">usize</span>::MAX / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;最大的用户 ID = &#123;&#125;&quot;</span>, MAX_ID);</span><br><span class="line">    <span class="comment">// 静态变量不能通过函数在编译期初始化</span></span><br><span class="line">    <span class="comment">// static NAMES: Mutex&lt;String&gt; = Mutex::new(String::from(&quot;Hello World&quot;));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">mut</span> REQUEST_COUNT: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 操作 static 类型的变量需要 unsafe 作用域</span></span><br><span class="line">        <span class="comment">// 因为这种使用方式往往并不安全，当在多线程中同时去修改时，会不可避免的遇到脏数据</span></span><br><span class="line">        REQUEST_COUNT = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;REQUEST_COUNT = &#123;&#125;&quot;</span>, REQUEST_COUNT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子类型是共享状态最好的一种方式</span></span><br><span class="line">    <span class="keyword">static</span> REQUEST_RECV: AtomicUsize = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            REQUEST_RECV.<span class="title function_ invoke__">fetch_add</span>(i, Ordering::SeqCst);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;REQUEST_RECV = &#123;&#125;&quot;</span>, REQUEST_RECV.<span class="title function_ invoke__">load</span>(Ordering::SeqCst));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 lazy_static 在运行期初始化一个全局变量</span></span><br><span class="line">    lazy_static! &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">ref</span> NAMES: Mutex&lt;<span class="type">String</span>&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">names</span> = NAMES.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        names.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">        names.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;NAMES = &#123;:?&#125;&quot;</span>, NAMES.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Box::leak 将变量从内存中泄露出去，使其成为 &#x27;static 的生命周期，这样就可以赋值给具有 &#x27;static 生命周期的全局变量，也就能达到在运行时初始化全局变量的目的</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        secret: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">mut</span> CONFIG: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> Config&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Config &#123;</span><br><span class="line">        secret: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        CONFIG = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(config));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, CONFIG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数返回一个全局变量，借助 Box::leak 即可</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">init_static</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Config &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Config &#123;</span><br><span class="line">            secret: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;None DO&quot;</span>),</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        CONFIG = <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">init_static</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, CONFIG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 基于 Send 和 Sync 的线程安全</title>
      <link href="/2024/06/27/rust-%E5%9F%BA%E4%BA%8E-Send-%E5%92%8C-Sync-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2024/06/27/rust-%E5%9F%BA%E4%BA%8E-Send-%E5%92%8C-Sync-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="基于-Send-和-Sync-的线程安全"><a href="#基于-Send-和-Sync-的线程安全" class="headerlink" title="基于 Send 和 Sync 的线程安全"></a>基于 Send 和 Sync 的线程安全</h2><p>为什么 Arc 可以在多线程中安全使用，而 Rc、RefCell 和裸指针不可以在多线程间使用呢，这归功于 Send 和 Sync 两个特征。</p><h3 id="Send-和-Sync"><a href="#Send-和-Sync" class="headerlink" title="Send 和 Sync"></a>Send 和 Sync</h3><p>Send 和 Sync 是 Rust 安全并发的重中之重，但是实际上它们只是标记特征(marker trait，该特征未定义任何行为，只用于标记)：</p><ul><li>实现 Send 特征的类型可以在线程间安全的传递其所有权，即<strong>数据能够在不同线程之间转移</strong></li><li>实现 Sync 特征的类型可以在线程间安全的共享(通过引用)，即<strong>数据能够在不同线程之间共享</strong></li></ul><p>这里有一个潜在的依赖：一个类型要在线程间安全的共享的前提是，指向它的引用必须能在线程间传递。<br>因为如果引用都不能被传递，我们就无法在多个线程间使用引用去访问同一个数据了。<br>这意味着：如果 T 为 Sync 则 &amp;T 为 Send，并且这个关系反过来在大部分情况下都是正确的，即如果 &amp;T 为 Send 则 T 为 Sync。</p><p>观察 Rc 和 Arc 的源码片段：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rc源码片段</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !marker::<span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Rc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !marker::<span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Rc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arc源码片段</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>!</code> 代表移除特征的相应实现，上面代码中 <code>Rc&lt;T&gt;</code> 的 Send 和 Sync 特征被特地移除了实现，而 <code>Arc&lt;T&gt;</code> 则相反，实现了 Sync + Send。</p><p>再看一下 Mutex，Mutex 是没有 Sync 特征限制的，这意味着 Mutex 不能直接用于线程共享：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Mutex</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-Send-和-Sync-的类型"><a href="#实现-Send-和-Sync-的类型" class="headerlink" title="实现 Send 和 Sync 的类型"></a>实现 Send 和 Sync 的类型</h3><p>在 Rust 中，几乎所有类型都默认实现了 Send 和 Sync，而且由于这两个特征都是可自动派生的特征(通过 derive 派生)。</p><p>一个复合类型(例如结构体), 只要它内部的所有成员都实现了 Send 或者 Sync，那么它就自动实现了 Send 或 Sync。</p><p>正是因为以上规则，Rust 中绝大多数类型都实现了 Send 和 Sync，常见的未实现有以下几个:</p><ul><li>裸指针两者都没实现，它本身没有任何安全保证</li><li>UnsafeCell 没有实现 Sync，因此 Cell 和 RefCell 也不是</li><li>Rc 两者都没实现(因为内部的引用计数器不是线程安全的)</li></ul><p>当然，如果是自定义的复合类型，那没实现这两个特征就比较常见：只要复合类型中有一个成员不是 Send 或 Sync，那么该复合类型也就不是 Send 或 Sync。</p><p>手动实现 Send 和 Sync 是不安全的，通常并不需要手动实现 Send 和 Sync trait，实现者需要使用 unsafe 小心维护并发安全保证。</p><h3 id="为裸指针实现-Send-和-Sync"><a href="#为裸指针实现-Send-和-Sync" class="headerlink" title="为裸指针实现 Send 和 Sync"></a>为裸指针实现 Send 和 Sync</h3><p>无法直接为裸指针实现 Send 和 Sync 特征，因此需要借助 newtype 为裸指针实现这两个特征。<br>但有一点需要注意：Send 和 Sync 是 unsafe 特征，实现时需要用 unsafe 代码块包裹。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>(*<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line"><span class="comment">// 为裸指针实现 Send 特征，支持数据在不同线程中转移</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Send</span> <span class="keyword">for</span> <span class="title class_">MyBox</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send 特征支持数据在不同线程中转移</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="title function_ invoke__">MyBox</span>(<span class="number">5</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, b);</span><br><span class="line">&#125;);</span><br><span class="line">h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p>Sync 特征支持数据在不同的线程中共享，但在多线程中共享数据涉及到 rust 的单一所有权问题，此时需要搭配 Arc 才能在多线程中共享：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>(*<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line"><span class="comment">// 为裸指针实现 Send 特征，支持数据在不同线程中转移</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Send</span> <span class="keyword">for</span> <span class="title class_">MyBox</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 为裸指针实现 Sync 特征，支持数据在不同线程中共享</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Sync</span> <span class="keyword">for</span> <span class="title class_">MyBox</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send 特征支持数据在不同线程中转移</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="title function_ invoke__">MyBox</span>(<span class="number">5</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, b);</span><br><span class="line">&#125;);</span><br><span class="line">h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync 特征支持数据在不同的线程中共享，此时涉及到 rust 的所有权问题，需要搭配 Arc 才能在多线程中共享</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="title function_ invoke__">MyBox</span>(<span class="number">5</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arc_b</span> = Arc::<span class="title function_ invoke__">new</span>(b);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_arc_b</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;arc_b);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, _arc_b);</span><br><span class="line">&#125;);</span><br><span class="line">h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>实现 Send 特征的类型可以在线程间安全的传递其所有权，即数据支持在线程中转移</li><li>实现 Sync 特征的类型可以在线程间安全的共享(通过引用)，即数据支持在线程中共享</li><li>绝大部分类型都实现了 Send 和 Sync 特征，常见的未实现的有：裸指针、Cell、RefCell、Rc 等</li><li>可以为自定义类型实现 Send 和 Sync，但是需要 unsafe 代码块</li><li>可以为部分 Rust 中的类型实现 Send、Sync，但是需要使用 newtype，例如裸指针</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyBox</span>(*<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line">    <span class="comment">// 为裸指针实现 Send 特征，支持数据在不同线程中转移</span></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Send</span> <span class="keyword">for</span> <span class="title class_">MyBox</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 为裸指针实现 Sync 特征，支持数据在不同线程中共享</span></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Sync</span> <span class="keyword">for</span> <span class="title class_">MyBox</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send 特征支持数据在不同线程中转移</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="title function_ invoke__">MyBox</span>(<span class="number">5</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    &#125;);</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 特征支持数据在不同的线程中共享，此时涉及到 rust 的所有权问题，需要搭配 Arc 才能在多线程中共享</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="title function_ invoke__">MyBox</span>(<span class="number">5</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arc_b</span> = Arc::<span class="title function_ invoke__">new</span>(b);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_arc_b</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;arc_b);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, _arc_b);</span><br><span class="line">    &#125;);</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 线程同步：Atomic 原子类型与内存顺序</title>
      <link href="/2024/06/24/rust-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9AAtomic-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F/"/>
      <url>/2024/06/24/rust-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9AAtomic-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="线程同步：Atomic-原子类型与内存顺序"><a href="#线程同步：Atomic-原子类型与内存顺序" class="headerlink" title="线程同步：Atomic 原子类型与内存顺序"></a>线程同步：Atomic 原子类型与内存顺序</h2><p>在多线程环境下访问共享数据时，需要确保数据一致性和完整性。传统的方法是使用锁（如互斥锁 Mutex）来保护共享数据，但锁可能导致性能开销和潜在的死锁问题。<br>在 rust 中，Mutex 用起来简单但是无法并发读，RwLock 可以并发读但是使用场景较为受限且性能不够。</p><p>原子类型（atomic types）是并发编程中用于实现<strong>无锁（lock-free）同步</strong>的一种工具。它们提供了对<strong>基本数据类型</strong>的原子操作。</p><p>原子指的是一系列不可被 CPU 上下文交换的机器指令，这些指令组合在一起就形成了原子操作。<br>在多核 CPU 下，当某个 CPU 核心开始运行原子操作时，会先暂停其它 CPU 内核对内存的操作，以保证原子操作不会被其它 CPU 内核所干扰。<br>由于原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。</p><p>相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，几乎所有的语言都支持原子类型。</p><p>虽然原子类型是无锁类型，但是无锁不代表无需等待，因为原子类型内部使用了 CAS 循环，当大量的冲突发生时，还是需要等待，但是比锁要好。</p><blockquote><p>CAS 全称是 Compare and swap, 它通过一条指令读取指定的内存地址，然后判断其中的值是否等于给定的前置值，如果相等，则将其修改为新的值。</p></blockquote><p>原子类型提供了一组原子操作方法，如 load、store、swap、compare_and_swap、fetch_add 等。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  计算 1-5000000 的和，分为 5 个线程完成，最终总数为 x + (1 + 5000) * 5000 / 2</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicI64::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">thread_count</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">start_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..thread_count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">1000001</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 fetch_add 增加数据</span></span><br><span class="line">            _counter.<span class="title function_ invoke__">fetch_add</span>(i * j, Ordering::SeqCst);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// println!(&quot;&#123;&#125; 当前计算累加和 = &#123;&#125;&quot;, i, _counter.load(Ordering::SeqCst));</span></span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">end_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="comment">// 使用 load 获取数据</span></span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;counter = &#123;&#125;, time = &#123;:?&#125;&quot;</span>,</span><br><span class="line">    counter.<span class="title function_ invoke__">load</span>(Ordering::SeqCst),</span><br><span class="line">    end_time.<span class="title function_ invoke__">sub</span>(start_time)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这种情况下，使用互斥锁计算，会比原子类型花费更长的时间</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Mutex 计算 1-5000000 的和，分为五个线程，统计耗时</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">counter</span>: Arc&lt;Mutex&lt;<span class="type">i64</span>&gt;&gt; = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">thread_count</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">start_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..thread_count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">1000001</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 fetch_add 增加数据</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = _counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += i * j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// println!(&quot;&#123;&#125; 当前计算累加和 = &#123;&#125;&quot;, i, _counter.load(Ordering::SeqCst));</span></span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">end_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;counter = &#123;&#125;, time = &#123;:?&#125;&quot;</span>,</span><br><span class="line">    counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">    end_time.<span class="title function_ invoke__">sub</span>(start_time)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counter = 5000005000000, time = 226.9952ms</span><br><span class="line">counter = 5000005000000, time = 1.1381521s</span><br></pre></td></tr></table></figure><h3 id="内存顺序"><a href="#内存顺序" class="headerlink" title="内存顺序"></a>内存顺序</h3><p><a href="https://course.rs/advance/concurrency-with-threads/sync2.html#%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F">https://course.rs/advance/concurrency-with-threads/sync2.html#内存顺序</a></p><h3 id="Atomic-和互斥锁"><a href="#Atomic-和互斥锁" class="headerlink" title="Atomic 和互斥锁"></a>Atomic 和互斥锁</h3><p>原子类型并不能完全替代锁：</p><ul><li>对于复杂的场景下，锁的使用简单粗暴，不容易有坑</li><li>std::sync::atomic 包中仅提供了数值类型的原子操作：AtomicBool, AtomicIsize, AtomicUsize, AtomicI8, AtomicU16 等，而锁可以应用于各种类型</li><li>在有些情况下，必须使用锁来配合，例如使用 Mutex 配合 Condvar</li></ul><h3 id="Atomic-的应用场景"><a href="#Atomic-的应用场景" class="headerlink" title="Atomic 的应用场景"></a>Atomic 的应用场景</h3><p>事实上，Atomic 虽然对于用户不太常用，但是对于高性能库的开发者、标准库开发者都非常常用，它是并发原语的基石，除此之外，还有一些场景适用：</p><ul><li>无锁(lock free)数据结构</li><li>全局变量，例如全局自增 ID, 在后续章节会介绍</li><li>跨线程计数器，例如可以用于统计指标</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//  计算 1-5000000 的和，分为 5 个线程完成，最终总数为 x + (1 + 5000) * 5000 / 2</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicI64::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">thread_count</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..thread_count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">1000001</span> &#123;</span><br><span class="line">                <span class="comment">// 使用 fetch_add 增加数据</span></span><br><span class="line">                _counter.<span class="title function_ invoke__">fetch_add</span>(i * j, Ordering::SeqCst);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// println!(&quot;&#123;&#125; 当前计算累加和 = &#123;&#125;&quot;, i, _counter.load(Ordering::SeqCst));</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="comment">// 使用 load 获取数据</span></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;counter = &#123;&#125;, time = &#123;:?&#125;&quot;</span>,</span><br><span class="line">        counter.<span class="title function_ invoke__">load</span>(Ordering::SeqCst),</span><br><span class="line">        end_time.<span class="title function_ invoke__">sub</span>(start_time)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Mutex 计算 1-5000000 的和，分为五个线程，统计耗时</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span>: Arc&lt;Mutex&lt;<span class="type">i64</span>&gt;&gt; = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">thread_count</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..thread_count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">1000001</span> &#123;</span><br><span class="line">                <span class="comment">// 使用 fetch_add 增加数据</span></span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = _counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                *num += i * j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// println!(&quot;&#123;&#125; 当前计算累加和 = &#123;&#125;&quot;, i, _counter.load(Ordering::SeqCst));</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end_time</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;counter = &#123;&#125;, time = &#123;:?&#125;&quot;</span>,</span><br><span class="line">        counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        end_time.<span class="title function_ invoke__">sub</span>(start_time)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 线程同步：锁、Condvar 和信号量</title>
      <link href="/2024/06/21/rust-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E9%94%81%E3%80%81Condvar-%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2024/06/21/rust-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E9%94%81%E3%80%81Condvar-%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="线程同步：锁、Condvar-和信号量"><a href="#线程同步：锁、Condvar-和信号量" class="headerlink" title="线程同步：锁、Condvar 和信号量"></a>线程同步：锁、Condvar 和信号量</h2><p><strong>同步性指的是通过协调不同线程或任务的执行顺序来安全地共享数据和资源</strong>。<br>同步性是并发编程中的一个重要概念，涉及到如何保证多个执行单元（如线程或异步任务）之间正确且安全地访问共享资源，而不会导致数据竞争、死锁等问题。</p><p>借助 Rust 强大的类型系统和所有权模型，在编写多线程代码，需要使用同步性时，可以通过互斥锁(Mutex)、读写锁(RwLock)、原子类型(Atomic Types)和通道(Channel)等机制，编写高效且安全的并发程序。</p><p>在多线程间有多种方式可以共享和传递数据，最常用有两种：</p><ul><li>消息传递</li><li>锁和 Arc 联合使用</li></ul><p>对于消息传递，在编程界有一个大名鼎鼎的 <strong>Actor 线程模型</strong>为其背书，典型的有 Erlang 语言、Go 语言。</p><h3 id="如何选择数据共享方式"><a href="#如何选择数据共享方式" class="headerlink" title="如何选择数据共享方式"></a>如何选择数据共享方式</h3><p><strong>共享内存</strong>是同步的灵魂，消息传递的底层也是通过共享内存来实现的：</p><ul><li>消息传递类似一个单所有权的系统，一个值同时只能有一个所有者，如果另一个线程需要该值的所有权，需要将所有权通过消息传递进行转移，可以做到传递引用和传递值</li><li>而共享内存类似于一个多所有权的系统，多个线程可以同时访问同一个值，用锁来控制哪个线程可以在当前时刻访问，可以做到直接访问同一个内存</li></ul><p>对比两种方式：</p><ul><li>锁和 Arc 联合使用的共享内存相对消息传递能节省多次内存拷贝的成本</li><li>共享内存的实现简洁的多</li><li>共享内存的锁竞争更多</li></ul><p>消息传递适用的场景很多，几个主要的使用场景:</p><ul><li>需要可靠和简单的(简单不等于简洁)实现多线程编程</li><li>需要模拟现实世界，例如用消息去通知某个目标执行相应的操作时（事件触发）</li><li>需要一个任务处理流水线(管道)时，等等</li></ul><p>而使用共享内存(并发原语)的场景往往就比较简单粗暴：需要<strong>简洁的实现以及更高的性能</strong>。</p><h3 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h3><blockquote><p>Mutex 在之前章节已经用过，这里的介绍有点繁琐，精简了一下学习过程<br><a href="https://course.rs/advance/concurrency-with-threads/sync1.html#%E4%BA%92%E6%96%A5%E9%94%81-mutex">https://course.rs/advance/concurrency-with-threads/sync1.html#互斥锁-mutex</a></p></blockquote><p>在之前章节介绍中提到过，Mutex 是一个并发原语，它能让多个线程并发的访问同一个值变成了排队访问，同一时间只允许一个线程 A 访问该值，其它线程需要等待 A 访问完成后才能访问。</p><p>使用 Mutex 时，需要先锁定它访问数据，然后再解锁让其他线程可以访问该数据。<br>锁定和解锁的过程通常是自动的，通过 Rust 的作用域管理来实现。当 Mutex 的锁超出作用域时，它会自动释放。</p><p>不同于线程局部变量的每一个线程都有单独的数据拷贝，<strong>Mutex 用于多线程访问同一个实例</strong>，因为用于多线程，所以常常和 <strong>Arc</strong> 搭配使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutex 需要手动上锁，超过作用于后自动解锁</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>)));</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// lock 方法申请一个锁, 该方法会阻塞当前线程，直到获取到锁，因此当多个线程同时访问该数据时，只有一个线程能获取到锁</span></span><br><span class="line">        <span class="comment">// 其它线程只能阻塞着等待，这样就保证了数据能被安全的修改！</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = _mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        s.<span class="title function_ invoke__">push_str</span>(i.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_str</span>())</span><br><span class="line">        <span class="comment">// 锁自动被drop</span></span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br></pre></td></tr></table></figure><p>lock 方法申请一个锁, 该方法会阻塞当前线程，直到获取到锁，因此当多个线程同时访问该数据时，只有一个线程能获取到锁，其它线程只能阻塞着等待，这样就保证了数据能被安全的修改！<br>lock 方法也有可能报错，例如当前正在持有锁的线程 panic 了，在这种情况下，其它线程不可能再获得锁，因此 lock 方法会返回一个错误。</p><p><code>Mutex&lt;T&gt;</code> 是一个智能指针（结构体），它的方法 lock 返回另外一个智能指针（结构体） <code>MutexGuard&lt;T&gt;</code>，<code>MutexGuard&lt;T&gt;</code> 实现两个非常便捷的特征，Deref 和 Drop：</p><ul><li>Deref 特征，会被自动解引用后获得一个引用类型，该引用指向 Mutex 内部的数据</li><li>Drop 特征，在超出作用域后，自动释放锁，以便其它线程能继续获取锁</li></ul><p>使用 Mutex 时注意避免形成死锁：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 mutex 注意避免形成死锁</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 上锁</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 由于在上一行给mutex上锁了，因此这里会一直阻塞，等待获取值的所有权，但是因为 num 没有释放，所以线程一直在阻塞，这就是死锁</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_num</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br></pre></td></tr></table></figure><h4 id="小心使用-Mutex"><a href="#小心使用-Mutex" class="headerlink" title="小心使用 Mutex"></a>小心使用 Mutex</h4><ul><li>在使用数据前必须先获取锁</li><li>在数据使用完成后，必须及时的释放锁，例如增加作用域</li></ul><p>例如：当一个操作试图锁住两个资源，然后两个线程各自获取其中一个锁，并试图获取另一个锁时，就会造成死锁（deadlock）。</p><h4 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h4><p>内部可变性是指当前<strong>变量&#x2F;值的空间存储的内容发生改变</strong>的行为。</p><p>Cell 与 RefCell 的可变借用行为并不完全一致，这是由于存储的数据类型不一样决定的：<br>Cell 和 RefCell 都是智能指针，用一个栈上的新空间存储被管理的值，不同的是 Cell 存储 Copy 类型的值，而 RefCell 存储的是非 Copy 类型的栈上指针信息（通过栈上指针信息管理堆上实际数据）。</p><p><code>Rc&lt;T&gt;/RefCell&lt;T&gt;</code> 用于单线程内部可变性， <code>Arc&lt;T&gt;/Mutex&lt;T&gt;</code> 用于多线程内部可变性。</p><h3 id="死锁-deadlock"><a href="#死锁-deadlock" class="headerlink" title="死锁 deadlock"></a>死锁 deadlock</h3><p>死锁形成的根本原因是<strong>带有阻塞性访问带有锁，并且已经处于锁定中的变量</strong>，具体来看，死锁分为单线程死锁和多线程死锁。</p><h4 id="单线程死锁"><a href="#单线程死锁" class="headerlink" title="单线程死锁"></a>单线程死锁</h4><p>单线程死锁非常容易形成，只要访问当前线程中处于锁定中的变量就会形成单线程死锁。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程死锁</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 上锁</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// 由于在上一行给mutex上锁了，因此这里会一直阻塞，等待获取值的所有权，但是因为 num 没有释放，所以线程一直在阻塞，这就是死锁</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">_num</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br></pre></td></tr></table></figure><h4 id="多线程死锁"><a href="#多线程死锁" class="headerlink" title="多线程死锁"></a>多线程死锁</h4><p>多线程死锁发生在两个线程上，有两个带锁的变量，两个线程各自使用锁定其中的一个变量后，再尝试访问另外一个锁时，就可能形成死锁。<br>此时就形成了一线程访问锁定状态的 A 被阻塞，二线程访问锁定状态的 B 被阻塞。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程死锁</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex1</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex2</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_mutex1</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_mutex2</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex2);</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 锁住 mutex1 后去锁 mutex2</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num1</span> = _mutex1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 锁住 mutex1，尝试锁住 mutex2&quot;</span>, i);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num2</span> = _mutex2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 锁住 mutex2 后去锁 mutex1</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num2</span> = _mutex2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 锁住 mutex2，尝试锁住 mutex1&quot;</span>, i);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num1</span> = _mutex1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;没有发生死锁&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为何某些时候，死锁不会发生？<br>原因很简单，线程 2 在线程 1 锁 MUTEX1 之前，就已经全部执行完了，随之线程 2 的 MUTEX2 和 MUTEX1 被全部释放，线程 1 对锁的获取将不再有竞争者，也就意味着不会被一直阻塞。<br>同理，线程 1 若全部被执行完，那线程 2 也不会被锁一直阻塞，可以在线程 1 中间加一个睡眠，增加死锁发生的概率。如果在线程 2 中同样的位置也增加一个睡眠，那死锁将必然发生!</p><h4 id="try-lock"><a href="#try-lock" class="headerlink" title="try_lock"></a>try_lock</h4><p>死锁的形成是因为<strong>带有阻塞性访问带有锁，并且已经处于锁定中的变量</strong>的阻塞，如果访问时不阻塞就意味着不会形成死锁，try_lock 就是不带阻塞的方法。</p><p>与 lock 方法不同，try_lock 会尝试去获取一次锁，如果无法获取会返回一个错误。</p><blockquote><p>一个有趣的命名规则：在 Rust 标准库中，使用 try_xxx 都会尝试进行一次操作，如果无法完成，就立即返回，不会发生阻塞。<br>例如消息传递章节中的 try_recv 以及本章节中的 try_lock</p></blockquote><h3 id="读写锁-RwLock"><a href="#读写锁-RwLock" class="headerlink" title="读写锁 RwLock"></a>读写锁 RwLock</h3><p>Mutex 会对每次读写都进行加锁（即使不修改数据），但某些时候需要大量的并发读，Mutex 就无法满足需求了，此时就可以使用 RwLock。<br>RwLock 在使用上和 Mutex 区别不大，只有在多个读的情况下不阻塞程序，其他如读写、写读、写写情况下均会对后获取锁的操作进行阻塞。</p><ul><li>同一时间允许多个读，不允许出现写</li><li>同一时间只允许一个写，不允许第二个读或写<br>即不允许出现数据在读的过程中被改变。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rwlock1</span> = Arc::<span class="title function_ invoke__">new</span>(RwLock::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rwlock2</span> = Arc::<span class="title function_ invoke__">new</span>(RwLock::<span class="title function_ invoke__">new</span>(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_rwlock1</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;rwlock1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_rwlock2</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;rwlock2);</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num2</span> = _rwlock2.<span class="title function_ invoke__">write</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 读取 rwlock1，尝试写 rwlock2&quot;</span>, i);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num1</span> = _rwlock1.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num1</span> = _rwlock1.<span class="title function_ invoke__">write</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 读取 rwlock2，尝试写 rwlock1&quot;</span>, i);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">num2</span> = _rwlock2.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;没有发生死锁&quot;</span>);</span><br></pre></td></tr></table></figure><p>也可以使用 try_write 和 try_read 来尝试进行一次写&#x2F;读，若失败则返回错误。</p><p>简单总结下 RwLock:</p><ul><li>读和写不能同时存在</li><li>同一时刻允许多个读，但最多只能有一个写，且读写不能同时存在</li><li>读可以使用 read、try_read，写 write、try_write, 在实际项目中，try_xxx 会更安全</li></ul><h3 id="Mutex-和-RwLock"><a href="#Mutex-和-RwLock" class="headerlink" title="Mutex 和 RwLock"></a>Mutex 和 RwLock</h3><p>使用上，Mutex 比 RwLock 更简单，因为 RwLock 需要着重关注几个问题：</p><ul><li>读和写不能同时发生，如果使用 try_xxx 解决，需要做大量的错误处理和失败重试机制</li><li>当读多写少时，写操作可能会因为一直无法获得锁导致连续多次失败 (writer starvation)</li><li>RwLock 其实是操作系统提供的，实现原理要比 Mutex 复杂的多，因此单就锁的性能而言，比不上原生实现的 Mutex</li></ul><p><strong>Mutex 和 RwLock 的使用场景</strong></p><ul><li>追求高并发读取时，可以使用 RwLock，因为 Mutex 一次只允许一个线程读取</li><li>如果要保证写操作的成功性，使用 Mutex</li><li>不知道哪个合适，统一使用 Mutex</li></ul><p>当然，确定使用哪个锁的最好方式是做一个 benchmark。</p><p>使用 RwLock 要确保满足以下两个条件：<strong>并发读和需要对读到的资源进行”长时间”的操作</strong>。</p><p>所以一个常见的错误使用 RwLock 的场景就是使用 HashMap 进行简单读写。<br>这是因为 HashMap 的读和写都非常快，HashMap 也许满足了并发读的需求，但是往往并不能满足 “长时间” 的操作这个需求，RwLock 的复杂实现和相对低的性能反而会导致整体性能的降低。</p><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><p>标准库在设计时总会存在取舍，因为往往性能并不是最好的，如果你追求性能，可以使用三方库提供的并发原语:</p><ul><li>parking_lot, 功能更完善、稳定，社区较为活跃，star 较多，更新较为活跃</li><li>spin, 在多数场景中性能比 parking_lot 高一点，最近没怎么更新</li></ul><h3 id="条件变量控制线程同步"><a href="#条件变量控制线程同步" class="headerlink" title="条件变量控制线程同步"></a>条件变量控制线程同步</h3><p>Mutex 与 Arc 的搭配可以解决多线程下资源安全访问的问题，在这个基础上 rust 还提供了一个条件变量（Condition Variable）用于控制资源的访问顺序。</p><p>条件变量（Condition Variable）搭配 Mutex 和 Arc，可以做到控制线程执行流程，让线程挂起直至某个条件满足后再继续运行。</p><p>比如，让两个线程内部的循环交替输出相同的序号，这里先用一个条件变量和线程休眠实现一个简单版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一个条件变量和线程休眠实现一个简单版本的交替输出</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">cond</span> = Arc::<span class="title function_ invoke__">new</span>(Condvar::<span class="title function_ invoke__">new</span>());</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="literal">true</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_cond</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;cond);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock</span> = _mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">while</span> *lock == <span class="literal">false</span> &#123;</span><br><span class="line">            lock = _cond.<span class="title function_ invoke__">wait</span>(lock).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 阻塞线程，等待条件变量的通知后继续运行，并将最新的值赋值给锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *lock = <span class="literal">false</span>; <span class="comment">// 重置条件，重新进入阻塞等待条件变量的调度</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;inner index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="comment">// 用线程休眠模拟另外一个条件，阻塞当前运行，然后恢复继续运行</span></span><br><span class="line">    <span class="comment">// 这里先休眠是为了让子线程进入条件阻塞状态</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;outer index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">    <span class="comment">// println!(&quot;outer index = &#123;&#125;&quot;, i); 调整输出位置，可以观察到交替顺序变换</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    cond.<span class="title function_ invoke__">notify_one</span>(); <span class="comment">// 通知另外一个线程可以继续运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p>一个条件变量的版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个互斥锁和条件变量对，用于线程间的同步</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pair1</span> = Arc::<span class="title function_ invoke__">new</span>((Mutex::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>), Condvar::<span class="title function_ invoke__">new</span>()));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pair2</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;pair1);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> (lock, cvar) = &amp;*pair2;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">started</span> = lock.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">while</span> !*started &#123;</span><br><span class="line">            <span class="comment">// 等待主线程的通知</span></span><br><span class="line">            started = cvar.<span class="title function_ invoke__">wait</span>(started).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;inner index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">        *started = <span class="literal">false</span>; <span class="comment">// 重置条件</span></span><br><span class="line">        cvar.<span class="title function_ invoke__">notify_one</span>(); <span class="comment">// 通知主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> (lock, cvar) = &amp;*pair1;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">started</span> = lock.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    *started = <span class="literal">true</span>; <span class="comment">// 设置条件</span></span><br><span class="line">    cvar.<span class="title function_ invoke__">notify_one</span>(); <span class="comment">// 通知子线程，需要放在条件变量阻塞之前，否则会造成死锁</span></span><br><span class="line">    <span class="keyword">while</span> *started &#123;</span><br><span class="line">        <span class="comment">// 等待子线程通知</span></span><br><span class="line">        started = cvar.<span class="title function_ invoke__">wait</span>(started).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;outer index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 等待子线程完成</span></span><br></pre></td></tr></table></figure><h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h3><p>在多线程中，另一个重要的概念就是信号量，使用它可以让我们精准的控制当前正在运行的任务最大数量。信号量可以看成一个池，如常见的线程池、连接池等。</p><p>想象一下，当一个新游戏刚开服时，往往会控制游戏内玩家的同时在线数，一旦超过某个临界值，就开始进行排队进服。<br>而在实际使用中，有很多时候需要通过信号量来控制最大并发数，防止服务器资源被撑爆。</p><p>本来 Rust 在标准库中有提供一个信号量实现, 但是由于各种原因这个库现在已经不再推荐使用了，推荐使用 tokio 中提供的 Semaphore 实现 tokio::sync::Semaphore。</p><p>这里先认识 <code>async move &#123;&#125;</code> 和 <code>async move || &#123;&#125;</code> 的区别：</p><ul><li><code>async move &#123;&#125;</code>：直接定义一个异步块，立即捕获环境变量并生成 Future，适用于需要单次执行的异步操作。</li><li><code>async move || &#123;&#125;</code>：定义一个异步闭包，每次调用该闭包时生成一个新的 Future，并捕获当前调用环境中的变量,适用于需要多次调用的异步函数。</li></ul><p>选择哪种形式取决于具体需求以及代码的应用场景。如果需要创建可复用的异步函数，async move || {} 更合适；如果只需要一次性执行的异步逻辑，async move {} 会更简洁。</p><blockquote><p>Future 是一个核心概念，用于表示一个异步操作的结果，它可能在将来某个时刻完成。Future 可以被视为一种承诺（promise），它将在未来某个时间点提供一个值或错误。<br>当编写异步代码时，如果希望某些操作能够在不阻塞当前线程的情况下执行，并且在这些操作完成后获得其结果。Future 提供了一种机制，可以描述这些异步操作，并在它们完成时得到通知。</p><p>这个概念和 JavaScript 的 Promise 非常相似，表示一个将来可能会产生结果的异步操作，优点：</p><ul><li>非阻塞：Future 允许异步代码在不阻塞线程的情况下执行，使得应用程序可以处理更多并发任务</li><li>组合性：可以通过组合多个 Future 来构建复杂的异步控制流</li><li>可读性：使用 async&#x2F;await 语法，使得异步代码看起来像同步代码，更加易读和易维护</li></ul></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">semaphore</span> = Arc::<span class="title function_ invoke__">new</span>(Semaphore::<span class="title function_ invoke__">new</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="comment">// acquire_owned 申请许可，申请通过则线程运行，否则线程被阻塞，直至获得许可后才会解除阻塞继续运行</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_semaphore</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;semaphore);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 未获取 permit 许可&quot;</span>, i);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">permit</span> = _semaphore.<span class="title function_ invoke__">acquire</span>().<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 已获取 permit 许可&quot;</span>, i);</span><br><span class="line">            tokio::time::<span class="title function_ invoke__">sleep</span>(tokio::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>)).<span class="keyword">await</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 运行结束&quot;</span>, i);</span><br><span class="line">            <span class="comment">// drop(permit); 在离开作用域时自动释放</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用信号量过程中需要申请和归还，使用前需要申请信号量，如果容量满了，就需要等待；使用后需要释放信号量，以便其它等待者可以继续。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在很多时候消息传递都是优雅解决并发问题的方式，但是它也并不能优雅的解决所有问题，因为面临的真实世界是非常复杂的，无法用某一种银弹统一解决。<br>当面临消息传递不太适用的场景时，或者需要更好的性能和简洁性时，往往需要用锁来解决这些问题，因为锁允许多个线程同时访问同一个资源，简单粗暴。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="comment">// lock 方法申请一个锁, 该方法会阻塞当前线程，直到获取到锁，因此当多个线程同时访问该数据时，只有一个线程能获取到锁</span></span><br><span class="line">            <span class="comment">// 其它线程只能阻塞着等待，这样就保证了数据能被安全的修改！</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span>: std::sync::MutexGuard&lt;<span class="type">String</span>&gt; = _mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            s.<span class="title function_ invoke__">push_str</span>(i.<span class="title function_ invoke__">to_string</span>().<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">            <span class="comment">// 锁自动被drop</span></span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 mutex 注意避免形成死锁</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 上锁</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 由于在上一行给mutex上锁了，因此这里会一直阻塞，等待获取值的所有权，但是因为 num 没有释放，所以线程一直在阻塞，这就是死锁</span></span><br><span class="line">        <span class="comment">// let _num = mutex.lock().unwrap();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单线程死锁</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 上锁</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 由于在上一行给mutex上锁了，因此这里会一直阻塞，等待获取值的所有权，但是因为 num 没有释放，所以线程一直在阻塞，这就是死锁</span></span><br><span class="line">    <span class="comment">// let _num = mutex.lock().unwrap();</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多线程死锁</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex1</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex2</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_mutex1</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex1);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_mutex2</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex2);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 锁住 mutex1 后去锁 mutex2</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num1</span> = _mutex1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 锁住 mutex1，尝试锁住 mutex2&quot;</span>, i);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num2</span> = _mutex2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 锁住 mutex2 后去锁 mutex1</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num2</span> = _mutex2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 锁住 mutex2，尝试锁住 mutex1&quot;</span>, i);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num1</span> = _mutex1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// println!(&quot;没有发生死锁&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// try_lock 不阻塞的方法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex1</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex2</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_mutex1</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex1);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_mutex2</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex2);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 锁住 mutex1 后去锁 mutex2</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num1</span> = _mutex1.<span class="title function_ invoke__">try_lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 锁住 mutex1，尝试锁住 mutex2&quot;</span>, i);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num2</span> = _mutex2.<span class="title function_ invoke__">try_lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 锁住 mutex2 后去锁 mutex1</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num2</span> = _mutex2.<span class="title function_ invoke__">try_lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 锁住 mutex2，尝试锁住 mutex1&quot;</span>, i);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num1</span> = _mutex1.<span class="title function_ invoke__">try_lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;没有发生死锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RwLock 读写锁支持并发读</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rwlock1</span> = Arc::<span class="title function_ invoke__">new</span>(RwLock::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rwlock2</span> = Arc::<span class="title function_ invoke__">new</span>(RwLock::<span class="title function_ invoke__">new</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_rwlock1</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;rwlock1);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_rwlock2</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;rwlock2);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num2</span> = _rwlock2.<span class="title function_ invoke__">write</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 读取 rwlock1，尝试写 rwlock2&quot;</span>, i);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num1</span> = _rwlock1.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num1</span> = _rwlock1.<span class="title function_ invoke__">write</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 读取 rwlock2，尝试写 rwlock1&quot;</span>, i);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">num2</span> = _rwlock2.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;没有发生死锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个条件变量和线程休眠实现一个简单版本的交替输出</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cond</span> = Arc::<span class="title function_ invoke__">new</span>(Condvar::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="literal">true</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_cond</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;cond);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock</span> = _mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">            <span class="keyword">while</span> *lock == <span class="literal">false</span> &#123;</span><br><span class="line">                lock = _cond.<span class="title function_ invoke__">wait</span>(lock).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 阻塞线程，等待条件变量的通知后继续运行，并将最新的值赋值给锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            *lock = <span class="literal">false</span>; <span class="comment">// 重置条件，重新进入阻塞等待条件变量的调度</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;inner index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="comment">// 用线程休眠模拟另外一个条件，阻塞当前运行，然后恢复继续运行</span></span><br><span class="line">        <span class="comment">// 这里先休眠是为了让子线程进入条件阻塞状态</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;outer index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">        <span class="comment">// println!(&quot;outer index = &#123;&#125;&quot;, i); 调整输出位置，可以观察到交替顺序变换</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *lock = <span class="literal">true</span>;</span><br><span class="line">        cond.<span class="title function_ invoke__">notify_one</span>(); <span class="comment">// 通知另外一个线程可以继续运行</span></span><br><span class="line">    &#125;</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个互斥锁和条件变量对，用于线程间的同步</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair1</span> = Arc::<span class="title function_ invoke__">new</span>((Mutex::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>), Condvar::<span class="title function_ invoke__">new</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair2</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;pair1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> (lock, cvar) = &amp;*pair2;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">started</span> = lock.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">while</span> !*started &#123;</span><br><span class="line">                <span class="comment">// 等待主线程的通知</span></span><br><span class="line">                started = cvar.<span class="title function_ invoke__">wait</span>(started).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;inner index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">            *started = <span class="literal">false</span>; <span class="comment">// 重置条件</span></span><br><span class="line">            cvar.<span class="title function_ invoke__">notify_one</span>(); <span class="comment">// 通知主线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> (lock, cvar) = &amp;*pair1;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">started</span> = lock.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *started = <span class="literal">true</span>; <span class="comment">// 设置条件</span></span><br><span class="line">        cvar.<span class="title function_ invoke__">notify_one</span>(); <span class="comment">// 通知子线程，需要放在条件变量阻塞之前，否则会造成死锁</span></span><br><span class="line">        <span class="keyword">while</span> *started &#123;</span><br><span class="line">            <span class="comment">// 等待子线程通知</span></span><br><span class="line">            started = cvar.<span class="title function_ invoke__">wait</span>(started).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;outer index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 等待子线程完成</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// tokio 的信号量，可以视为连接池，通过 acquire_owned 申请许可，申请通过则线程运行，否则线程被阻塞，直至获得许可后才会解除阻塞继续运行。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">semaphore</span> = Arc::<span class="title function_ invoke__">new</span>(Semaphore::<span class="title function_ invoke__">new</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="comment">// acquire_owned 申请许可，申请通过则线程运行，否则线程被阻塞，直至获得许可后才会解除阻塞继续运行</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_semaphore</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;semaphore);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 未获取 permit 许可&quot;</span>, i);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">permit</span> = _semaphore.<span class="title function_ invoke__">acquire</span>().<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 已获取 permit 许可&quot;</span>, i);</span><br><span class="line">            tokio::time::<span class="title function_ invoke__">sleep</span>(tokio::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>)).<span class="keyword">await</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; 运行结束&quot;</span>, i);</span><br><span class="line">            <span class="comment">// drop(permit); 在离开作用域时自动释放</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 线程同步：消息传递</title>
      <link href="/2024/06/18/rust-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/"/>
      <url>/2024/06/18/rust-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h2 id="线程同步：消息传递"><a href="#线程同步：消息传递" class="headerlink" title="线程同步：消息传递"></a>线程同步：消息传递</h2><blockquote><p>注意：在 rust 线程中借用外部的引用必须拥有 <code>&#39;static</code> 生命周期。</p></blockquote><p>在多线程间有多种方式可以共享和传递数据，最常用有两种：</p><ul><li>消息传递</li><li>锁和 Arc 联合使用</li></ul><p>对于消息传递，在编程界有一个大名鼎鼎的 <strong>Actor 线程模型</strong>为其背书，典型的有 Erlang 语言，还有 Go 语言。</p><blockquote><p>在 Go 语言中有一句很经典的话：<br>Do not communicate by sharing memory; instead, share memory by communicating<br>不要通过共享内存来进行通信，而是通过通信来共享内存</p><p>简单理解：尽量避免访问同一块内存空间来通信，因为它会造成的并发问题如竞争条件（Race condition），死锁（Deadlocks）等。<br>而是应该通过消息通知（触发）进行数据传递，例如消息队列、Socket 等方法。不同进程或线程之间通过这些通信机制共享数据，避免共享内存造成的并发问题。</p></blockquote><p>与 Go 语言直接内置 chan 关键字不同，rust 通过标准库的 <code>channel</code> 提供消息通道。</p><p>消息常常被视为信息的反映形式之一，是信息的外壳。但消息&#x2F;信息没有个统一认可的定义。在香浓的《通信数学理论》中，他认为：<br>从通信角度看，信息是通信的内容。通信的目的就是要减少或消除接收端(信宿)对于发出端(信源)可能会发出哪些消息的不确定性。<br>所谓不确定性，就是指人们对客观事物的不了解或不清楚程度。<br>人们通过某种方式或手段，获取了新的情况或知识，就可从对客观事物的不清楚变为较清楚或完全清楚，不确定性也就减少或消除了。<br>这种使人们减少或消除不确定性的东西就是信息。</p><p>简单理解，消息是发送者发信息给接收者的音讯，它更多的是指一个音讯整体，包含发送者和接收者。<br>消息通过消息通道进行传播，一个消息通道可以传播多个消息，因此消息通道应该支持多个发送者和接收者。</p><p>在实际使用中，需要使用不同的库来满足诸如：<code>多发送者 -&gt; 单接收者</code>，<code>多发送者 -&gt; 多接收者</code> 等场景形式。</p><blockquote><p>消息管道一般不区分单发送者和多发送者，因为支持多发送者就是支持单发送者。</p><ol><li>在实际应用中，通常需要多个发送者向同一个接收者发送消息，单发送者的场景相对较少。</li><li>多发送者形式更加灵活和通用，能满足单个发送者功能。</li><li>从设计的角度来看，多发送者形式更加符合消息管道的本质。消息管道的目的是将消息从发送者传递到接收者，而不管发送者和接收者的数量。</li></ol></blockquote><p>当发送者或接收者任一被丢弃时可以认为通道被关闭（closed）了。</p><h3 id="多发送者，单接收者"><a href="#多发送者，单接收者" class="headerlink" title="多发送者，单接收者"></a>多发送者，单接收者</h3><p>标准库提供了通道 <code>std::sync::mpsc</code>，其中 <code>mpsc</code> 是 <code>multiple producer, single consumer</code> 的缩写，代表了该通道支持多个发送者，但是只支持唯一的接收者。<br>当然，支持多个发送者也意味着支持单个发送者。</p><p>在实际使用过程中，发送者 <code>transmitter</code> 常被简写为 <code>tx</code>，接收者 <code>receiver</code> 被简写为 <code>rx</code>。</p><p><strong>单发送者，单接收者</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  创建消息通道，返回发送者、接收者元组（transmitter，receiver）</span></span><br><span class="line"><span class="comment">// let (tx, rx) = mpsc::channel::&lt;i32&gt;(); // 手动指定消息通道类型</span></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>(); <span class="comment">// 可以手动指定类型，也可以由编译器推导类型，如果编译器没有推导出类型，则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 编译器自动推导出类型，发送者为 Sender&lt;i32&gt;，接收者为 Receiver&lt;i32&gt;，后续管道无法发送其他类型</span></span><br><span class="line">                         <span class="comment">// send 方法返回 Result，说明它有可能返回一个错误，例如接收者被 drop 导致了发送的值不会被任何人接收，此时继续发送毫无意义，因此返回一个错误最为合适</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// tx.send(Some(1)); 错误，经过 `tx.send(1)` 后管道被推导为只能传送 i32 类型</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// recv 方法会阻塞当前线程，直到读取到值或者通道被关闭才会解除阻塞</span></span><br></pre></td></tr></table></figure><p>以上代码并不复杂，但仍有几点需要注意：</p><ul><li>tx,rx 对应发送者和接收者，它们的类型由编译器自动推导: 因为 tx.send(1) 发送了整数，所以编译器推导它们分别是 <code>mpsc::Sender&lt;i32&gt;</code> 和 <code>mpsc::Receiver&lt;i32&gt;</code> 类型</li><li>由于通道内部是泛型实现，一旦类型被推导确定，该通道就只能传递对应类型的值，否则会导致类型错误。</li><li>接收消息的操作 rx.recv() 会阻塞当前线程，直到读取到值，或者通道被关闭</li><li>需要使用 move 将 tx 的所有权转移到子线程的闭包中</li></ul><p>send 方法返回一个 <code>Result&lt;T,E&gt;</code>，说明它有可能返回一个错误，例如接收者被 drop 导致<strong>发送的值不会被任何人接收</strong>，此时继续发送毫无意义，因此返回一个错误最为合适。<br>同样的，对于 recv 方法来说，当发送者关闭时，它也会接收到一个错误，用于说明<strong>不会再有任何值被发送过来</strong>。</p><h3 id="不阻塞的-try-recv"><a href="#不阻塞的-try-recv" class="headerlink" title="不阻塞的 try_recv"></a>不阻塞的 try_recv</h3><p>recv 方法在通道中没有消息时会阻塞当前线程，如果不希望阻塞线程，可以使用 try_recv，try_recv 会尝试接收一次消息，如果通道中没有消息，会立刻返回一个错误。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try_recv 会立即尝试接收一次消息，如果通道中没有消息则会返回一个错误</span></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">match</span> rx.<span class="title function_ invoke__">try_recv</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;n&#125;&quot;</span>),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e), <span class="comment">// 在子线程未创建前，通道中没有信息，try_recv 返回 empty channel 错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> rx.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;n&#125;&quot;</span>),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e), <span class="comment">// 利用 recv 阻塞，区分两种类型的错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> rx.<span class="title function_ invoke__">try_recv</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;n&#125;&quot;</span>),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e), <span class="comment">// 在子线程结束后，通道被关闭，try_recv 返回 closed channel 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于子线程的创建需要时间，第一个 <code>match rx.try_recv</code> 执行时子线程的消息还未发出。因为消息没有发出，try_recv 在立即尝试读取一次消息后就会报错，返回 empty channel 错误。<br>当子线程创建成功且发送消息后，主线程会接收到 Ok(1) 的消息内容，紧接着子线程结束，发送者也随着被 drop，此时接收者又会报错，但是这次错误原因有所不同：closed channel 代表发送者已经被关闭。</p><h3 id="传输数据的所有权"><a href="#传输数据的所有权" class="headerlink" title="传输数据的所有权"></a>传输数据的所有权</h3><p>使用通道来传输数据，一样要遵循 Rust 的所有权规则：</p><ul><li>若值的类型实现了 Copy 特征，则直接复制一份该值，然后传输</li><li>若值没有实现 Copy 特征，则它的所有权会被<strong>转移给接收端</strong>，在发送端继续使用该值将报错</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息管理会转移非 Copy 类型的所有权</span></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(s);</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;s&#125;&quot;); 不能再使用s，s的所有权被转移</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br></pre></td></tr></table></figure><p>假如没有所有权的保护，String 字符串将被两个线程同时持有，任何一个线程对字符串内容的修改都会导致另外一个线程持有的字符串被改变，除非故意这么设计，否则这就是不安全的隐患。</p><h3 id="循环接收消息"><a href="#循环接收消息" class="headerlink" title="循环接收消息"></a>循环接收消息</h3><p>消息通道中的消息数量是不确定的，为了方便接收所有消息以及在通道关闭时自动停止接收者接收消息，rust 为接收者 Receiver 实现了可迭代特征协议(IntoIterator)。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Iterator</span> <span class="keyword">for</span> <span class="title class_">IntoIter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">ok</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">IntoIterator</span> <span class="keyword">for</span> <span class="title class_">Receiver</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = T;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">IntoIter</span> = IntoIter&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">into_iter</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> IntoIter&lt;T&gt; &#123;</span><br><span class="line">        IntoIter &#123; rx: <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rx.recv()</code> 阻塞当前线程直到发送者或通道关闭，结合迭代器说明可以对 <code>rx</code> 进行循环操作，即可取出通道内的所有消息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Receiver 接收者实现了可迭代特征，可以使用 for 遍历 Receiver 接收者</span></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msgs</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Test&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World&quot;</span>),</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> msgs &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 消费了一条消息，消息通道内减少一条</span></span><br><span class="line"><span class="keyword">match</span> rx.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(msg) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;msg&#125;&quot;</span>),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;e&#125;&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 for 遍历 Receiver 接收者，即可取出通道内的消息</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;msg&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mpsc-的多发送者"><a href="#mpsc-的多发送者" class="headerlink" title="mpsc 的多发送者"></a>mpsc 的多发送者</h3><p>发送者 Sender 和 Arc 一样实现了 Send 特征，可以在多线程中共享数据。</p><p>使用多发送者时，和在多线程中使用 Arc 一样，复制一份引用即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用多发送者，Sender 和 Arc 一样实现了 Send 特征，可以在多线程中共享数据</span></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="comment">// Sender 和 Arc 一样实现了 Send 特征，可以在多线程中共享数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_tx</span> = Sender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        _tx.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有所有发送者释放后，消息通道才会因为没有发送者而关闭，进而释放 rx，这里需要在阻塞线程前主动释放 tx</span></span><br><span class="line"><span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line"><span class="comment">// 使用 for 遍历 Receiver 接收者，即可取出通道内的消息，</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几点需要注意:</p><ul><li>需要所有的发送者都被 drop 掉后，接收者 rx 才会收到错误，进而跳出 for 循环，最终结束主线程，因此要提前销毁 tx</li><li>由于子线程谁先创建完成是未知的，因此哪条消息先发送也是未知的，最终主线程消息的<strong>输出顺序也不确定</strong></li></ul><h3 id="同步和异步通道"><a href="#同步和异步通道" class="headerlink" title="同步和异步通道"></a>同步和异步通道</h3><p>Rust 标准库的 mpsc 通道其实分为两种类型：同步和异步。</p><h4 id="异步通道"><a href="#异步通道" class="headerlink" title="异步通道"></a>异步通道</h4><p>异步：发送操作不会阻塞当前线程，无论消息是否被接收，继续执行当前线程。即无论接收者是否正在接收消息，消息发送者在发送消息时都不会阻塞。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mpsc::channel 是一个异步管道，发送操作不会阻塞当前线程</span></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="comment">// Sender 和 Arc 一样实现了 Send 特征，可以在多线程中共享数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_tx</span> = Sender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;发送之前&quot;</span>);</span><br><span class="line">        _tx.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 发送操作不会阻塞当前线程</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;发送之后&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主线程阻塞，还未开始接收消息，但是子线程中发送操作正常运行</span></span><br><span class="line">thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 只有所有发送者释放后，消息通道才会因为没有发送者而关闭，进而释放 rx，这里需要在阻塞线程前主动释放 tx</span></span><br><span class="line"><span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line"><span class="comment">// 使用 for 遍历 Receiver 接收者，即可取出通道内的消息，</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程因为睡眠阻塞了 2 秒，并没有进行消息接收，而子线程却在此期间轻松完成了消息的发送。发送之前和发送之后是连续输出的，没有受到接收端主线程的任何影响，<br>等睡眠结束后，主线程才姗姗来迟的从通道中接收了子线程老早之前发送的消息。因此通过 <code>mpsc::channel</code> 创建的通道是<strong>异步通道</strong>。</p><h4 id="同步通道"><a href="#同步通道" class="headerlink" title="同步通道"></a>同步通道</h4><p>与异步通道相反，同步通道的发送者<strong>发送操作是可以阻塞当前线程的</strong>，只有等发送者发出的消息被接收后，发送者所在的线程才会解除阻塞并继续执行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mpsc::sync_channel 是一个同步通道，发送操作可以阻塞当前线程，只有等发出的消息被接收后，发送者所在的线程才会解除阻塞并继续执行</span></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_tx</span> = SyncSender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;同步通道，发送之前，idx = &#123;i&#125;&quot;</span>);</span><br><span class="line">        _tx.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 只有等消息被接收后才会解除阻塞，让当前线程继续执行</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;同步通道，发送之后，idx = &#123;i&#125;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主线程阻塞，还未开始接收消息，各个子线程发送操作阻塞当前线程，只有等主线程接收消息后，各线程才会依次解除阻塞继续运行</span></span><br><span class="line">thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line"><span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;同步通道，接收消息，idx = &#123;&#125;&quot;</span>, msg); <span class="comment">// 与“发送之后”的输出顺序是不确定的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同步通道中，当发送者发出消息时，只有等发出的<strong>消息被接收</strong>后，发送者所在的线程才会解除阻塞并继续执行。</p><h4 id="消息缓存"><a href="#消息缓存" class="headerlink" title="消息缓存"></a>消息缓存</h4><p>同步通道可以指定<strong>通道长度，即同步通道的消息缓存条数</strong>。</p><p>当设定为 N 时，发送者可以<strong>无阻塞</strong>的往通道中发送 N 条消息。<br>当消息缓冲队列满了后，新的消息发送将被阻塞(如果没有接收者消费缓冲队列中的消息，那么从第 N+1 条消息开始将触发发送阻塞)。</p><p>在同步通道中，在生成通道时指定通道长度：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定通道长度，在生成通道时指定通道长度</span></span><br><span class="line"><span class="comment">// 当设定为 N 时，发送者可以**无阻塞**的往通道中发送 N 条消息。</span></span><br><span class="line"><span class="comment">// 当消息缓冲队列满了后，新的消息发送将被阻塞(如果没有接收者消费缓冲队列中的消息，那么从第 N+1 条消息开始将触发发送阻塞)。</span></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_tx</span> = SyncSender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;前，idx = &#123;i&#125;&quot;</span>);</span><br><span class="line">        _tx.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 在消息通道还没满时，可以无阻塞的发送消息。当通道满了之后，发送操作阻塞当前线程</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;后，idx = &#123;i&#125;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主线程阻塞，还未开始接收消息，各个子线程发送操作阻塞当前线程，只有等主线程接收消息后，各线程才会依次解除阻塞继续运行</span></span><br><span class="line"><span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;接收，idx = &#123;&#125;&quot;</span>, msg); <span class="comment">// 与“发送之后”的输出顺序是不确定的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步通道没有这个缓冲值参数 mpsc::channel()，事实上异步通道的缓冲上限取决于内存大小。</p><p>虽然异步消息非常高效不会造成发送线程的阻塞，但是存在消息未及时消费，最终内存过大的问题。<br>因此，在实际项目中，可以考虑使用一个<strong>带缓冲值的同步通道</strong>来避免这种风险。</p><h4 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h4><p>所有发送者被 drop 或者所有接收者被 drop 后，引用计数归 0，rust 根据发送者和接收者实现的 Drop 特征<strong>自动关闭通道</strong>。<br>这种设计平衡了性能和灵活性，维护开销非常低并且是在线程安全的基础上进行的。</p><h4 id="传输多种类型的数据"><a href="#传输多种类型的数据" class="headerlink" title="传输多种类型的数据"></a>传输多种类型的数据</h4><p><strong>一个消息通道只能传输一种类型的数据</strong>，如果需要传输多种类型的数据，可以为每个类型创建一个通道，或者使用枚举类型来实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **一个消息通道只能传输一种类型的数据**，如果需要传输多种类型的数据，可以为每个类型创建一个通道，或者使用枚举类型来实现：</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Apple</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Orange</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_tx</span> = SyncSender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">3</span> &#123;</span><br><span class="line">            _tx.<span class="title function_ invoke__">send</span>(Fruit::<span class="title function_ invoke__">Apple</span>(i <span class="keyword">as</span> <span class="type">u8</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _tx.<span class="title function_ invoke__">send</span>(Fruit::<span class="title function_ invoke__">Orange</span>(i.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点需要注意，Rust 会按照枚举中占用内存最大的那个成员进行内存对齐，这意味着即使传输枚举中占用内存最小的成员，它占用的内存依然和最大的成员相同, 因此会造成内存上的浪费。</p><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><p>在以上使用循环生成线程、发送消息的代码中，都会在调用接收者之前手动释放发送者的一个引用。<br>如果去掉手动释放这个引用的过程，会发现运行后主线程会一直阻塞，最后一行打印输出也不会被执行。<br>原因在于：子线程拿走的是复制后 send 的所有权，这些拷贝会在子线程结束后被 drop，因此无需担心，但是 send 本身要到 main 函数的结束才会被 drop。</p><p>mpsc 通道关闭的两种方式：发送者全部 drop 或接收者被 drop，要结束 for 循环显然是要求发送者全部 drop，但是由于 send 自身没有被 drop，会导致该循环永远无法结束，最终主线程会一直阻塞。</p><h3 id="更好的性能"><a href="#更好的性能" class="headerlink" title="更好的性能"></a>更好的性能</h3><p>如果需要 mpmc(多发送者，多接收者)或者需要更高的性能，可以考虑第三方库:</p><ul><li>crossbeam-channel, 老牌强库，功能较全，性能较强，之前是独立的库，但是后面合并到了 crossbeam 主仓库中</li><li>flume, 官方给出的性能数据某些场景要比 crossbeam 更好些</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//  创建消息通道，返回发送者、接收者元组（transmitter，receiver）</span></span><br><span class="line">    <span class="comment">// let (tx, rx) = mpsc::channel::&lt;i32&gt;(); // 手动指定消息通道类型</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>(); <span class="comment">// 可以手动指定类型，也可以由编译器推导类型，如果编译器没有推导出类型，则会报错</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 编译器自动推导出类型，发送者为 Sender&lt;i32&gt;，接收者为 Receiver&lt;i32&gt;，后续管道无法发送其他类型</span></span><br><span class="line">                             <span class="comment">// send 方法返回 Result，说明它有可能返回一个错误，例如接收者被 drop 导致了发送的值不会被任何人接收，此时继续发送毫无意义，因此返回一个错误最为合适</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// tx.send(Some(1)); 错误，经过 `tx.send(1)` 后管道被推导为只能传送 i32 类型</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try_recv 会立即尝试接收一次消息，如果通道中没有消息则会返回一个错误</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">match</span> rx.<span class="title function_ invoke__">try_recv</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;n&#125;&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e), <span class="comment">// 在子线程未创建前，通道中没有信息，try_recv 返回 empty channel 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> rx.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;n&#125;&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e), <span class="comment">// 利用 recv 阻塞，区分两种类型的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> rx.<span class="title function_ invoke__">try_recv</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;n&#125;&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;&#125;&quot;</span>, e), <span class="comment">// 在子线程结束后，通道被关闭，try_recv 返回 closed channel 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息管理会转移非 Copy 类型的所有权</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(s);</span><br><span class="line">        <span class="comment">// println!(&quot;&#123;s&#125;&quot;); 不能再使用s，s的所有权被转移</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Receiver 接收者实现了可迭代特征，可以使用 for 遍历 Receiver 接收者</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msgs</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Test&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> msgs &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 消费了一条消息，消息通道内减少一条</span></span><br><span class="line">    <span class="keyword">match</span> rx.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(msg) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;msg&#125;&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;&#123;e&#125;&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 for 遍历 Receiver 接收者，即可取出通道内的消息</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;msg&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用多发送者，Sender 和 Arc 一样实现了 Send 特征，可以在多线程中共享数据</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="comment">// Sender 和 Arc 一样实现了 Send 特征，可以在多线程中共享数据</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_tx</span> = Sender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            _tx.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有所有发送者释放后，消息通道才会因为没有发送者而关闭，进而释放 rx，这里需要在阻塞线程前主动释放 tx</span></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line">    <span class="comment">// 使用 for 遍历 Receiver 接收者，即可取出通道内的消息，</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mpsc::channel 是一个异步管道，发送操作不会阻塞当前线程</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="comment">// Sender 和 Arc 一样实现了 Send 特征，可以在多线程中共享数据</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_tx</span> = Sender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;发送之前&quot;</span>);</span><br><span class="line">            _tx.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 发送操作不会阻塞当前线程</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;发送之后&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主线程阻塞，还未开始接收消息，但是子线程中发送操作正常运行</span></span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 只有所有发送者释放后，消息通道才会因为没有发送者而关闭，进而释放 rx，这里需要在阻塞线程前主动释放 tx</span></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line">    <span class="comment">// 使用 for 遍历 Receiver 接收者，即可取出通道内的消息，</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mpsc::sync_channel 是一个同步通道，发送操作可以阻塞当前线程，只有等发出的消息被接收后，发送者所在的线程才会解除阻塞并继续执行</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_tx</span> = SyncSender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;同步通道，发送之前，idx = &#123;i&#125;&quot;</span>);</span><br><span class="line">            _tx.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 只有等消息被接收后才会解除阻塞，让当前线程继续执行</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;同步通道，发送之后，idx = &#123;i&#125;&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主线程阻塞，还未开始接收消息，各个子线程发送操作阻塞当前线程，只有等主线程接收消息后，各线程才会依次解除阻塞继续运行</span></span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;同步通道，接收消息，idx = &#123;&#125;&quot;</span>, msg); <span class="comment">// 与“发送之后”的输出顺序是不确定的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;=====================================================&quot;</span>);</span><br><span class="line">    <span class="comment">// 指定通道长度，在生成通道时指定通道长度</span></span><br><span class="line">    <span class="comment">// 当设定为 N 时，发送者可以**无阻塞**的往通道中发送 N 条消息。</span></span><br><span class="line">    <span class="comment">// 当消息缓冲队列满了后，新的消息发送将被阻塞(如果没有接收者消费缓冲队列中的消息，那么从第 N+1 条消息开始将触发发送阻塞)。</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_tx</span> = SyncSender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;前，idx = &#123;i&#125;&quot;</span>);</span><br><span class="line">            _tx.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 在消息通道还没满时，可以无阻塞的发送消息。当通道满了之后，发送操作阻塞当前线程</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;后，idx = &#123;i&#125;&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主线程阻塞，还未开始接收消息，各个子线程发送操作阻塞当前线程，只有等主线程接收消息后，各线程才会依次解除阻塞继续运行</span></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;接收，idx = &#123;&#125;&quot;</span>, msg); <span class="comment">// 与“发送之后”的输出顺序是不确定的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// **一个消息通道只能传输一种类型的数据**，如果需要传输多种类型的数据，可以为每个类型创建一个通道，或者使用枚举类型来实现</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Apple</span>(<span class="type">u8</span>),</span><br><span class="line">        <span class="title function_ invoke__">Orange</span>(<span class="type">String</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_tx</span> = SyncSender::<span class="title function_ invoke__">clone</span>(&amp;tx);</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">3</span> &#123;</span><br><span class="line">                _tx.<span class="title function_ invoke__">send</span>(Fruit::<span class="title function_ invoke__">Apple</span>(i <span class="keyword">as</span> <span class="type">u8</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _tx.<span class="title function_ invoke__">send</span>(Fruit::<span class="title function_ invoke__">Orange</span>(i.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(tx);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 使用多线程</title>
      <link href="/2024/06/13/rust-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/06/13/rust-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h2><h3 id="多线程编程的风险"><a href="#多线程编程的风险" class="headerlink" title="多线程编程的风险"></a>多线程编程的风险</h3><p>由于多线程的代码是同时运行的，所以无法保证线程间的执行顺序，这会导致一些问题：</p><ul><li>竞态条件(race conditions)，多个线程以非一致性的顺序同时访问数据资源</li><li>死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行</li><li>一些因为多线程导致的很隐晦的 BUG，难以复现和解决</li></ul><p>注意：在 rust 线程中借用外部的引用必须拥有 <code>&#39;static</code> 生命周期。</p><h3 id="spawn-创建线程"><a href="#spawn-创建线程" class="headerlink" title="spawn 创建线程"></a>spawn 创建线程</h3><p>使用 thread::spawn 可以创建线程，它与主线程的执行顺序和次数依赖操作系统如何调度线程，总之，<strong>千万不要依赖线程的执行顺序</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;spawned thread, index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;main thread, index = &#123;&#125;&quot;</span>, j);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>)); <span class="comment">// thread::sleep() 可以强制线程停止执行一段时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几点值得注意：</p><ul><li>线程内部的代码使用<strong>闭包</strong>来执行</li><li>main 线程一旦结束，程序就立刻结束，如果其它子线程需要完成自己的任务，就需要保证主线程的存活</li><li>thread::sleep 会让当前线程休眠指定的时间，随后其它线程会被调度运行，如果是在单核心处理上，那就会形成并发</li></ul><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main thread, index = 1</span><br><span class="line">spawned thread, index = 1</span><br><span class="line">spawned thread, index = 2</span><br><span class="line">spawned thread, index = 3</span><br><span class="line">spawned thread, index = 4</span><br><span class="line">spawned thread, index = 5</span><br><span class="line">spawned thread, index = 6</span><br><span class="line">main thread, index = 2</span><br><span class="line">spawned thread, index = 7</span><br><span class="line">spawned thread, index = 8</span><br><span class="line">main thread, index = 3</span><br><span class="line">main thread, index = 4</span><br></pre></td></tr></table></figure><h3 id="线程的结束方式"><a href="#线程的结束方式" class="headerlink" title="线程的结束方式"></a>线程的结束方式</h3><p>main 线程是程序的主线程，一旦结束则程序随之结束，同时各个子线程也将被强行终止。<br>如果父线程不是 main 线程，那么父线程的结束后子线程是继续运行还是被强行终止？</p><p>答案是<strong>当父线程不是 main 线程时，父线程的结束不会强制终止子线程，只有线程的代码执行完，线程才会自动结束</strong>。<br>这是因为虽然在系统编程中，操作系统提供了直接杀死线程的接口，但是<strong>粗暴地终止一个线程可能会引发资源没有释放、状态混乱等不可预期的问题</strong>，所以 Rust 并没有提供功能。</p><p>因此<strong>非主线程的子线程的代码不会执行完时(阻塞、死循环)，子线程就不会结束，此时只有主动关闭或结束主线程才能关闭子线程</strong>。</p><p><strong>阻塞和死循环</strong></p><ul><li>线程的任务是一个循环 IO 读取，任务流程类似：IO 阻塞，等待读取新的数据 -&gt; 读到数据，处理完成 -&gt; 继续阻塞等待 ··· -&gt; 收到 socket 关闭的信号 -&gt; 结束线程，在此过程中，绝大部分时间线程都处于阻塞的状态，因此虽然看上去是循环，CPU 占用其实很小，也是网络服务中最常见的模型</li><li>线程的任务是一个循环，没有任何阻塞（也不包括休眠），此时如果没有设置终止条件，该线程将持续跑满一个 CPU 核心，并且不会被终止，直到 main 线程的结束</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程的关闭方式</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;sub sub thread running&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sub thread end&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡眠一段时间，看子线程创建的子线程是否还在运行</span></span><br><span class="line">thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h3 id="join-等待线程结束"><a href="#join-等待线程结束" class="headerlink" title="join 等待线程结束"></a>join 等待线程结束</h3><p>在使用 spawn 创建线程中，由于主线程结束，导致依赖主线程的新创建线程并没有执行完整。<br>为了能让线程安全的结束执行，需要保证<strong>主线程</strong>在依赖线程后结束，使用 join 可以达到目的。</p><p>join 可以阻塞当前线程，直到调用 join 方法的线程执行完成后才会解除当前线程的阻塞。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 join，可以使当前线程阻塞，直到调用 join 方法的线程执行完成后才会解除当前线程的阻塞</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle1</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;spawned1 thread, index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;spawned2 thread, index = &#123;&#125;&quot;</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">handle1.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// spawned1 和 spawned2 不确定的轮换执行</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">k</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;main thread, index = &#123;&#125;&quot;</span>, k);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="move-和多线程"><a href="#move-和多线程" class="headerlink" title="move 和多线程"></a>move 和多线程</h3><p>线程的启动时间点和结束时间点是不确定的，与代码的创建点无关。<br>由于这种无序和不确定性，<strong>被依赖线程</strong>不一定在依赖线程后结束，换句话说，存在<strong>被依赖线程结束运行，而依赖线程仍在运行</strong>的情况。</p><p>这意味依赖线程访问<strong>被依赖线程</strong>的环境时，需要有一个限制条件：<br>当依赖线程的闭包访问被依赖线程的变量时，需要将被依赖线程的变量所有权转移到依赖线程的闭包内，否则容易出现被依赖线程结束运行后变量被释放，而依赖线程还在访问该变量的问题。</p><p>因此使用 move 关键字拿走访问变量的所有权，被依赖线程就无法再使用该变量，也就是不会再释放该变量的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;spawned thread, index = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">&#125;);</span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><h3 id="多线程的性能"><a href="#多线程的性能" class="headerlink" title="多线程的性能"></a>多线程的性能</h3><p>不精确估算，创建一个线程大概需要 0.24 毫秒，随着线程的变多，这个值会变得更大，因此线程的创建耗时是不可忽略的，<strong>只有真的值得用线程去处理的任务时，才使用线程</strong>。</p><h4 id="创建合适的线程数量"><a href="#创建合适的线程数量" class="headerlink" title="创建合适的线程数量"></a>创建合适的线程数量</h4><p>合适的线程数是提高并发性能的关键，并发性能关键在于 CPU 负载利用率的高低。</p><p>当任务是 CPU 密集型时，就算线程数超过了 CPU 核心数，也不能获得更好的性能，因为每个线程的任务都可以轻松让 CPU 的某个核心跑满，CPU 负载利用率的高，此时让线程数等于 CPU 核心数是最好的。</p><p>当任务大部分时间都处于阻塞状态时，就可以考虑增多线程数量，这样当某个线程处于阻塞状态时会被切走，系统运行其它的线程。<br>典型就是网络 IO 操作，可以为每一个进来的用户连接创建一个线程去处理，该连接绝大部分时间都是处于 IO 读取阻塞状态，因此有限的 CPU 核心完全可以处理成百上千的用户连接线程。<br>但事实上网络 IO 一般都不再使用多线程的方式了，毕竟操作系统的线程数是有限的，意味着并发数也很容易达到上限，而且过多的线程也会导致线程上下文切换的代价过大，使用 async&#x2F;await 的 M:N 并发模型就没有这个烦恼。</p><p>CPU 密集型任务尽量让线程数量等于 CPU 核心数，阻塞型任务可以选择 async&#x2F;await 的 M:N 模型。<br>如果不确定任务是 CPU 密集型还是阻塞型，就需要通过测试来确定选择合适的线程数量。</p><h4 id="多线程的开销"><a href="#多线程的开销" class="headerlink" title="多线程的开销"></a>多线程的开销</h4><p>阅读：<a href="https://course.rs/advance/concurrency-with-threads/thread.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%80%E9%94%80">https://course.rs/advance/concurrency-with-threads/thread.html#多线程的开销</a></p><p>性能不会随着线程数的增加而线性增长，锁、数据竞争、缓存失效这些限制了现代化软件系统随着 CPU 核心的增多性能也线性增加的野心。</p><ul><li>线程过多时，CPU 缓存的命中率会显著下降，同时多个线程竞争一个 CPU Cache-line 的情况也会经常发生</li><li>大量读写可能会让内存带宽也成为瓶颈</li><li>读和写不一样，无锁数据结构的读往往可以很好地线性增长，但是写不行，因为写竞争太大</li></ul><h3 id="线程屏障-Barrier"><a href="#线程屏障-Barrier" class="headerlink" title="线程屏障(Barrier)"></a>线程屏障(Barrier)</h3><p>在 Rust 中，可以使用 Barrier 让多个线程<strong>都执行到某个位置</strong>后，才继续一起往后执行，Barrier 对于需要所有线程同时开始执行某部分代码的场景非常有用。</p><p>Rust 的 Barrier 类型是一个同步原语，Barrier 数量对应线程数量，如果两者不相等则会导致线程无法自动停止：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">barrier</span> = Arc::<span class="title function_ invoke__">new</span>(Barrier::<span class="title function_ invoke__">new</span>(<span class="number">7</span>));</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = barrier.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;before wait, &#123;i&#125;&quot;</span>);</span><br><span class="line">        b.<span class="title function_ invoke__">wait</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;after wait, &#123;i&#125;&quot;</span>);</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待线程结束才允许关闭主线程</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">t</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程局部变量（Thread-Local-Variable）"><a href="#线程局部变量（Thread-Local-Variable）" class="headerlink" title="线程局部变量（Thread Local Variable）"></a>线程局部变量（Thread Local Variable）</h3><p>对于多线程编程，线程局部变量在一些场景下非常有用，而 Rust 通过标准库和三方库对此进行了支持。</p><p>rust 标准库中提供 <code>thread_local!</code> 宏来生成线程内部变量 Thread Local Variable，有一点值得注意：<br><code>thread_local!</code> 宏声明线程局部存储 (Thread Local Storage, TLS) 变量需要使用 static 关键字，这是由于 TLS 变量的内存布局、线程安全性、编译时求值以及语义等原因决定的。<br><code>thread_local!</code> 宏本质上是在创建<strong>一个静态变量</strong>，所以在修改后，同一个线程访问的都是被修改后的值。</p><ul><li>内存布局：静态变量在程序的整个生命周期内存在，而不是在函数调用时创建和销毁，这使得 TLS 变量可以在多个函数和模块中访问</li><li>线程安全：静态变量的初始化是线程安全的。当多个线程同时访问 TLS 变量时，每个线程都会得到自己独立的变量副本</li><li>编译时求值：使用 static 可以让编译器在编译时就确定变量的内存布局和初始化表达式，这提高了性能和安全性</li><li>语义：将 TLS 变量声明为 static 更加明确地表达了它们的作用域和生命周期</li></ul><p>线程内部使用该变量的 with 方法获取变量值，每个新的线程访问它时，都会使用它的初始值作为开始：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程内部变量（Thread Local Variable），每个新的线程访问它时，都会使用它的初始值作为开始</span></span><br><span class="line">thread_local! &#123;</span><br><span class="line">    <span class="keyword">static</span> N: RefCell&lt;<span class="type">i32</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">thread_local!(<span class="keyword">static</span> FOO: RefCell&lt;<span class="type">u32</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>)); <span class="comment">// 另一种声明形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用该变量的 with 方法获取变量值，thread_local! 的本质是创建一个全局静态变量，所以在修改后，同一个线程访问的都是被修改后的值</span></span><br><span class="line">N.<span class="title function_ invoke__">with</span>(|n| &#123;</span><br><span class="line">    *n.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="comment">// 使用该变量的 with 方法获取变量值，thread_local! 的本质是创建一个全局静态变量，所以在修改后，同一个线程访问的都是被修改后的值</span></span><br><span class="line">    N.<span class="title function_ invoke__">with</span>(|n| &#123;</span><br><span class="line">        *n.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 子线程打印的值是4</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, N.<span class="title function_ invoke__">take</span>());</span><br><span class="line">&#125;);</span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// 主线程打印的值是2</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, N.<span class="title function_ invoke__">take</span>());</span><br></pre></td></tr></table></figure><p>此外还可以在结构中声明线程内部变量，与普通声明一样，每个新的线程访问它时都会使用它的初始值作为开始：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体使用 thread_local! 创建线程局部变量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    thread_local! &#123;</span><br><span class="line">        <span class="keyword">static</span> V: RefCell&lt;<span class="type">i32</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="comment">// 使用该变量的 with 方法获取变量值，thread_local! 的本质是创建一个全局静态变量，所以在修改后，同一个线程访问的都是被修改后的值</span></span><br><span class="line">    Node::V.<span class="title function_ invoke__">with</span>(|v| &#123;</span><br><span class="line">        *v.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;v:?&#125;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Node::V.<span class="title function_ invoke__">take</span>()); <span class="comment">// 4，本质是一个全局变量，被修改后同一线程访问的数据是被修改后的值</span></span><br><span class="line">&#125;);</span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Node::V.<span class="title function_ invoke__">take</span>()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>当然结构体也可以通过引用的方式使用线程局部变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">thread_local! &#123;</span><br><span class="line">    <span class="keyword">static</span> M: RefCell&lt;<span class="type">i32</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    m: &amp;<span class="symbol">&#x27;static</span> LocalKey&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, <span class="comment">// 结构体通过引用的方式使用线程局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123; m: &amp;M &#125;; <span class="comment">// 与普通声明一样，每个新的线程访问它时都会使用它的初始值作为开始</span></span><br><span class="line">    p.m.<span class="title function_ invoke__">with</span>(|m| &#123;</span><br><span class="line">        *m.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p.m.<span class="title function_ invoke__">take</span>());</span><br><span class="line">&#125;);</span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Person &#123; m: &amp;M &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p.m.<span class="title function_ invoke__">take</span>());</span><br></pre></td></tr></table></figure><p>线程中对 FOO 的使用是通过借用的方式，如果需要每个线程独自获取它的拷贝，最后进行汇总，<code>thread_local!</code> 宏就不太满足需求了。<br>借助第三方库 thread-local 很容易实现：<a href="https://course.rs/advance/concurrency-with-threads/thread.html#%E4%B8%89%E6%96%B9%E5%BA%93-thread-local">https://course.rs/advance/concurrency-with-threads/thread.html#三方库-thread-local</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用第三方包 thread_local</span></span><br><span class="line"><span class="comment">// 为了便于修改基础数据，使用 Cell</span></span><br><span class="line"><span class="comment">// let tls: Arc&lt;ThreadLocal&lt;Cell&lt;i32&gt;&gt;&gt; = Arc::new(ThreadLocal::new());</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tls</span> = Arc::<span class="title function_ invoke__">new</span>(ThreadLocal::&lt;Cell&lt;<span class="type">i32</span>&gt;&gt;::<span class="title function_ invoke__">new</span>());</span><br><span class="line"><span class="comment">// 创建多个线程，每个线程更新第三方包生成的线程局部变量（TLS），最后统计总和</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_tls</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;tls);</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cell</span> = _tls.<span class="title function_ invoke__">get_or</span>(|| Cell::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">        cell.<span class="title function_ invoke__">set</span>(cell.<span class="title function_ invoke__">get</span>() + <span class="number">1</span>);</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待所有的线程都执行完成</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计线程中的数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tls</span> = Arc::<span class="title function_ invoke__">try_unwrap</span>(tls).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">total</span> = tls</span><br><span class="line">    .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">reduce</span>(|acc, item| Cell::<span class="title function_ invoke__">new</span>(acc.<span class="title function_ invoke__">get</span>() + item.<span class="title function_ invoke__">get</span>()));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, total.<span class="title function_ invoke__">unwrap</span>());</span><br></pre></td></tr></table></figure><p>最终可以得到每个线程的线程局部变量的值的总和。</p><h3 id="条件变量控制线程的挂起和执行"><a href="#条件变量控制线程的挂起和执行" class="headerlink" title="条件变量控制线程的挂起和执行"></a>条件变量控制线程的挂起和执行</h3><p><strong>条件变量(Condition Variables)</strong> 经常和 <strong>Mutex</strong> 一起使用，可以让<strong>线程挂起</strong>，直到某个条件发生后再继续执行。</p><h4 id="Mutex（Mutual-Exclusion）"><a href="#Mutex（Mutual-Exclusion）" class="headerlink" title="Mutex（Mutual Exclusion）"></a>Mutex（Mutual Exclusion）</h4><p>Mutex 是一个互斥锁（Mutual Exclusion），同时是一个同步原语，用于在多线程环境中<strong>保护共享数据</strong>。<br>当多个线程需要访问同一数据时，Mutex 确保任何时刻只有一个线程可以访问该数据，从而防止数据竞争和不一致的问题。</p><p>使用 Mutex 时，需要先锁定它访问数据，然后再解锁让其他线程可以访问该数据。<br>锁定和解锁的过程通常是自动的，通过 Rust 的作用域管理来实现。当 Mutex 的锁超出作用域时，它会自动释放。</p><p>不同于线程局部变量的每一个线程都有单独的数据拷贝，<strong>Mutex 用于多线程访问同一个实例</strong>，因为用于多线程，所以常常和 <strong>Arc</strong> 搭配使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutex 需要手动上锁，超过作用于后自动解锁</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(Cell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>)));</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// 上锁，其他线程不能访问该数据</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cell</span> = _mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        cell.<span class="title function_ invoke__">set</span>(i.<span class="title function_ invoke__">into</span>())</span><br><span class="line">        <span class="comment">// 超出作用域后自动解锁</span></span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;mutex.lock().unwrap() = &#123;:?&#125;&quot;</span>, mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br></pre></td></tr></table></figure><h4 id="Condvar（Condition-Variable）"><a href="#Condvar（Condition-Variable）" class="headerlink" title="Condvar（Condition Variable）"></a>Condvar（Condition Variable）</h4><p>Condvar（Condition Variable）是一个同步原语，用于在多线程环境中协调线程的执行，可以视为一个信号。</p><p><code>Condvar</code> 可以阻塞一个或多个线程，让线程等待某个信号发出后继续执行，因此具有阻塞性的 <code>Condvar</code> <strong>不占用 CPU 资源</strong>。<br>当 <code>Condvar</code> 信号发出时，可以唤醒等待的线程，让线程继续执行。这种机制可以帮助提高多线程程序的性能和响应性。</p><p><code>Condvar</code> 通常配合 while 使用。while 一直循环，condvar wait 等待条件不满足时阻塞执行，不占用 CPU 资源。<br>当条件满足时，<code>Condvar</code> 唤醒等待的线程，while 循环继续执行。</p><p>因为用于多线程，并且阻塞需要给定条件和解除信号，所以 Condvar 所以常常和 <strong>Arc、Mutex</strong> 搭配使用。</p><h4 id="Mutex-和-Condvar"><a href="#Mutex-和-Condvar" class="headerlink" title="Mutex 和 Condvar"></a>Mutex 和 Condvar</h4><p><code>Condvar</code>（Condition Variable）与 <code>Mutex</code> （Mutual Exclusion）一起使用，允许线程阻塞等待特定条件成立，并在条件满足时被唤醒。</p><ul><li>等待特定条件成立，即线程（多个线程）访问某一个数据并将其作为条件，用到 Mutex</li><li>在条件满足时发出信号，唤醒等待的线程，用到 Condvar</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pair</span> = Arc::<span class="title function_ invoke__">new</span>((Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>), Condvar::<span class="title function_ invoke__">new</span>()));</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_pair</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;pair);</span><br><span class="line"></span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// 不应该在外部尝试解构 _pair，而是直接在闭包内部使用它</span></span><br><span class="line">        <span class="keyword">let</span> (mutex, condvar) = &amp;*_pair;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">single</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">4</span> &#123;</span><br><span class="line">            *single = <span class="number">4</span>;</span><br><span class="line">            condvar.<span class="title function_ invoke__">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> *single != <span class="number">4</span> &#123;</span><br><span class="line">            <span class="comment">// 当条件不满足时进入循环，被 condvar.wait 阻塞，当 condvar.notify 发出信号时，改变 single</span></span><br><span class="line">            <span class="comment">// 此时线程执行，while 循环不再符合条件，代码继续往下执行</span></span><br><span class="line">            single = condvar.<span class="title function_ invoke__">wait</span>(single).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condvar index = &#123;i&#125;&quot;</span>);</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只调用一次的函数"><a href="#只调用一次的函数" class="headerlink" title="只调用一次的函数"></a>只调用一次的函数</h3><p>如果希望一个变量无论被多少线程访问且无论访问的顺序如何，该变量只调用一次初始化代码，就需要用到 Once::call_one 方法。<br>回顾所学的两个特殊变量&#x2F;类型，线程局部变量（Thread Local Variable）和 互斥锁 Mutex（Mutual Exclusion）：</p><ul><li>线程局部变量（Thread Local Variable）在每个线程访问时都会拷贝一份初始化的值，不适合做能被多线程访问，且变量只初始化一次的场景</li><li>Mutex 存储同一份数据，可以做到被多线程访问，且变量限制初始化一次的功能，这需要每个线程判断是否为<strong>最初值</strong>，比较麻烦</li></ul><p>除了 Mutex 外，只要是一个所有线程可以访问的位置，都可以做到只调用一次初始化的功能。并且初始化的值一定是第一个访问的线程初始化的。</p><p>使用 Mutex 实现只初始化一次的功能：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 Mutex 做一个只初始化一次的变量，这需要每个线程在访问变量时判断是否为**最初值**</span></span><br><span class="line"><span class="comment">// 这里有一点注意，当前程序中初始化的值一定是第一个访问的线程，也就是索引为0线程进行了唯一一次初始化流程</span></span><br><span class="line"><span class="keyword">const</span> init_value: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(init_value));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = _mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="comment">// 每个线程的初始化值不一样</span></span><br><span class="line">        <span class="keyword">if</span> *num == init_value &#123;</span><br><span class="line">            *num = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles.<span class="title function_ invoke__">into_iter</span>() &#123;</span><br><span class="line">    h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br></pre></td></tr></table></figure><p>不确定顺序的线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(init_value));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex1</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex2</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = mutex1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">if</span> *num == init_value &#123;</span><br><span class="line">        *num = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = mutex2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">if</span> *num == init_value &#123;</span><br><span class="line">        *num = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// 10 OR 20</span></span><br></pre></td></tr></table></figure><p>使用 Mutex 做只调用一次初始化函数的功能，除了需要初始化代码，还需要手动判断是否已初始化的逻辑。<code>Once::call_once</code> 可以减少手动判断的步骤。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Once::call_once，只调用一次的函数</span></span><br><span class="line"><span class="keyword">static</span> INIT: Once = Once::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(init_value));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex1</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mutex2</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = mutex1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    INIT.<span class="title function_ invoke__">call_once</span>(<span class="keyword">move</span> || *num = <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = mutex2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    INIT.<span class="title function_ invoke__">call_once</span>(<span class="keyword">move</span> || *num = <span class="number">20</span>);</span><br><span class="line">&#125;);</span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br></pre></td></tr></table></figure><p>执行初始化过程一次，并且<strong>只执行一次</strong>。如果当前有另一个初始化过程正在运行，线程将阻止该方法被调用。<br>当这个函数返回时，保证一些初始化已经运行并完成，它还保证由执行的闭包所执行的任何内存写入都能被其他线程在这时可靠地观察到。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">     <span class="comment">// 一、初步使用 thread</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;spawned thread, index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;main thread, index = &#123;&#125;&quot;</span>, j);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>)); <span class="comment">// thread::sleep() 可以强制线程停止执行一段时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二、线程的关闭方式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(|| <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">// println!(&quot;sub sub thread running&quot;);</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;sub thread end&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 睡眠一段时间，看子线程创建的子线程是否还在运行</span></span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三、使用 join，可以使当前线程阻塞，直到调用 join 方法的线程执行完成后才会解除当前线程的阻塞</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle1</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;spawned1 thread, index = &#123;&#125;&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;spawned2 thread, index = &#123;&#125;&quot;</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    handle1.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">k</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;main thread, index = &#123;&#125;&quot;</span>, k);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四、move 和闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;spawned thread, index = &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 五、线程屏障 Barrier，Rust 的 Barrier 类型是一个同步原语。</span></span><br><span class="line">    <span class="comment">// Barrier 数量对应线程数量，如果两者不相等则会导致线程无法自动停止。</span></span><br><span class="line">    <span class="comment">// Barrier 对于需要所有线程同时开始执行某部分代码的场景非常有用。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">barrier</span> = Arc::<span class="title function_ invoke__">new</span>(Barrier::<span class="title function_ invoke__">new</span>(count));</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = barrier.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;before wait, &#123;i&#125;&quot;</span>);</span><br><span class="line">            b.<span class="title function_ invoke__">wait</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;after wait, &#123;i&#125;&quot;</span>);</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待线程结束才允许关闭主线程</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">t</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 六、线程内部变量（Thread Local Variable）</span></span><br><span class="line">    thread_local! &#123;</span><br><span class="line">        <span class="keyword">static</span> N: RefCell&lt;<span class="type">i32</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    thread_local!(<span class="keyword">static</span> FOO: RefCell&lt;<span class="type">u32</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用该变量的 with 方法获取变量值，thread_local! 的本质是创建一个全局静态变量，所以在修改后，同一个线程访问的都是被修改后的值</span></span><br><span class="line">    N.<span class="title function_ invoke__">with</span>(|n| &#123;</span><br><span class="line">        *n.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="comment">// 使用该变量的 with 方法获取变量值，thread_local! 的本质是创建一个全局静态变量，所以在修改后，同一个线程访问的都是被修改后的值</span></span><br><span class="line">        N.<span class="title function_ invoke__">with</span>(|n| &#123;</span><br><span class="line">            *n.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">4</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 子线程打印的值是4</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, N.<span class="title function_ invoke__">take</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 主线程打印的值是2</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, N.<span class="title function_ invoke__">take</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体使用 thread_local! 创建线程局部变量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        value: <span class="type">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        thread_local! &#123;</span><br><span class="line">            <span class="keyword">static</span> V: RefCell&lt;<span class="type">i32</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="comment">// 使用该变量的 with 方法获取变量值，thread_local! 的本质是创建一个全局静态变量，所以在修改后，同一个线程访问的都是被修改后的值</span></span><br><span class="line">        Node::V.<span class="title function_ invoke__">with</span>(|v| &#123;</span><br><span class="line">            *v.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">4</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;v:?&#125;&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Node::V.<span class="title function_ invoke__">take</span>()); <span class="comment">// 4，本质是一个全局变量，被修改后同一线程访问的数据是被修改后的值</span></span><br><span class="line">    &#125;);</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Node::V.<span class="title function_ invoke__">take</span>()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    thread_local! &#123;</span><br><span class="line">        <span class="keyword">static</span> M: RefCell&lt;<span class="type">i32</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        m: &amp;<span class="symbol">&#x27;static</span> LocalKey&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, <span class="comment">// 结构体通过引用的方式使用线程局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">p</span> = Person &#123; m: &amp;M &#125;; <span class="comment">// 与普通声明一样，每个新的线程访问它时都会使用它的初始值作为开始</span></span><br><span class="line">        p.m.<span class="title function_ invoke__">with</span>(|m| &#123;</span><br><span class="line">            *m.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">4</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p.m.<span class="title function_ invoke__">take</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123; m: &amp;M &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p.m.<span class="title function_ invoke__">take</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用第三方包 thread_local</span></span><br><span class="line">    <span class="comment">// 为了便于修改基础数据，使用 Cell</span></span><br><span class="line">    <span class="comment">// let tls: Arc&lt;ThreadLocal&lt;Cell&lt;i32&gt;&gt;&gt; = Arc::new(ThreadLocal::new());</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tls</span> = Arc::<span class="title function_ invoke__">new</span>(ThreadLocal::&lt;Cell&lt;<span class="type">i32</span>&gt;&gt;::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    <span class="comment">// 创建多个线程，每个线程更新第三方包生成的线程局部变量（TLS），最后统计总和</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_tls</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;tls);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">cell</span> = _tls.<span class="title function_ invoke__">get_or</span>(|| Cell::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">            cell.<span class="title function_ invoke__">set</span>(cell.<span class="title function_ invoke__">get</span>() + <span class="number">1</span>);</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待所有的线程都执行完成</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 统计线程中的数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tls</span> = Arc::<span class="title function_ invoke__">try_unwrap</span>(tls).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span> = tls</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">reduce</span>(|acc, item| Cell::<span class="title function_ invoke__">new</span>(acc.<span class="title function_ invoke__">get</span>() + item.<span class="title function_ invoke__">get</span>()));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, total.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同于线程局部变量的每一个线程都有单独的数据拷贝，Mutex 用于多线程访问同一个实例，因为用于多线程，所以常常和 Arc 搭配使用</span></span><br><span class="line">    <span class="comment">// Mutex 需要手动上锁，超过作用于后自动解锁</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(Cell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="comment">// 上锁，其他线程不能访问该数据</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">cell</span> = _mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            cell.<span class="title function_ invoke__">set</span>(i.<span class="title function_ invoke__">into</span>())</span><br><span class="line">            <span class="comment">// 超出作用域后自动解锁</span></span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;mutex.lock().unwrap() = &#123;:?&#125;&quot;</span>, mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Condvar（Condition Variable）是一个同步原语，用于在多线程环境中协调线程的执行，可以视为一个信号。</span></span><br><span class="line">    <span class="comment">// `Condvar` 的主要作用是让一个或多个线程等待某个条件成立，而**不占用 CPU 资源**，通常配合 while 使用。</span></span><br><span class="line">    <span class="comment">// 让 while 一直循环，condvar wait 等待条件不满足时阻塞执行，因此不占用 CPU 资源。</span></span><br><span class="line">    <span class="comment">// 当条件满足时，其他线程可以通知 `Condvar` 唤醒等待的线程，while循环继续执行。这种机制可以帮助提高多线程程序的性能和响应性。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = Arc::<span class="title function_ invoke__">new</span>((Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>), Condvar::<span class="title function_ invoke__">new</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_pair</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;pair);</span><br><span class="line"></span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="comment">// 不应该在外部尝试解构 _pair，而是直接在闭包内部使用它</span></span><br><span class="line">            <span class="keyword">let</span> (mutex, condvar) = &amp;*_pair;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">single</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">4</span> &#123;</span><br><span class="line">                *single = <span class="number">4</span>;</span><br><span class="line">                condvar.<span class="title function_ invoke__">notify_all</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> *single != <span class="number">4</span> &#123;</span><br><span class="line">                <span class="comment">// 当条件不满足时进入循环，被 condvar.wait 阻塞，当 condvar.notify 发出信号时，改变 single</span></span><br><span class="line">                <span class="comment">// 此时线程执行，while 循环不再符合条件，代码继续往下执行</span></span><br><span class="line">                single = condvar.<span class="title function_ invoke__">wait</span>(single).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;condvar index = &#123;i&#125;&quot;</span>);</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 Mutex 做一个只初始化一次的变量，这需要每个线程在访问变量时判断是否为**最初值**</span></span><br><span class="line">    <span class="comment">// 这里有一点注意，当前程序中初始化的值一定是第一个访问的线程，也就是索引为0线程进行了唯一一次初始化流程</span></span><br><span class="line">    <span class="keyword">const</span> init_value: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(init_value));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span>: <span class="type">Vec</span>&lt;JoinHandle&lt;()&gt;&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(count);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..count &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_mutex</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = _mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="comment">// 每个线程的初始化值不一样</span></span><br><span class="line">            <span class="keyword">if</span> *num == init_value &#123;</span><br><span class="line">                *num = i <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">h</span> <span class="keyword">in</span> handles.<span class="title function_ invoke__">into_iter</span>() &#123;</span><br><span class="line">        h.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(init_value));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex1</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex2</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = mutex1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> *num == init_value &#123;</span><br><span class="line">            *num = <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = mutex2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> *num == init_value &#123;</span><br><span class="line">            *num = <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// 10 OR 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once::call_once，只调用一次的函数</span></span><br><span class="line">    <span class="keyword">static</span> INIT: Once = Once::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(init_value));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex1</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutex2</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = mutex1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        INIT.<span class="title function_ invoke__">call_once</span>(<span class="keyword">move</span> || *num = <span class="number">10</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = mutex2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        INIT.<span class="title function_ invoke__">call_once</span>(<span class="keyword">move</span> || *num = <span class="number">20</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 并发(Concurrent)和并行(Parallel)</title>
      <link href="/2024/06/08/rust-%E5%B9%B6%E5%8F%91-Concurrent-%E5%92%8C%E5%B9%B6%E8%A1%8C-Parallel/"/>
      <url>/2024/06/08/rust-%E5%B9%B6%E5%8F%91-Concurrent-%E5%92%8C%E5%B9%B6%E8%A1%8C-Parallel/</url>
      
        <content type="html"><![CDATA[<h2 id="并发-Concurrent-和并行-Parallel"><a href="#并发-Concurrent-和并行-Parallel" class="headerlink" title="并发(Concurrent)和并行(Parallel)"></a>并发(Concurrent)和并行(Parallel)</h2><p>在 Rust 中由于语言设计理念、安全、性能的多方面考虑，而是选择了多线程与 async&#x2F;await 相结合。<br>优点是可控性更强、性能更高，缺点是复杂度并不低，当然这也是系统级语言的应有选择：<strong>使用复杂度换取可控性和性能</strong>。</p><p>由于一个 CPU 核心在同一时刻只能执行一个任务，为了避免 IO 等阻塞操作占用 CPU，需要用并发和并行提高 CPU 利用率。并发和并行是两个概念，不完全相等。</p><ul><li><strong>并发（Concurrent）</strong>  是指一个 CPU 核心在一个极小的时间片段内，快速轮换处理多个任务的部分计算。即多个任务被轮换处理，一次处理一个任务的一部分计算。</li><li><strong>并行（Parallel）</strong>是指多个 CPU 核心同时执行多个任务，一次可以执行多个任务。</li></ul><p>Erlang 之父对于 Concurrent(并发) 和 Parallel(并行) 的解释:</p><ul><li>单线程：一个咖啡机, 有多于两个队伍的人都需要使用这一个咖啡机接咖啡, 调度员只在一个队伍的人接到咖啡之后, 才允许下一个队伍使用这台咖啡机</li><li>单线程并发：仍然只有一个咖啡机, 队伍数量不变, 调度员这次取消了一个队伍的人全部接完咖啡后才能切换队伍的限制, 允许这次 A 队的人接, 下次 B 队的人接, 总体上队伍之间的进展比较协调</li><li>并行：有多个咖啡机，多个队伍可以同时接咖啡</li><li>1:1 并行：有几个队伍, 就有几个咖啡机, 队伍之间互不干扰</li><li>M:N 并行：M 个队伍, N 个咖啡机 (M &gt; N), 调度员可以根据情况, 选择让某几个队伍, <strong>在某个咖啡机上, 形成单线程并发</strong></li></ul><p><strong>并发和并行都是对“多任务”处理的描述，其中并发是指多个任务被快速轮换处理，而并行是多个任务被同时处理。</strong></p><p>并发和并行总共可以分为三类：单核心并发，多核心并行，多核心并发。</p><h3 id="单核心并发"><a href="#单核心并发" class="headerlink" title="单核心并发"></a>单核心并发</h3><p>在 OS 级别，多线程负责管理任务队列，可以简单认为一个线程管理着一个任务队列，然后线程之间还能根据空闲度进行任务调度。<br>程序只会跟 OS 线程打交道，并不关心 CPU 到底有多少个核心，真正关心的只是 OS，当线程把任务交给 CPU 核心去执行时，如果只有一个 CPU 核心，那么它就只能同时处理一个任务。</p><p>假如某个任务执行时间过长，就可能导致用户界面的假死。此时就需要 CPU 的任务调度器，它会按照某些条件从任务队列中选择任务进行执行，并且当一个任务执行时间过长时，调度器会强行切换该任务到后台中，去执行新的任务。<br>不断这样的快速任务切换，对用户而言就实现了表面上的多任务同时处理，但是实际上最终也只有一个 CPU 核心在不停的工作。</p><p>因此并发的关键在于：<strong>快速轮换</strong>处理不同的任务，给用户带来所有任务同时在运行的假象。</p><h3 id="多核心并行"><a href="#多核心并行" class="headerlink" title="多核心并行"></a>多核心并行</h3><p>当 CPU 核心增多到 N 时，那么同一时间就能有 N 个任务被处理，并行度就是 N，相应的处理效率也变成了单核心的 N 倍（实际情况并没有这么高）。</p><h3 id="多核心并发"><a href="#多核心并发" class="headerlink" title="多核心并发"></a>多核心并发</h3><p>当核心增多到 N 时，操作系统同时在进行的任务肯定远不止 N 个，这些任务将被放入 M 个线程队列中，接着交给 N 个 CPU 核心去执行，最后实现了 M:N 的处理模型。<br>在这种情况下，并发与并行是同时在发生的，所有用户任务从表面来看都在同时运行，但实际上，同一时刻只有 N 个任务能被同时并行的处理。</p><h3 id="lt-lt-并发的艺术-gt-gt-的正式定义"><a href="#lt-lt-并发的艺术-gt-gt-的正式定义" class="headerlink" title="&lt;&lt;并发的艺术&gt;&gt; 的正式定义"></a>&lt;&lt;并发的艺术&gt;&gt; 的正式定义</h3><p>如果某个系统支持两个或者多个动作（任务）<strong>同时存在</strong>，那么这个系统就是一个并发系统。<br>如果某个系统支持两个或者多个动作（任务）<strong>同时执行</strong>，那么这个系统就是一个并行系统。<br>并发系统与并行系统这两个定义之间的关键差异在于 “同时存在和同时运行”。</p><p>在并发程序中可以同时拥有两个或者多个线程。这意味着：<br>如果程序在单核处理器上运行，那么这两个&#x2F;多个线程将轮换地换入或者换出内存。这些线程是<strong>同时存在</strong>的——每个线程都处于执行过程中的某个状态。<br>如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。</p><p>并发中中的 “同时” 指的是 “多个任务同时存在”，在一个极小的时间片段内，多个任务轮换执行。而并行中的同时强调的是 “多个任务同时执行”，在一个时刻同时执行多个任务。<br>同一个时间片段内并不代表同时执行，但是一个时刻同时执行多个任务，那么在这个时刻周围的一段时间必然同时存在多个任务。</p><p>也就是说：<strong>“并行”概念是“并发”概念的一个子集</strong>，一个多线程&#x2F;进程程序，如果没有多核处理器执行，那就不能以并行的方式运行代码。<br>凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</p><h3 id="编程语言的并发模型"><a href="#编程语言的并发模型" class="headerlink" title="编程语言的并发模型"></a>编程语言的并发模型</h3><p>不同的编程语言对于线程的实现可能大相径庭，但最终都是通过操作系统的线程来运行：</p><ul><li>部分语言会直接调用操作系统提供的创建线程的 API 来创建线程（语言的线程），最终程序内的线程数和程序占用的操作系统的线程数相等，一般称之为 1:1 线程模型，例如 Rust。</li><li>部分语言在内部实现了自己的线程模型（绿色线程、协程），程序内部的 M 个线程最后会以某种映射方式使用 N 个操作系统线程去运行，因此称之为 M:N 线程模型，其中 M 和 N 并没有特定的彼此限制关系。例如 Go。</li><li>部分言使用了 Actor 模型，基于消息传递进行并发，例如 Erlang。</li></ul>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 结构体的自引用</title>
      <link href="/2024/06/05/rust-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%87%AA%E5%BC%95%E7%94%A8/"/>
      <url>/2024/06/05/rust-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%87%AA%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="结构体的自引用"><a href="#结构体的自引用" class="headerlink" title="结构体的自引用"></a>结构体的自引用</h2><p>在 JavaScript&#x2F;TypeScript 中，自引用很常见，例如 <code>this</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">nickname</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line">  <span class="attr">nickname</span>: <span class="string">&quot;N&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">person.<span class="property">nickname</span> = name;</span><br></pre></td></tr></table></figure><p>在没有所有权机制的语言、特别是带 GC 自动引用的语言中，自引用非常简单。而在具有所有权机制的 rust，自引用是一个非常困难的问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SelfRef</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    value: <span class="type">String</span>,</span><br><span class="line">    pointer_to_value: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, <span class="comment">// 该引用指向上面的value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">selfRef</span> = SelfRef &#123;</span><br><span class="line">     value: s,</span><br><span class="line">     pointer_to_value: &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于转移所有权和使用借用同时发生，不符合借用规则，最后编译报错。</p><p>rust 中有几种解决这种问题的方案，如类似解决循环引用的组合 <code>Rc + RefCell</code>，又或者绕过借用规则的 unsafe 操作，但最终<strong>最好的方式是不使用自引用结构体</strong>。</p><p><a href="https://course.rs/advance/circle-self-ref/self-referential.html#rc--refcell-%E6%88%96-arc--mutex">https://course.rs/advance/circle-self-ref/self-referential.html#rc--refcell-%E6%88%96-arc--mutex</a></p><h3 id="Rc-RefCell"><a href="#Rc-RefCell" class="headerlink" title="Rc + RefCell"></a>Rc + RefCell</h3><p>在循环引用章节中，为了方便值的初始化，选择 enum 枚举来定义空值状态，现在改成 Option 以便定义空值状态。</p><p><strong>第一步</strong><br>因为节点的 prev、next 可以指向任意一个节点，所以这两个属性应该是 <code>RefCell&lt;Rc&lt;Node&gt;&gt;</code> 类型，而不是 <code>Rc&lt;RefCell&lt;Node&gt;&gt;</code>。<br>这是因为根据<strong>内部可变性</strong>， <code>RefCell&lt;Rc&lt;Node&gt;&gt;</code> 可以更改 <code>Rc&lt;Node&gt;</code> 的内容，而 <code>Rc&lt;RefCell&lt;Node&gt;&gt;</code> 不能更改指向的节点，只能修改节点信息。</p><p><strong>第二步</strong><br><code>RefCell&lt;Rc&lt;Node&gt;&gt;</code> 组合在链表状态下，很有可能形成循环强引用进而触发 OOM，为了避免循环强引用，将 prev 改为 Weak，利用 Weak 阻断循环强引用。<br><code>next: RefCell&lt;Rc&lt;Node&gt;&gt;</code> 和 <code>prev: RefCell&lt;Weak&lt;Node&gt;&gt;</code></p><p><strong>第三步</strong><br>初始化 Node 结构体时，prev 和 next 不可能永远有值，因此需要定义一个空值。此时 prev 和 next 的定义应该是：一个能够指向任意节点或指向空的数据。<br>prev 和 next 指针可以指向任意节点或指向空，意味着 prev 和 next 是可变的。</p><p>因此，为了避免所有权的 mutable 的特性（整体可变，要求内部所有字段都可变）需要把类型定义为 <code>RefCell&lt;Option&lt;Rc&lt;Node&gt;&gt;&gt;</code>，而不是 <code>Option&lt;RefCell&lt;Rc&lt;Node&gt;&gt;&gt;</code>。<br>因为 <code>Option&lt;T&gt;</code> 涉及到所有权的 mutable 特性，当需要更改指向节点时，所有权变更&#x2F;管理非常麻烦，而 <code>RefCell&lt;T&gt;</code> 因为内部可变性将会很简单。<br>同理，不能用 <code>Rc</code> 包裹 <code>RefCell</code>，而是 <code>RefCell</code> 包裹 <code>Rc</code>。</p><p>因此，next 的类型为 <code>RefCell&lt;Option&lt;Rc&lt;Node&gt;&gt;&gt;</code>，prev 的类型为 <code>RefCell&lt;Option&lt;Weak&lt;Node&gt;&gt;&gt;</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    prev: RefCell&lt;<span class="type">Option</span>&lt;Weak&lt;Node&gt;&gt;&gt;,</span><br><span class="line">    next: RefCell&lt;<span class="type">Option</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    prev: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">    next: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    prev: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">    next: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 a 的 next 指向 b</span></span><br><span class="line">*a.next.<span class="title function_ invoke__">borrow_mut</span>() = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;b));</span><br><span class="line"><span class="comment">// 将 b 的 prev 指向 a</span></span><br><span class="line">*b.prev.<span class="title function_ invoke__">borrow_mut</span>() = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">downgrade</span>(&amp;a));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure><p>当使用到自引用时，只需要复制 <code>Rc</code> 指针即可。</p><p><code>Rc + RefCell</code> 虽然可以解决问题，但是增加了许多类型标识，可读性受到很大的影响。</p><h3 id="unsafe-操作"><a href="#unsafe-操作" class="headerlink" title="unsafe 操作"></a>unsafe 操作</h3><p>既然自引用受到借用规则的限制，那么可以通过绕过借用规则来实现自引用。绕过借用规则的最简单方式就是通过 unsafe。</p><p>unsafe 中不操作 rust 的引用，而是直接存储&#x2F;操作<strong>裸指针</strong>（原始指针），不再受到 Rust 借用规则和生命周期的限制，实现起来非常清晰、简洁。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 unsafe 操作裸指针实现自引用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelfRef</span> &#123;</span><br><span class="line">    value: <span class="type">String</span>,</span><br><span class="line">    pointer_to_value: *<span class="keyword">const</span> <span class="type">String</span>, <span class="comment">// 该裸指针指向上面的 value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">selfRef</span> = SelfRef &#123;</span><br><span class="line">    value: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>),</span><br><span class="line">    pointer_to_value: ptr::<span class="title function_ invoke__">null</span>(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 直接存储裸指针信息，引用转换裸指针需要类型标注，否则就是rust引用</span></span><br><span class="line">selfRef.pointer_to_value = &amp;selfRef.value;</span><br><span class="line"><span class="comment">// 操作裸指针取值时需要unsafe绕过借用规则和生命周期检查</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">pointer_to_value</span> = <span class="keyword">unsafe</span> &#123; &amp;(*selfRef.pointer_to_value) &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, selfRef.value, pointer_to_value);</span><br></pre></td></tr></table></figure><p><code>ptr::null()</code> 是不可变裸指针类型的空值，除了 <code>*const</code> 不可变裸指针类型外，还有一种 <code>*mut</code> 可变裸指针类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *mut 可变裸指针</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelfRefMut</span> &#123;</span><br><span class="line">    value: <span class="type">String</span>,</span><br><span class="line">    pointer_to_value: *<span class="keyword">mut</span> <span class="type">String</span>, <span class="comment">// 该裸指针指向上面的 value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">selfRef</span> = SelfRefMut &#123;</span><br><span class="line">    value: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>),</span><br><span class="line">    pointer_to_value: ptr::<span class="title function_ invoke__">null_mut</span>(),</span><br><span class="line">&#125;;</span><br><span class="line">selfRef.pointer_to_value = &amp;<span class="keyword">mut</span> selfRef.value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *mut 无论是取值还是赋值，都需要在 unsafe 中操作</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">pointer_to_value</span> = <span class="keyword">unsafe</span> &#123; &amp;(*selfRef.pointer_to_value) &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, selfRef.value, pointer_to_value);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pointer_to_vlaue</span> = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    *selfRef.pointer_to_value = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">    &amp;(*selfRef.pointer_to_value)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;:?&#125;&quot;</span>,</span><br><span class="line">    selfRef.value, pointer_to_vlaue, selfRef.pointer_to_value</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>unsafe 虽然简单好用，但是它不太安全，当 value 的地址改变后，访问 <code>pointer_to_value</code> 即访问 value 原地址就存在未定义行为的风险。<br>比如完全克隆一份 <code>selfRef</code> 数据，然后释放原有的 <code>selfRef</code> 数据，此时新数据的 <code>selfRef.pointer_to_value</code> 存储的原 value 地址就是一个未定义的数据，访问此时的 <code>selfRef.pointer_to_value</code> 就是未定义的行为。</p><h3 id="Pin-固定值的地址"><a href="#Pin-固定值的地址" class="headerlink" title="Pin 固定值的地址"></a>Pin 固定值的地址</h3><p>unsafe 实现不能保证安全的原因是 value 的地址可能发生更改，<code>pointer_to_value</code> 记录 value 的原地址可能是一个未定义的数据，访问存在未定义行为的风险。</p><blockquote><p>比如完全克隆一份 <code>selfRef</code> 数据，然后释放原有的 <code>selfRef</code> 数据，此时新数据的 <code>selfRef.pointer_to_value</code> 存储的原 value 地址就是一个未定义的数据，访问此时的 <code>selfRef.pointer_to_value</code> 就是未定义的行为。</p></blockquote><p>如果将 value 的地址固定，<code>pointer_to_value: *const</code> 就是一直有效的地址，不会存在未定义行为的风险。rust 提供的 Pin 智能指针(结构体)提供了固定地址的功能。</p><p>从<strong>是否可以在内存中安全的被移动</strong>的角度，rust 的类型分类两类，<code>Unpin</code> 和 <code>!Unpin</code>，具体的区分如下：</p><ul><li><code>Unpin</code> 表示类型<strong>可以在内存中安全地移动</strong>，即能安全的改变地址不会带来意外的错误。绝大多数标准库类型都实现了 Unpin。</li><li><code>!Unpin</code> 表示类型<strong>在内存中移动可能会发生意外的副作用</strong>，比如裸指针实现的自引用结构体，改变结构体地址后，存储的裸指针还是访问原地址，存在未定义行为的风险。</li></ul><blockquote><p>特征前的 <code>!</code> 代表没有实现某个特征的意思，<code>!Unpin</code> 说明类型没有实现 Unpin 特征。</p></blockquote><p>这些定义与名称会比较绕，<code>Unpin</code> 表示<strong>不需要被固定就可以安全移动的类型</strong>，<code>!Unpin</code> 表示没有实现 <code>Unpin</code> 特征的类型，也就是在内存移动中可能发生副作用的类型。<br>为什么不用 Pin 和 Unpin？这是因为 rust 将 <code>Pin</code> 作为“动作”的智能指针（结构体），而不是特征，**<code>Pin</code> 表示固定一个值的地址**，它可以接收实现 <code>Unpin</code> 或 <code>!Unpin</code> 特征的类型。</p><ul><li>如果 Pin 的是 Unpin 类型，则还是可以被移动走的。因为实现 Unpin 就表示移动是安全的。</li><li>如果 Pin 的是 !Unpin 类型，则无法被移动走。因为 !Unpin 就表示移动是不安全的。</li></ul><p><strong>Pin 不仅可以将值固定到堆上，也可以固定到栈上</strong>。将 <code>!Unpin</code> 值固定到堆上无需 unsafe，可以通过 <code>Box::pin</code> 来简单的实现，将 <code>!Unpin</code> 值固定到栈上需要使用 unsafe。<br><code>Box::pin</code> 函数在内部处理了固定操作，通过类型系统和所有权规则来自动保证值在整个生命周期内不会被移动。栈上的固定涉及到更直接的内存操作，可能需要手动保证对象不被移动。<br>由于 Rust 的安全模型默认不允许直接操控栈上的内存位置，因此需要使用 unsafe 来明确绕过这些限制，这也意味着固定在栈上的 <code>!Unpin</code>，不仅需要使用 Pin，而且还需要 <code>unsafe</code>。</p><p>结构体实现 <code>Unpin</code> 和 <code>!Unpin</code>：</p><ul><li>如果自定义的类型成员都实现了 Unpin 的，那么该自定义类型会自动实现 Unpin。</li><li><code>!Unpin</code> 类型需要通过 PhantomPinned 特殊标记，只要自定义构体里面有一个成员是 <code>!Unpin</code>，则该结构也是 <code>!Unpin</code>。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能安全移动的类型，即在内存中移动数据可能会导致意外的副作用，通常需要 PhantomPinned 标识字段</span></span><br><span class="line"><span class="comment">// 只要有一个字段被标示为 `!Unpin`（一般都是 PhantomPinned 作为值），那么整个结构体就实现 `!Unpin` 特征</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelfRefNotUnpin</span> &#123;</span><br><span class="line">    value: <span class="type">String</span>,</span><br><span class="line">    pointer_to_value: *<span class="keyword">mut</span> <span class="type">String</span>,</span><br><span class="line">    _pin: PhantomPinned, <span class="comment">// 用 PhantomPinned 标识该类型是一个实现 `!Unpin` 的类型，只要一个类型属性是 `!Unpin`，这个结构体就默认成为实现 `!Unpin` 的类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">self_ref_not_unpin</span> = <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(SelfRefNotUnpin &#123;</span><br><span class="line">    value: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>),</span><br><span class="line">    pointer_to_value: ptr::<span class="title function_ invoke__">null_mut</span>(),</span><br><span class="line">    _pin: PhantomPinned,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Pin后，并不意味着就不需要使用 unsafe 操作，Pin 只是将由于 `!Unpin` 在内存移动可能引发副作用的移动限制了，不会移动就不发生 `!Unpin` 的副作用。</span></span><br><span class="line"><span class="comment">// 至于在原内存空间修改值，还是需要 unsafe 操作获取被 Pin 包括的值，此时的 unsafe 代码是安全的，因为修改内部的值不会导致整体的内存地址发生变化</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// 被包裹的PinRef</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">self_ref_not_unpin_pin_mutref</span> = self_ref_not_unpin.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">    <span class="comment">// 真正值的 mut ref</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">self_ref_not_unpin_mutref</span> = Pin::<span class="title function_ invoke__">get_unchecked_mut</span>(self_ref_not_unpin_pin_mutref);</span><br><span class="line">    self_ref_not_unpin_mutref.pointer_to_value = &amp;<span class="keyword">mut</span> self_ref_not_unpin_mutref.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值还是要通过unsafe操作</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">pointer_to_value</span> = <span class="keyword">unsafe</span> &#123; &amp;(*self_ref_not_unpin.pointer_to_value) &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;&#125;&quot;</span>, self_ref_not_unpin, pointer_to_value);</span><br></pre></td></tr></table></figure><p>使用 Pin 后，并不意味着就不需要使用 unsafe 操作，Pin 只是将由于 <code>!Unpin</code> 在内存移动可能引发副作用的移动限制了，不会移动就不发生 <code>!Unpin</code> 的副作用。<br>至于在原内存空间修改值，还是需要 unsafe 操作获取被 Pin 包括的值，此时的 unsafe 代码是安全的，因为修改内部的值不会导致整体的内存地址发生变化</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自引用结构体是一个很特殊的类型，由于所有权和引用同时存在，导致不能像正常类型一样使用。比较建议通过 <code>RefCell + Rc</code> 或者 <code>Pin + unsafe</code> 使用自引用结构体。<br><code>RefCell + Rc</code> 的缺点是类型声明很多，可读性太差，<code>Pin + unsafe</code> 的缺点是需要用到 unsafe 操作。</p><p>Pin 是一个智能指针（结构体），<code>Unpin</code> 和 <code>!Unpin</code> 则是特征。</p><p>TODO 等某一天使用到自引用结构时再来补齐</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        value: <span class="type">i32</span>,</span><br><span class="line">        prev: RefCell&lt;<span class="type">Option</span>&lt;Weak&lt;Node&gt;&gt;&gt;,</span><br><span class="line">        next: RefCell&lt;<span class="type">Option</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">1</span>,</span><br><span class="line">        prev: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">        next: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">2</span>,</span><br><span class="line">        prev: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">        next: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 a 的 next 指向 b</span></span><br><span class="line">    *a.next.<span class="title function_ invoke__">borrow_mut</span>() = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;b));</span><br><span class="line">    <span class="comment">// 将 b 的 prev 指向 a</span></span><br><span class="line">    *b.prev.<span class="title function_ invoke__">borrow_mut</span>() = <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">downgrade</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 unsafe 操作裸指针实现自引用</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SelfRef</span> &#123;</span><br><span class="line">        value: <span class="type">String</span>,</span><br><span class="line">        pointer_to_value: *<span class="keyword">const</span> <span class="type">String</span>, <span class="comment">// 该裸指针指向上面的 value</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">selfRef</span> = SelfRef &#123;</span><br><span class="line">        value: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>),</span><br><span class="line">        pointer_to_value: ptr::<span class="title function_ invoke__">null</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 直接存储裸指针信息，引用转换裸指针需要类型标注，否则就是rust引用</span></span><br><span class="line">    selfRef.pointer_to_value = &amp;selfRef.value;</span><br><span class="line">    <span class="comment">// 操作裸指针取值时需要unsafe绕过借用规则和生命周期检查</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pointer_to_value</span> = <span class="keyword">unsafe</span> &#123; &amp;(*selfRef.pointer_to_value) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, selfRef.value, pointer_to_value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *mut 可变裸指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SelfRefMut</span> &#123;</span><br><span class="line">        value: <span class="type">String</span>,</span><br><span class="line">        pointer_to_value: *<span class="keyword">mut</span> <span class="type">String</span>, <span class="comment">// 该裸指针指向上面的 value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">selfRef</span> = SelfRefMut &#123;</span><br><span class="line">        value: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>),</span><br><span class="line">        pointer_to_value: ptr::<span class="title function_ invoke__">null_mut</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    selfRef.pointer_to_value = &amp;<span class="keyword">mut</span> selfRef.value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *mut 无论是取值还是赋值，都需要在 unsafe 中操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pointer_to_value</span> = <span class="keyword">unsafe</span> &#123; &amp;(*selfRef.pointer_to_value) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, selfRef.value, pointer_to_value);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pointer_to_vlaue</span> = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *selfRef.pointer_to_value = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">        &amp;(*selfRef.pointer_to_value)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;:?&#125;&quot;</span>,</span><br><span class="line">        selfRef.value, pointer_to_vlaue, selfRef.pointer_to_value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能安全移动的类型，即在内存中移动数据可能会导致意外的副作用，通常需要 PhantomPinned 标识字段</span></span><br><span class="line">    <span class="comment">// 只要有一个字段被标示为 `!Unpin`（一般都是 PhantomPinned 作为值），那么整个结构体就实现 `!Unpin` 特征</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SelfRefNotUnpin</span> &#123;</span><br><span class="line">        value: <span class="type">String</span>,</span><br><span class="line">        pointer_to_value: *<span class="keyword">mut</span> <span class="type">String</span>,</span><br><span class="line">        _pin: PhantomPinned, <span class="comment">// 用 PhantomPinned 标识该类型是一个实现 `!Unpin` 的类型，只要一个类型属性是 `!Unpin`，这个结构体就默认成为实现 `!Unpin` 的类型</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">self_ref_not_unpin</span> = <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(SelfRefNotUnpin &#123;</span><br><span class="line">        value: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>),</span><br><span class="line">        pointer_to_value: ptr::<span class="title function_ invoke__">null_mut</span>(),</span><br><span class="line">        _pin: PhantomPinned,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Pin后，并不意味着就不需要使用 unsafe 操作，Pin 只是将由于 `!Unpin` 在内存移动可能引发副作用的移动限制了，不会移动就不发生 `!Unpin` 的副作用。</span></span><br><span class="line">    <span class="comment">// 至于在原内存空间修改值，还是需要 unsafe 操作获取被 Pin 包括的值，此时的 unsafe 代码是安全的，因为修改内部的值不会导致整体的内存地址发生变化</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 被包裹的PinRef</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">self_ref_not_unpin_pin_mutref</span> = self_ref_not_unpin.<span class="title function_ invoke__">as_mut</span>();</span><br><span class="line">        <span class="comment">// 真正值的 mut ref</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">self_ref_not_unpin_mutref</span> = Pin::<span class="title function_ invoke__">get_unchecked_mut</span>(self_ref_not_unpin_pin_mutref);</span><br><span class="line">        self_ref_not_unpin_mutref.pointer_to_value = &amp;<span class="keyword">mut</span> self_ref_not_unpin_mutref.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取值还是要通过unsafe操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pointer_to_value</span> = <span class="keyword">unsafe</span> &#123; &amp;(*self_ref_not_unpin.pointer_to_value) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;&#125;&quot;</span>, self_ref_not_unpin, pointer_to_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: Weak 与循环引用</title>
      <link href="/2024/05/31/rust-Weak-%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"/>
      <url>/2024/05/31/rust-Weak-%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Weak-与循环引用"><a href="#Weak-与循环引用" class="headerlink" title="Weak 与循环引用"></a>Weak 与循环引用</h2><p>链表在 Rust 中之所以这么难，完全是因为循环引用和自引用的问题引起的，这两个问题可以说综合了 Rust 的很多难点。<br>rust 的安全措施可以避免大部分的内存问题，但是不代表它不会出现问题。一个典型的例子就是同时使用 <code>Rc</code> 和 <code>RefCell</code> 出现的循环引用，导致引用计数无法归零，最终出现内存问题。</p><p>在 Rc&#x2F;Arc 介绍的章节中，使用 Rc&#x2F;Arc 解决图数据结构引用复杂的问题，但因为 Rc&#x2F;Arc 是不可变引用，所以不能通过 Rc&#x2F;Arc 修改节点的数据。</p><p>同时在上一章提过 Rc 与 RefCell 的不同组合（<code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 和 <code>RefCell&lt;Rc&lt;T&gt;&gt;</code>）的特点。</p><ul><li><p><code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 类型是一个通过 Rc 可供多个变量引用，通过 RefCell 可提供不可变&#x2F;可变借用的高级类型，也就是每个该类型的变量都可单独读写真实数据。</p></li><li><p><code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 类型也是一个内部可变性的高级类型，不仅可以提供不可变&#x2F;可变借用和无需手动管理复杂的生命周期，<br><strong><code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 还能通过 <code>Rc</code> 智能指针可以指向 T 类型的不同实例</strong>，<code>RefCell&lt;T&gt;</code> 只能指向 T 类型的一个实例，因为这是内部可变性，而不是整体可变。</p></li><li><p><code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 是常用的一种组合，它给变量提供了自动管理引用释放转换不可变&#x2F;可变借用的功能</p></li><li><p><code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 是解决内部可变性整体不可变的限制，它为变量提供不可变&#x2F;可变引用和存储数据指针的空间</p></li></ul><p>现在利用 RefCell 与 Rc 的组合 <code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 就可以实现一个简单的链表。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="title function_ invoke__">derive</span>(<span class="built_in">Debug</span>)]</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">node</span> = List::<span class="title function_ invoke__">Cons</span>(<span class="number">12</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(List::Nil)));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, node);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> &amp;node &#123;</span><br><span class="line">    List::<span class="title function_ invoke__">Cons</span>(v, next) =&gt; &#123;</span><br><span class="line">        <span class="comment">// next 原有的指针信息是指向 List::Nil 的，现在指向 List::Cons(20, RefCell::new(Rc::new(List::Nil)))</span></span><br><span class="line">        <span class="comment">// 此时是存储的指针信息发生改变，而不是存储空间发生改变</span></span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">new</span>(List::<span class="title function_ invoke__">Cons</span>(<span class="number">20</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(List::Nil))))</span><br><span class="line">    &#125;</span><br><span class="line">    List::Nil =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, node);</span><br></pre></td></tr></table></figure><p>上面注意 <code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 更改存储的指针就能达到更改指向的节点的功能，这与更改节点数据使节点看起来是另外一个节点是两回事。<br><code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 关注的是指向其他节点，而 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 只是更改节点内容信息。</p><p>以上链表的实现非常简单，没有考虑循环引用以及自引用的情况，看一段循环引用的实现：</p><ul><li>创建 a，创建 b，利用 <code>Rc::clone(&amp;a)</code> 让 b 的 next 指向 a，即 b 引用了 a</li><li>利用 <code>Rc::clone(&amp;b)</code> 让 a 的 next 指向 b，即 a 引用了 b</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义取出节点的下一节点的方法，不拿走下一节点的所有权，即只拿引用，又因为下一节点是RefCell类型，所以可以只拿不可变引用就能得到可变引用</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tail</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            List::<span class="title function_ invoke__">Cons</span>(_, next) =&gt; <span class="title function_ invoke__">Some</span>(next),</span><br><span class="line">            List::Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - 创建 a，创建 b，利用 `Rc::clone(&amp;b)` 让 a 的 next 指向 b，即 a 引用了 b</span></span><br><span class="line"><span class="comment">// - 利用 `Rc::clone(&amp;a)` 让 b 的 next 指向 a，即 b 引用了 a</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(List::<span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(List::Nil))));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(List::<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(List::Nil))));</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;Initial: a.strone_count = &#123;&#125;, b.strone_count = &#123;&#125;&quot;</span>,</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next) = a.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">    *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b); <span class="comment">// a 的 next 指向 b，即 a 引用了 b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;a.next: a.strone_count = &#123;&#125;, b.strone_count = &#123;&#125;&quot;</span>,</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next) = b.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">    *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;a); <span class="comment">// b 的 next 指向 a，即 b 引用了 a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;b.next: a.strone_count = &#123;&#125;, b.strone_count = &#123;&#125;&quot;</span>,</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 成功创建了循环引用a-&gt; b -&gt; a -&gt; b ····</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环引用，造成8MB的主线程栈溢出</span></span><br><span class="line"><span class="comment">// println!(&quot;&#123;:?&#125;&quot;, a.tail());</span></span><br></pre></td></tr></table></figure><p>在 main 函数结束前，a 和 b 的引用计数均是 2，随后变量 a 触发 Drop，此时值的 Rc 引用计数变为 1，由于 b.next 的引用，Rc 引用计数并不会归 0，因此变量 a 所指向内存（值）不会被释放，同理 b 指向的内存（值）也不会被释放，最终发生了内存泄漏。</p><p>只需要访问 a 或 b 的下一节点，就会触发循环引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环引用，造成8MB的主线程栈溢出</span></span><br><span class="line"><span class="comment">// println!(&quot;&#123;:?&#125;&quot;, a.tail());</span></span><br></pre></td></tr></table></figure><p><code>a.tail</code> 调用返回 <code>a.next</code> 引用即 <code>b</code> 智能指针，打印 <code>b</code> 智能指针时会打印 <code>b.next</code> 智能指针（打印一个完整的链表数据）。<br><code>b.next</code> 即 <code>a</code>，打印 <code>a</code> 时同样因为要打印完整的数据，会打印 <code>a.next</code> 即 <code>b</code>，最后出现循环引用不断解析引用指向的数据。<br>Rust 试图打印出 <code>a -&gt; b -&gt; a ···</code> 的所有内容，最终 main 线程终于不堪重负，发生了栈溢出。</p><p>创建循环引用并不简单，但是也并不是完全遇不到，当使用 <code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 或者<strong>具备内部可变性和引用计数的嵌套组合类型</strong>时，就要打起万分精神，避免出现循环引用。<br><strong>循环引用的存在不一定会引起问题</strong>，只有使用到循环引用时才会触发 OOM。</p><h3 id="Weak"><a href="#Weak" class="headerlink" title="Weak"></a>Weak</h3><p>在上面的循环引用案例中，main 函数结束前释放变量，由于值被其他变量引用所以不能被释放。这种引用属于强引用，只要存在强引用，值就不会被释放，换句话说强引用会阻止值的释放。</p><p>相比较强引用，<strong>弱引用不持有值所有权，不保证引用关系一直有效，它仅仅保存一份指向数据的弱引用</strong>。<br>所以所引用它无法阻止所引用的内存值被释放，即<strong>弱引用本身不对值的存在性做任何担保</strong>，引用的值还存在就返回 Some，不存在就返回 None。</p><p><code>Weak</code> 就是一个弱引用，它与 Rc 非常相似，但是与 Rc 持有所有权不同，Weak 不持有所有权，它仅仅保存一份指向数据的弱引用。<br><code>Weak</code> 虽然与 Rc 智能指针不同，但是有效 <code>Weak</code> 的生成总是需要 Rc 指针，通过值的 Rc 指针形式 <code>Rc::downgrade</code> 生成有效的 Weak 指针。</p><p>如果想要访问数据，需要通过 Weak 指针的 <code>upgrade</code> 方法实现，该方法返回一个类型为 <code>Option&lt;Rc&lt;T&gt;&gt;</code> 的值。</p><p><strong>对比 Weak 和 Rc</strong></p><table><thead><tr><th>Weak 弱引用，不计数</th><th>Rc 强引用，引用计数</th></tr></thead><tbody><tr><td>不拥有所有权</td><td>拥有访问值的能力（不可变引用访问）</td></tr><tr><td>不阻止值被释放(drop)</td><td>所有权计数归零，才能 drop</td></tr><tr><td>引用的值存在返回 Some，不存在返回 None</td><td>引用的值必定存在</td></tr><tr><td>通过 upgrade 取到 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，然后再取值</td><td>通过 Deref 自动解引用，取值无需任何操作</td></tr></tbody></table><p>Weak 的功能非常弱，而这种弱恰恰适合以下的场景：</p><ul><li>阻止 Rc 导致的循环强引用，因为 Rc 智能指针的引用计数机制，可能会导致一个值对应的多个 Rc 计数无法归零</li><li>希望持有一个 Rc 类型的对象的临时引用，并希望这个引用不影响任何值的释放</li></ul><p>在上面的 List 结构中，可以使用这种方式来解决循环强引用问题：让前一个节点通过 Rc 来引用后一个节点，然后让后一个节点通过 Weak 来引用前一个节点。<br>Rc 强引用意味着数据不会被释放，Weak 需要使用 <code>upgrade</code> 后才能访问数据，意味着无法直接访问弱引用指向的数据，能避开循环强引用的陷阱。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于多出一种 Weak 类型，当前的List不满足使用，需要拓展字段。同时有可能需要修改前一个节点的值，所以用 `RefCell` 包裹</span></span><br><span class="line"><span class="comment">// 利用枚举创建一个空值类型，避免结构体没有空值的问题</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// value, prev, next</span></span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Weak&lt;Node&gt;&gt;, RefCell&lt;Rc&lt;Node&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;Node&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Node::<span class="title function_ invoke__">Cons</span>(_, _, next) =&gt; <span class="title function_ invoke__">Some</span>(next),</span><br><span class="line">            Node::Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">prev</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Weak&lt;Node&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Node::<span class="title function_ invoke__">Cons</span>(_, prev, _) =&gt; <span class="title function_ invoke__">Some</span>(prev),</span><br><span class="line">            Node::Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用 Rc 指向下一个节点，使用 Weak 指向上一个节点，避免循环强引用陷阱</span></span><br><span class="line"><span class="comment">// - 创建 a，创建 b，利用 `Rc::clone(&amp;b)` 让 a 的 next 指向 b，即 a 引用了 b</span></span><br><span class="line"><span class="comment">// - 利用 `Rc::downgrade(&amp;a)` 让 b 的 prev 指向 a，即 b 弱引用了 a</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">Cons</span>(</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">    RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Node::Nil)),</span><br><span class="line">));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">Cons</span>(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">    RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Node::Nil)),</span><br><span class="line">));</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;Initial: a.strong_count = &#123;&#125;, a.weak_count = &#123;&#125;, b.strone_count = &#123;&#125;, b.weak_count = &#123;&#125;&quot;</span>,</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">    Rc::<span class="title function_ invoke__">weak_count</span>(&amp;a),</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b),</span><br><span class="line">    Rc::<span class="title function_ invoke__">weak_count</span>(&amp;b)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next) = a.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">    *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b); <span class="comment">// a 的 next 指向 b，即 a 引用了 b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;a.next: a.strong_count = &#123;&#125;, a.weak_count = &#123;&#125;, b.strone_count = &#123;&#125;, b.weak_count = &#123;&#125;&quot;</span>,</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">    Rc::<span class="title function_ invoke__">weak_count</span>(&amp;a),</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b),</span><br><span class="line">    Rc::<span class="title function_ invoke__">weak_count</span>(&amp;b)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(prev) = b.<span class="title function_ invoke__">prev</span>() &#123;</span><br><span class="line">    *prev.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;a); <span class="comment">// Weak 有值的引用只有通过 Rc::downgrade 生成，Weak::new 是无值的弱引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;b.prev: a.strong_count = &#123;&#125;, a.weak_count = &#123;&#125;, b.strone_count = &#123;&#125;, b.weak_count = &#123;&#125;&quot;</span>,</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">    Rc::<span class="title function_ invoke__">weak_count</span>(&amp;a),</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b),</span><br><span class="line">    Rc::<span class="title function_ invoke__">weak_count</span>(&amp;b)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a); <span class="comment">// Weak 需要使用 upgrade 方法后才能访问真实数据，因此 Weak 会阻断循环强引用的生成</span></span><br></pre></td></tr></table></figure><p>Weak 需要使用 <code>upgrade</code> 方法后才能访问真实数据，因此 Weak 会阻断循环强引用的生成。</p><p>除了树类型数据结构，还有所属关系的数据结构容易引起循环引用，比如杯子与所属人的关系，一个人可以有多个杯子，一个杯子属于一个人。<br>在这种设计下，可以将人属性中的杯子属性设置为 Weak 或者把杯子中的所有人属性设置为 Weak。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Owner</span> &#123;</span><br><span class="line">    id: <span class="type">i32</span>,</span><br><span class="line">    <span class="comment">// RefCell&lt;Vec&lt;Weak&lt;Cup&gt;&gt;&gt; 比 Vec&lt;RefCell&lt;Weak&lt;Cup&gt;&gt;&gt; 更好的在于可以直接借用一整个vec，就可以修改vec内的元素。不需要单独借用再修改</span></span><br><span class="line">    cups: RefCell&lt;<span class="type">Vec</span>&lt;Weak&lt;Cup&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cup</span> &#123;</span><br><span class="line">    id: <span class="type">i32</span>,</span><br><span class="line">    owner: RefCell&lt;Rc&lt;Owner&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rc::clone(&amp;owner)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">owner</span> = Rc::<span class="title function_ invoke__">new</span>(Owner &#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    cups: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">cup1</span> = Rc::<span class="title function_ invoke__">new</span>(Cup &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    owner: RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;owner)),</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">cup2</span> = Rc::<span class="title function_ invoke__">new</span>(Cup &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    owner: RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;owner)),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;Initial: owner.strong_count = &#123;&#125;, owner.weak_count = &#123;&#125;, \ncup1.strong_count = &#123;&#125;, cup1.weak_count = &#123;&#125;, \ncup2.strong_count = &#123;&#125;, cup2.weak_count = &#123;&#125;&quot;</span>,</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;owner),</span><br><span class="line">    Rc::<span class="title function_ invoke__">weak_count</span>(&amp;owner),</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;cup1),</span><br><span class="line">    Rc::<span class="title function_ invoke__">weak_count</span>(&amp;cup1),</span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;cup2),</span><br><span class="line">    Rc::<span class="title function_ invoke__">weak_count</span>(&amp;cup2),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">*owner.cups.<span class="title function_ invoke__">borrow_mut</span>() = <span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">downgrade</span>(&amp;cup1), Rc::<span class="title function_ invoke__">downgrade</span>(&amp;cup2)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, owner);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">cup</span> <span class="keyword">in</span> owner.cups.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> cup.<span class="title function_ invoke__">upgrade</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;x:?&#125;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;当前引用失效&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unsafe-解决循环引用"><a href="#unsafe-解决循环引用" class="headerlink" title="unsafe 解决循环引用"></a>unsafe 解决循环引用</h3><p>除了 Weak，还可以使用 unsafe 操作来解决循环引用问题。<br>虽然 unsafe 不安全，但是在各种库的代码中依然很常见用它来实现自引用结构，主要优点如下:</p><ul><li>性能高，毕竟直接用裸指针操作</li><li>代码更简单更符合直觉: 对比下 <code>Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;</code></li></ul><p>阅读：<a href="https://course.rs/advance/circle-self-ref/circle-reference.html#unsafe-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">https://course.rs/advance/circle-self-ref/circle-reference.html#unsafe-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Rc 与 RefCell 组合的新类型非常好用，但是这种类型容易引起循环强引用，进而引发 OOM，这属于运行时的 panic。</li><li><strong>循环引用的存在不一定会引起问题</strong>，只有使用到循环引用时才会触发 OOM。</li><li>有效的 Weak 是通过 <code>Rc::downgrade</code> 生成的，因为访问 Weak 指向的数据需要通过 <code>Rc::upgrade</code>，所以在循环引用中，可以用 Weak 来阻断循环强引用的生成。</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">        Nil,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">node</span> = List::<span class="title function_ invoke__">Cons</span>(<span class="number">12</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(List::Nil)));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> &amp;node &#123;</span><br><span class="line">        List::<span class="title function_ invoke__">Cons</span>(v, next) =&gt; &#123;</span><br><span class="line">            <span class="comment">// next 原有的指针信息是指向 List::Nil 的，现在指向 List::Cons(20, RefCell::new(Rc::new(List::Nil)));</span></span><br><span class="line">            <span class="comment">// 此时是存储的指针信息发生改变，而不是存储空间发生改变</span></span><br><span class="line">            *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">new</span>(List::<span class="title function_ invoke__">Cons</span>(<span class="number">20</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(List::Nil))))</span><br><span class="line">        &#125;</span><br><span class="line">        List::Nil =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义取出节点的下一节点的方法，不拿走下一节点的所有权，即只拿引用，又因为下一节点是RefCell类型，所以可以只拿不可变引用就能得到可变引用</span></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">tail</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">                List::<span class="title function_ invoke__">Cons</span>(_, next) =&gt; <span class="title function_ invoke__">Some</span>(next),</span><br><span class="line">                List::Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// - 创建 a，创建 b，利用 `Rc::clone(&amp;b)` 让 a 的 next 指向 b，即 a 引用了 b</span></span><br><span class="line">    <span class="comment">// - 利用 `Rc::clone(&amp;a)` 让 b 的 next 指向 a，即 b 引用了 a</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(List::<span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(List::Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(List::<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(List::Nil))));</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;Initial: a.strone_count = &#123;&#125;, b.strone_count = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next) = a.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b); <span class="comment">// a 的 next 指向 b，即 a 引用了 b</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;a.next: a.strone_count = &#123;&#125;, b.strone_count = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next) = b.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;a); <span class="comment">// b 的 next 指向 a，即 b 引用了 a</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;b.next: a.strone_count = &#123;&#125;, b.strone_count = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功创建了循环引用a-&gt; b -&gt; a -&gt; b ····</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环引用，造成8MB的主线程栈溢出</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, a.tail());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于多出一种 Weak 类型，当前的List不满足使用，需要拓展字段。同时有可能需要修改前一个节点的值，所以用 `RefCell` 包裹</span></span><br><span class="line">    <span class="comment">// 利用枚举创建一个空值类型，避免结构体没有空值的问题</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// value, prev, next</span></span><br><span class="line">        <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Weak&lt;Node&gt;&gt;, RefCell&lt;Rc&lt;Node&gt;&gt;),</span><br><span class="line">        Nil,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;Node&gt;&gt;&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">                Node::<span class="title function_ invoke__">Cons</span>(_, _, next) =&gt; <span class="title function_ invoke__">Some</span>(next),</span><br><span class="line">                Node::Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">prev</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Weak&lt;Node&gt;&gt;&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">                Node::<span class="title function_ invoke__">Cons</span>(_, prev, _) =&gt; <span class="title function_ invoke__">Some</span>(prev),</span><br><span class="line">                Node::Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  使用 Rc 指向下一个节点，使用 Weak 指向上一个节点，避免循环强引用陷阱</span></span><br><span class="line">    <span class="comment">// - 创建 a，创建 b，利用 `Rc::clone(&amp;b)` 让 a 的 next 指向 b，即 a 引用了 b</span></span><br><span class="line">    <span class="comment">// - 利用 `Rc::downgrade(&amp;a)` 让 b 的 prev 指向 a，即 b 弱引用了 a</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">Cons</span>(</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Node::Nil)),</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">Cons</span>(</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Node::Nil)),</span><br><span class="line">    ));</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;Initial: a.strong_count = &#123;&#125;, a.weak_count = &#123;&#125;, b.strone_count = &#123;&#125;, b.weak_count = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;a),</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;b)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next) = a.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        *next.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b); <span class="comment">// a 的 next 指向 b，即 a 引用了 b</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;a.next: a.strong_count = &#123;&#125;, a.weak_count = &#123;&#125;, b.strone_count = &#123;&#125;, b.weak_count = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;a),</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;b)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(prev) = b.<span class="title function_ invoke__">prev</span>() &#123;</span><br><span class="line">        *prev.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;a); <span class="comment">// Weak 有值的引用只有通过 Rc::downgrade 生成，Weak::new 是无值的弱引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;b.prev: a.strong_count = &#123;&#125;, a.weak_count = &#123;&#125;, b.strone_count = &#123;&#125;, b.weak_count = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;a),</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;b)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a); <span class="comment">// Weak 需要使用 upgrade 方法后才能访问真实数据，因此 Weak 会阻断循环强引用的生成</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Owner</span> &#123;</span><br><span class="line">        id: <span class="type">i32</span>,</span><br><span class="line">        <span class="comment">// RefCell&lt;Vec&lt;Weak&lt;Cup&gt;&gt;&gt; 比 Vec&lt;RefCell&lt;Weak&lt;Cup&gt;&gt;&gt; 更好的在于可以直接借用一整个vec，就可以修改vec内的元素。不需要单独借用再修改</span></span><br><span class="line">        cups: RefCell&lt;<span class="type">Vec</span>&lt;Weak&lt;Cup&gt;&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Cup</span> &#123;</span><br><span class="line">        id: <span class="type">i32</span>,</span><br><span class="line">        owner: RefCell&lt;Rc&lt;Owner&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rc::clone(&amp;owner)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">owner</span> = Rc::<span class="title function_ invoke__">new</span>(Owner &#123;</span><br><span class="line">        id: <span class="number">0</span>,</span><br><span class="line">        cups: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cup1</span> = Rc::<span class="title function_ invoke__">new</span>(Cup &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        owner: RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;owner)),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cup2</span> = Rc::<span class="title function_ invoke__">new</span>(Cup &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        owner: RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;owner)),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;Initial: owner.strong_count = &#123;&#125;, owner.weak_count = &#123;&#125;, \ncup1.strong_count = &#123;&#125;, cup1.weak_count = &#123;&#125;, \ncup2.strong_count = &#123;&#125;, cup2.weak_count = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;owner),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;owner),</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;cup1),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;cup1),</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;cup2),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;cup2),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    *owner.cups.<span class="title function_ invoke__">borrow_mut</span>() = <span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">downgrade</span>(&amp;cup1), Rc::<span class="title function_ invoke__">downgrade</span>(&amp;cup2)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, owner);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">cup</span> <span class="keyword">in</span> owner.cups.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">match</span> cup.<span class="title function_ invoke__">upgrade</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(x) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;x:?&#125;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;当前引用失效&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 内部可变性的 Cell 与 RefCell</title>
      <link href="/2024/05/19/rust-%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%E7%9A%84-Cell-%E4%B8%8E-RefCell/"/>
      <url>/2024/05/19/rust-%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%E7%9A%84-Cell-%E4%B8%8E-RefCell/</url>
      
        <content type="html"><![CDATA[<h2 id="内部可变性的-Cell-与-RefCell"><a href="#内部可变性的-Cell-与-RefCell" class="headerlink" title="内部可变性的 Cell 与 RefCell"></a>内部可变性的 Cell 与 RefCell</h2><p>Rust 通过严格的规则来保证所有权和借用的正确性，这带来安全提升的同时，损失了灵活性，比如结构体可变必须要求结构体所有字段可变。</p><p>这是由于 Rust 的 mutable 特性，一个结构体中的字段，要么全都是 immutable，要么全部是 mutable，<strong>不支持针对部分字段进行设置</strong>。<br>比如，在一个 struct 中，可能只有个别的字段需要修改，其他字段并不需要修改，为了一个字段而将整个 struct 变为 <code>&amp;mut</code> 是不合理的。</p><p>rust 提供实现了<strong>内部可变性</strong> Cell 和 RefCell 解决这类问题，通过<strong>内部可变性</strong>可以实现 struct 部分字段可变，而不用将整个 struct 设置为 mutable。</p><blockquote><p>内部可变性的实现是因为 Rust 使用了 unsafe 来做到这一点，但是对于使用者来说，这些都是透明的，因为这些不安全代码都被封装到了安全的 API 中。<br>简而言之，<strong>可以在拥有不可变引用的同时修改目标数据</strong>。</p></blockquote><h3 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h3><p>Cell 和 RefCell 在功能上没有区别，区别在于 <code>Cell&lt;T&gt;</code> 适用于 T 实现 Copy 特征的情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  use std::cell::Cell;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s_cell</span> = Cell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = s_cell.<span class="title function_ invoke__">get</span>(); <span class="comment">// 获取内部数据</span></span><br><span class="line">s_cell.<span class="title function_ invoke__">set</span>(<span class="string">&quot;Hi&quot;</span>); <span class="comment">// 不可变引用直接修改内部数据</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s_cell:?&#125;, &#123;s&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码展示了 Cell 的基本用法，有几点值得注意：</p><ul><li>“Hello World” 是 <code>&amp;str</code> 类型，它实现了 Copy 特征</li><li>get 用来取值，set 用来设置新值</li></ul><p>取到值保存在 s 变量后，还能同时进行修改，这个违背了 Rust 的借用规则，但是由于实现了内部可变性的结构体 Cell 的存在，可以优雅地做到用不可变引用修改目标数据。</p><p>Cell 适用于实现 Copy 的类型，如果尝试在 Cell 中存放 String，编译器会立刻报错，这是因为 <code>String</code> 没有实现 Copy 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = Cell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;asdf&quot;</span>)); 错误，<span class="type">String</span>没有实现<span class="built_in">Copy</span>特征</span><br></pre></td></tr></table></figure><p>如果是自定义的结构体实现，会发现 safe 代码中不能实现在拥有不可变引用的情况下修改数据。因为这与方法接收者的类型不一致，不可变引用不能调用可变引用的方法（点操作符的隐式转换）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCell</span>&lt;T: <span class="built_in">Copy</span>&gt; &#123;</span><br><span class="line">    value: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span>&gt; MyCell&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(v: T) <span class="punctuation">-&gt;</span> MyCell&lt;T&gt; &#123;</span><br><span class="line">        MyCell &#123; value: v &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">set</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, v: T) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">my_cell</span> = MyCell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">my_cell.<span class="title function_ invoke__">set</span>(<span class="string">&quot;Hi&quot;</span>); 错误，set函数 `<span class="title function_ invoke__">set</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, v: T)` 要求接收者是可变引用 `<span class="keyword">self</span>: &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>`，而此时的 `my_cell` 是一个不可变引用。</span><br></pre></td></tr></table></figure><h4 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h4><p>Cell 通过内部的 <code>get set</code> 方法完成数据的获取和替换，即 <code>get</code> 提供不可变引用功能（读），<code>get set</code> 提供可变引用（读写）</p><h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h3><p>在实际开发中，程序操作的更多是一个复杂数据类型，如多字段深层结构体。Cell 适用于 实现了 Copy 特征的类型，显然当复杂类型没有实现 Copy 时就需要另外一个内部可变性的工具来代替 Cell。<br>rust 针对复杂数据类型（未实现 Copy）提供实现了内部可变性的 <code>RefCell</code>。</p><p><strong>RefCell 的功能是通过 unsafe 操作，为一个类型（变量&#x2F;值）对外提供该类型的不可变引用和可变引用，无论这个类型（变量&#x2F;值）是否可变</strong>。由于是 unsafe 的实现，不受借用规则限制。</p><p>对外暴露的不可变引用和可变引用操作是<strong>有限制</strong>的，必须要符合借用规则。<br>RefCell 关注点在为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，这里是 unsafe 的实现，不受借用规则限制。<br>接收不可变引用和可变引用的变量不属于 RefCell 的关注点，它们依然要符合借用规则，以保证 RefCell 智能指针的正常运行。<br>RefCell 会在内部记录不可变引用（borrow 方法）和可变引用（borrow_mut 方法）的使用次数，通过<strong>使用次数来判断此时是否符合借用规则</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **RefCell 的功能是通过 unsafe 操作，为一个类型（变量/值）对外提供该类型的不可变引用和可变引用，无论这个类型（变量/值）是否可变**。</span></span><br><span class="line"><span class="comment">// RefCell 会在内部记录不可变引用（borrow）和可变引用（borrow_mut）的使用次数，通过使用次数来判断此时是否符合借用规则</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow</span>(); <span class="comment">// RefCell 记录一次不可变引用，不可变引用是1，可变引用是0，符合借用规则，正常运行</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow</span>(); <span class="comment">// RefCell 记录一次不可变引用，不可变引用是2，可变引用是0，符合借用规则，正常运行</span></span><br><span class="line"><span class="comment">// let s2 = s.borrow_mut(); // RefCell 记录一次可变引用，不可变引用是2，可变引用是1，此时会报错，因为不能同时存在不可变引用和可变引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow_mut</span>(); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行</span></span><br><span class="line"><span class="comment">// let s2 = s.borrow_mut(); // RefCell 记录一次可变引用，不可变引用是0，可变引用是2，此时会报错，因为不能同时存在多个可变引用（一个可变引用周期内存在另外一个可变引用）</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">*s.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">*s.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>也就是 RefCell 实际上<strong>没有解决可变引用和引用可以共存的问题</strong>。<br>它的关注点在于为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，这里是 <strong>unsafe</strong> 的实现，不受借用规则限制。<br>所以 RefCell 只是绕过了编译期的错误，将报错从编译期推迟到运行时，从编译器错误变成了 panic 异常。</p><h4 id="为什么需要-RefCell？"><a href="#为什么需要-RefCell？" class="headerlink" title="为什么需要 RefCell？"></a>为什么需要 RefCell？</h4><p>既然没有解决问题，为什么还需要 RefCell？这是因为复杂类型的不可变与可变性。<br>由于 Rust 的 mutable 特性，一个结构体中的字段，要么全都是 immutable，要么全部是 mutable，<strong>不支持针对部分字段进行设置</strong>。<br>比如，在一个 struct 中，可能只有个别的字段需要修改，其他字段并不需要修改，为了一个字段而将整个 struct 变为 <code>&amp;mut</code> 是不合理的。</p><p>而 RefCell 通过 unsafe 操作，可以为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，只需要接收的变量遵守借用规则就不会出现运行时错误。</p><p>这意味着可以<strong>通过 RefCell 让一个结构体既有不可变字段，也有可变字段</strong>，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 RefCell，让一个结构体既有不可变字段，也有可变字段</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: RefCell&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">    name: RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;L&quot;</span>)),</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// p.age = 22; 错误的，如果需要age可更改，需要p是可变的。</span></span><br><span class="line">*p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;M&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">*p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;N&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;p:?&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>对于大型的复杂程序，可以选择使用 RefCell 来让事情简化。例如在 Rust 编译器的 ctxt 结构体中有大量的 RefCell 类型的 map 字段，主要的原因是：这些 map 会被分散在各个地方的代码片段所广泛使用或修改。由于这种分散在各处的使用方式，导致了管理可变和不可变成为一件非常复杂的任务（甚至不可能），你很容易就碰到编译器抛出来的各种错误。而且 RefCell 的运行时错误在这种情况下也变得非常有用：一旦有人做了不正确的使用，代码会 panic，然后告诉我们哪些借用冲突了。</p><p>总之，当有一个复杂类型，既有可变又有不可变，又或者需要被到处使用和修改然后导致借用关系难以管理时，都可以优先考虑使用 RefCell。</p><h4 id="RefCell-总结"><a href="#RefCell-总结" class="headerlink" title="RefCell 总结"></a>RefCell 总结</h4><ul><li>RefCell 适用 Copy 和非 Copy 类型，一般来说 Copy 类型可直接选择 Cell</li><li>RefCell 只是绕过编译期的借用规则，程序运行期没有绕过</li><li>RefCell 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时</li><li>使用 RefCell 时，<code>borrow</code> 和 <code>borrow_mut</code> 提供不可变引用和可变引用不能违背借用规则，否则会导致运行期的 panic</li><li>RefCell 通过 unsafe 操作，可以为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，由于是 unsafe 操作，编译时期 <code>borrow(不可变借用)</code> 和 <code>borrow_mut(可变借用)</code> 方法内部实现不受借用规则的限制，所以编译不会报错。但是两个方法的接收者变量不是 unsafe 操作，接收者会受到借用规则的限制，RefCell 智能指针在运行时会记录不可变借用和可变借用的次数，如果方法接收者变量不符合借用规则，则会 panic。</li></ul><h3 id="选择-Cell-还是-RefCell"><a href="#选择-Cell-还是-RefCell" class="headerlink" title="选择 Cell 还是 RefCell"></a>选择 Cell 还是 RefCell</h3><ul><li>RefCell 适用 Copy 和非 Copy 类型，一般来说 Copy 类型可直接选择 Cell</li><li>Cell 通过内部的 <code>get set</code> 方法完成数据的获取和替换，即 <code>get</code> 提供不可变引用功能（读），<code>get set</code> 提供可变引用（读写）</li><li>RefCell 通过 unsafe 操作，可以为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，由于是 unsafe 操作，编译时期 <code>borrow(不可变借用)</code> 和 <code>borrow_mut(可变借用)</code> 方法内部实现不受借用规则的限制，所以编译不会报错。但是两个方法的接收者变量不是 unsafe 操作，接收者会受到借用规则的限制，RefCell 智能指针在运行时会记录不可变借用和可变借用的次数，如果方法接收者变量不符合借用规则，则会 panic。</li><li>Cell 没有额外的性能损耗，RefCell 有一点运行期开销，原因是它包含了一个字节大小的“借用状态”指示器，该指示器在每次运行时借用时都会被修改，进而产生一点开销。</li></ul><p>总之，当需要使用内部可变性时，首选 Cell，只有类型没有实现 Copy 特征时，再选择 RefCell。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code snipet 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = Cell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span> = &amp;x;</span><br><span class="line">x.<span class="title function_ invoke__">set</span>(<span class="number">2</span>);</span><br><span class="line">y.<span class="title function_ invoke__">set</span>(<span class="number">3</span>);</span><br><span class="line">z.<span class="title function_ invoke__">set</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">get</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// code snipet 2 编译失败，原因是不能对基础类型取引用</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span> = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">*y = <span class="number">3</span>;</span><br><span class="line">*z = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure><h3 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h3><p>Cell 与 RefCell 具有内部可变性，何为内部可变性？简单来说，<strong>对一个不可变的值进行可变借用</strong>。具体到 Cell 和 RefCell：</p><ul><li>Cell 通过内部的 <code>get set</code> 方法完成数据的获取和替换，即 <code>get</code> 提供不可变引用功能（读），<code>get set</code> 提供可变引用（读写）</li><li>RefCell 通过 unsafe 操作，可以为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，由于是 unsafe 操作，编译时期 <code>borrow(不可变借用)</code> 和 <code>borrow_mut(可变借用)</code> 方法内部实现不受借用规则的限制，所以编译不会报错。但是两个方法的接收者变量不是 unsafe 操作，接收者会受到借用规则的限制，RefCell 智能指针在运行时会记录不可变借用和可变借用的次数，如果方法接收者变量不符合借用规则，则会 panic。</li></ul><p>内部可变性并不符合 Rust 的基本借用规则：<strong>不能对一个不可变的值进行可变借用</strong>，这会破坏 Rust 的安全性保证。<br>这是因为当值不可变时，可能会有多个不可变的引用指向它，此时若将其中一个修改为可变的，会造成可变引用与不可变引用共存的情况，这可能会造成未定义的行为。</p><p>相反，可以对一个可变值进行不可变借用，根据借用规则只允许一个借用存在，所以当值可变时，最多只会有一个可变引用指向它，将其修改为不可变，那么最终依然是只有一个不可变的引用指向它。</p><p>Rust 的借用规则是内存安全的保证基石，但是有些场景遵守借用规则会非常麻烦，比如由于 Rust 的 mutable 特性，一个结构体中的字段，要么全都是 immutable，要么全部是 mutable，<strong>不支持针对部分字段进行设置</strong>。</p><p>比如；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 RefCell，让一个结构体既有不可变字段，也有可变字段</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: RefCell&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">    name: RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;L&quot;</span>)),</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// p.age = 22; 错误的，如果需要age可更改，需要p是可变的。</span></span><br><span class="line">*p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;M&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">*p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;N&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;p:?&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果需要修改 age 则需要将整个 Person 设置为可变，这种行为不合理。</p><p>又比如为自定义结构体实现外部特征，外部特征的方法接收者为 <code>self: &amp;Self</code> 时：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在外部库中的特征，不能直接修改</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: <span class="type">String</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的数据结构和实现（消息队列结构体）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MsgQueue</span> &#123;</span><br><span class="line">    msg_cache: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自定义数据结构实现外部特征</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MsgQueue</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.msg_cache.<span class="title function_ invoke__">push</span>(msg) <span class="comment">// 报错，因为接收者 self 的类型是不可变引用，不能通过不可变引用修改值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为接收者 self 的类型是不可变引用，<strong>不能通过不可变引用修改值</strong>，所以上述代码编译就会报错。<br>并且由于实现的是<strong>外部特征，不能直接修改方法签名</strong>，此时就依靠 <code>RefCell</code> 的内部可变性为不可变值提供可变引用，进而修改：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在外部库中的特征，不能直接修改</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: <span class="type">String</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的数据结构和实现（消息队列结构体），用 RefCell 为一个无论是否可变的类型（变量/值），**对外提供该类型的不可变引用和可变引用**</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MsgQueue</span> &#123;</span><br><span class="line">    msg_cache: RefCell&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自定义数据结构实现外部特征</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MsgQueue</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: <span class="type">String</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译正常，虽然接收者 self 的类型是不可变引用，但 msg_cache 通过内部可变性提供了可变引用。</span></span><br><span class="line">        <span class="comment">// 此外，运行正常，RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则正常运行。</span></span><br><span class="line">        <span class="keyword">self</span>.msg_cache.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 RefCell 为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>，解决了 <code>&amp;self</code> 不能通过不可变引用改变值的问题。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当遇到需要通过不可变引用修改数据，或者需要被到处使用和修改然后导致借用关系难以管理时，就可以考虑内部可变性的 Cell 和 RefCell。</p><h3 id="内部可变性注意事项"><a href="#内部可变性注意事项" class="headerlink" title="内部可变性注意事项"></a>内部可变性注意事项</h3><p>Cell 与 RefCell 的可变借用行为并不完全一致，这是由于存储的数据类型不一样决定的：<br>Cell 和 RefCell 都是智能指针，用一个栈上的新空间存储被管理的值，不同的是 Cell 存储 Copy 类型的值，而 RefCell 存储的是非 Copy 类型的栈上指针信息（通过栈上指针信息管理堆上实际数据）。</p><p>这种结构决定 Cell 和 RefCell 两者一个相同点和一个不同点：</p><ul><li>相同点：<strong>Cell 和 RefCell 存储被管理值的空间地址是不发生改变的</strong>，即存储值的空间地址不变，但地址对应的空间所存储的内容可以改变。<br>这就是为什么称为内部可变性而不是整体可变的原因。再深层研究会发现，如果整体可变，意味着空间大小不确定，就会违反 rust 不允许直接使用动态尺寸类型的规定。<br>这个性质决定了 Cell 不能存储不同的类型，而 RefCell 得通过指针引用的形式（固定尺寸）才能指向不同的类型（因为转换成固定尺寸类型，这些类型也可能会丢失部分信息的，参考不定长转换章节）。</li><li>不同点：可变借用行为不完全一致：Cell 不会改变原有变量的值，而 RefCell 会改变原有变量的值</li></ul><p><strong>相同点</strong></p><p>RefCell 有一个经典的例子：<code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 和 <code>RefCell&lt;Rc&lt;T&gt;&gt;</code>。</p><ul><li><code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 类型是一个通过 Rc 可供多个变量引用，通过 RefCell 可提供不可变&#x2F;可变借用的高级类型，也就是每个该类型的变量都可单独读写真实数据。</li><li><code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 类型也是一个内部可变性的高级类型，不仅可以提供不可变&#x2F;可变借用和无需手动管理复杂的生命周期，**<code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 还能通过 <code>Rc</code> 智能指针（多套一层）指向 T 类型的不同实例**，<code>RefCell&lt;T&gt;</code> 只能指向 T 类型的一个实例，因为这是内部可变性，而不是整体可变。</li></ul><p>由于内部可变性的限制，存储被管理值的空间地址是不发生改变的。<code>RefCell&lt;T&gt;</code> 只能指向同一数据地址，而通过 <code>Rc</code> 智能指针，<code>RefCell&lt;Rc&lt;T&gt;&gt;</code> 解决了这个问题，可以指向同一类型的不同的实例。</p><p><strong>不同点</strong></p><p>用于 Copy 的 Cell，Cell 不会修改原有变量的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  use std::cell::Cell;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;num);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">num_cell</span> = Cell::<span class="title function_ invoke__">new</span>(num);</span><br><span class="line">num_cell.<span class="title function_ invoke__">set</span>(<span class="number">18</span>); <span class="comment">// Copy 不会修改原有变量的值</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;num_cell:?&#125;, &#123;num&#125;&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;num);</span><br></pre></td></tr></table></figure><p>用于非 Copy 的 RefCell，RefCell 的内部可变性是指当前<strong>变量&#x2F;值的空间存储的内容发生改变</strong>的行为，RefCell 会改变原有变量的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = Person &#123;</span><br><span class="line">    name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>),</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;p);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p_cell</span> = RefCell::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">mut</span> p);</span><br><span class="line">p_cell.<span class="title function_ invoke__">borrow_mut</span>().name = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, p);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;p);</span><br></pre></td></tr></table></figure><h3 id="Rc-x2F-Arc-RefCell-的组合使用"><a href="#Rc-x2F-Arc-RefCell-的组合使用" class="headerlink" title="Rc&#x2F;Arc + RefCell 的组合使用"></a>Rc&#x2F;Arc + RefCell 的组合使用</h3><p>可以将所有权、借用规则和这些智能指针做一个对比：</p><table><thead><tr><th>Rust 规则</th><th>智能指针带来的额外规则</th></tr></thead><tbody><tr><td>一个数据只有一个所有者</td><td>Rc&#x2F;Arc 让一个数据可以拥有多个所有者</td></tr><tr><td>要么多个不可变借用，要么一个可变借用</td><td>RefCell 实现编译期可变、不可变引用共存</td></tr><tr><td>违背规则导致编译错误</td><td>违背规则导致运行时 panic</td></tr></tbody></table><p><code>Rc/Arc</code> 和 <code>RefCell</code> 合理结合，可以解决 Rust 中严苛的所有权和借用规则带来的某些场景下难使用的问题，甚至某些时候可以达到其他带 GC 的高级语言的程度。</p><ul><li>Rc&#x2F;Arc 智能指针通过引用计数（不可变引用）在符合借用规则的情况下实现一个值可以被多个变量访问。实现原理是：<strong>利用结构体存储底层数据的地址和引用次数</strong>，底层数据（实际类型数据）存放在堆上，结构体（胖指针，智能指针）存储在栈上作为管理信息数据管理实际类型数据。</li><li>RefCell 通过内部 unsafe 操作实现数据的可变性，为一个无论是否可变的类型（变量&#x2F;值），<strong>对外提供该类型的不可变引用和可变引用</strong>。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rc与RefCell的结合使用，可以让rust变得像其他高级语言一样使用变量/值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>)));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">s1.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; ❌&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">s1.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; 2&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s:?&#125;&quot;</span>);</span><br><span class="line">*s2.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s:?&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>两者的结合流程认识 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>：</p><ul><li>RefCell 为一个无论是否可变的类型（变量&#x2F;值）提供不可变引用和可变引用，让数据减少借用规则的影响，让数据更容易被改变</li><li>Rc&#x2F;Arc 为一个类型提供简化的生命周期管理（回收资源），让 rust 的变量达到传统 GC 语言指针引用的便捷<br>Rc&#x2F;Arc 结合 RefCell 后功能上可以看成<strong>减少手动管理生命周期（回收资源）的步骤，并且可以随时获取不可变引用和可变引用的类型</strong>，即能达到传统带 GC 语言变量的程度。</li></ul><h4 id="性能损耗"><a href="#性能损耗" class="headerlink" title="性能损耗"></a>性能损耗</h4><p>功能上 Rc&#x2F;Arc 与 RefCell 的结合可以极大的降低生命周期管理和借用规则的复杂性，并且在性能上，这个组合也是非常高的。<br>大致相当于没有线程安全版本的 C++ std::shared_ptr 指针，事实上，C++ 这个指针的主要开销也在于原子性这个<strong>并发原语</strong>上，毕竟线程安全在哪个语言中开销都不小。</p><h4 id="内存损耗"><a href="#内存损耗" class="headerlink" title="内存损耗"></a>内存损耗</h4><p>Rc&#x2F;Arc 与 RefCell 的结合相当于以下结构体，从对内存的影响来看，仅仅多分配了三个 usize&#x2F;isize，并没有其它额外的负担。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// Rc 数据</span></span><br><span class="line">    strong_count: <span class="type">usize</span>,</span><br><span class="line">    weak_count: <span class="type">usize</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Refcell 数据</span></span><br><span class="line">    borrow_count: <span class="type">isize</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包裹的数据</span></span><br><span class="line">    item: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CPU-损耗"><a href="#CPU-损耗" class="headerlink" title="CPU 损耗"></a>CPU 损耗</h4><p>从 CPU 来看，损耗如下：</p><ul><li>对 Rc<T> 解引用是免费的（编译期自动转换），但是 <code>*</code> 带来的间接取值并不免费</li><li>克隆 Rc<T> 需要将当前的引用计数跟 0 和 usize::Max 进行一次比较，然后将计数值加 1</li><li>释放（drop） Rc<T> 需要将计数值减 1， 然后跟 0 进行一次比较</li><li>对 RefCell 进行不可变借用，需要将 isize 类型的借用计数加 1，然后跟 0 进行比较</li><li>对 RefCell 的不可变借用进行释放，需要将 isize 减 1</li><li>对 RefCell 的可变借用大致流程跟上面差不多，但是需要先跟 0 比较，然后再减 1</li><li>对 RefCell 的可变借用进行释放，需要将 isize 加 1（存疑：为什么不是减 1）</li></ul><p><a href="https://course.rs/advance/smart-pointer/cell-refcell.html#cpu-%E6%8D%9F%E8%80%97">https://course.rs/advance/smart-pointer/cell-refcell.html#cpu-%E6%8D%9F%E8%80%97</a></p><p>其实这些细节不必过于关注，只要知道 CPU 消耗也非常低，甚至编译器还会对此进行进一步优化！</p><h4 id="CPU-缓存-Miss"><a href="#CPU-缓存-Miss" class="headerlink" title="CPU 缓存 Miss"></a>CPU 缓存 Miss</h4><p>唯一需要担心的可能就是这种组合数据结构对于 CPU 缓存是否亲和，这个我们证明，只能提出来存在这个可能性，最终的性能影响还需要在实际场景中进行测试。</p><p>总之，分析这两者组合的性能还挺复杂的，大概总结下：</p><ul><li>从表面来看，它们带来的内存和 CPU 损耗都不大，但是由于 Rc 额外的引入了一次间接取值（<code>*</code>），在少数场景下可能会造成性能上的显著损失</li><li>CPU 缓存可能也不够亲和</li></ul><h3 id="过-Cell-from-mut-解决借用冲突"><a href="#过-Cell-from-mut-解决借用冲突" class="headerlink" title="过 Cell::from_mut 解决借用冲突"></a>过 Cell::from_mut 解决借用冲突</h3><p>使用迭代器时，如果恰巧碰上需要修改迭代器内的数据，就会遇到两种情况，这两种情况都不能通过借用规则的检查：</p><ul><li>不可变引用与可变引用一起使用：<code>iter()</code> 与 修改迭代器数据</li><li>可变引用与可变引用一起使用：<code>iter_mut()</code> 与 修改迭代器数据</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|x| **x &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// nums[i] = *num; 错误的，不能同时使用可变引用与不可变引用</span></span><br><span class="line">    <span class="comment">// i += 1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">filter</span>(|x| **x &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// nums[i] = *num; 错误的，不能同时使用多个可变借用</span></span><br><span class="line">    <span class="comment">// i += 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于迭代器出现的这两个场景，多个不可变引用与不可引用和可变引用同时使用的问题，可以<strong>通过索引解决</strong>，即不使用迭代器就不会出现问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">0</span>..nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">if</span> (nums[j] &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是使用索引就违背迭代器的初衷了，毕竟迭代器会让代码更加简洁。此时可以使用 <code>from_mut</code> 方法来解决这个问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用索引不符合迭代器的初衷，迭代器能够简化代码</span></span><br><span class="line"><span class="comment">// 此时可以通过 `Cell` 解决这个问题，因此 Cell 可以提供 set get 方法设置数据。</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// cell_slice 是一个 Cell 的引用类型，内部元素是切片</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">nums_slice</span> = &amp;<span class="keyword">mut</span> nums[..];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">cell_slice</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// as_slice() 方法返回的是一个不可变的切片，这意味着返回的切片不能被修改，也就是nums不能被修改。</span></span><br><span class="line"><span class="comment">// let cell_slice_ref = Cell::from_mut(&amp;mut nums.as_slice());</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 内部元素是切片引用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">cell_slice_ref</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums.<span class="title function_ invoke__">as_slice</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 nums 中的元素变为 Cell 类型，就能够访问和设置元素数据</span></span><br><span class="line"><span class="comment">// 手动声明形式</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice_nums</span> = <span class="built_in">vec!</span>[Cell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">2</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">3</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">4</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cell::from_mut 与 Cell::as_slice_of_cells 结合生成，两种写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">cell_slice</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice_cell</span> = Cell::<span class="title function_ invoke__">as_slice_of_cells</span>(cell_slice);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice_cell</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]).<span class="title function_ invoke__">as_slice_of_cells</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> slice_cell.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|x| (**x).<span class="title function_ invoke__">get</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    slice_cell[i].<span class="title function_ invoke__">set</span>(num.<span class="title function_ invoke__">get</span>()); <span class="comment">// 通过slice_cell改变nums的数据，避免直接修改nums让不可变引用和可变引用同时存在，导致借用规则检查失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;nums:?&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="内部可变性的-Drop-的流程认识，与-Rc-和-Arc-对比"><a href="#内部可变性的-Drop-的流程认识，与-Rc-和-Arc-对比" class="headerlink" title="内部可变性的 Drop 的流程认识，与 Rc 和 Arc 对比"></a>内部可变性的 Drop 的流程认识，与 Rc 和 Arc 对比</h3><p>在 Rc&#x2F;Arc 中，rust 通过**引用计数 (<code>reference counting</code>)**来简化不可变引用对应值的 Drop 实现。<br>在 Cell&#x2F;RefCell 中，rust 又是通过什么来维护 Drop 的流程？<br>Cell&#x2F;RefCell 的 Drop 流程很简单，与 rust 普通的堆上值是一样的释放流程。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>Cell 与 RefCell 带来了内部可变性这个重要特性，将借用规则的检查从编译期推迟到运行期，但是这个检查并不能被绕过，RefCell 在运行期的报错会造成 panic。</li><li>RefCell 适用于编译器误报或者一个引用被在多个代码中使用、修改以至于难于管理借用关系时，还有就是需要内部可变性时。</li><li>从性能上看，RefCell 由于是非线程安全的，因此无需保证原子性，性能虽然有一点损耗，但是依然非常好，而 Cell 则完全不存在任何额外的性能损耗。</li><li>Rc 跟 RefCell 结合使用可以实现多个所有者共享同一份数据，非常好用，但是潜在的性能损耗也要考虑进去，建议对于热点代码使用时，做好 benchmark。</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//  use std::cell::Cell;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s_cell</span> = Cell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = s_cell.<span class="title function_ invoke__">get</span>(); <span class="comment">// 获取内部数据</span></span><br><span class="line">    s_cell.<span class="title function_ invoke__">set</span>(<span class="string">&quot;Hi&quot;</span>); <span class="comment">// 不可变引用直接修改内部数据</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s_cell:?&#125;, &#123;s&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyCell</span>&lt;T: <span class="built_in">Copy</span>&gt; &#123;</span><br><span class="line">        value: T,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span>&gt; MyCell&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>(v: T) <span class="punctuation">-&gt;</span> MyCell&lt;T&gt; &#123;</span><br><span class="line">            MyCell &#123; value: v &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">set</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, v: T) &#123;</span><br><span class="line">            <span class="keyword">self</span>.value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_cell</span> = MyCell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="comment">// my_cell.set(&quot;Hi&quot;); 错误，set函数 `set(&amp;mut self, v: T)` 要求接收者是可变引用 `self: &amp;mut Self`，而此时的 `my_cell` 是一个不可变引用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// **RefCell 的功能是通过 unsafe 操作，为一个类型（变量/值）对外提供该类型的不可变引用和可变引用，无论这个类型（变量/值）是否可变**。</span></span><br><span class="line">    <span class="comment">// RefCell 会在内部记录不可变引用（borrow）和可变引用（borrow_mut）的使用次数，通过使用次数来判断此时是否符合借用规则</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow</span>(); <span class="comment">// RefCell 记录一次不可变引用，不可变引用是1，可变引用是0，符合借用规则，正常运行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow</span>(); <span class="comment">// RefCell 记录一次不可变引用，不可变引用是2，可变引用是0，符合借用规则，正常运行</span></span><br><span class="line">                         <span class="comment">// let s2 = s.borrow_mut(); // RefCell 记录一次可变引用，不可变引用是2，可变引用是1，此时会报错，因为不能同时存在不可变引用和可变引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">borrow_mut</span>(); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行</span></span><br><span class="line">                             <span class="comment">// let s2 = s.borrow_mut(); // RefCell 记录一次可变引用，不可变引用是0，可变引用是2，此时会报错，因为不能同时存在多个可变引用（一个可变引用周期内存在另外一个可变引用）</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = s.<span class="title function_ invoke__">borrow_mut</span>(); <span class="comment">// 给出原始数据的可变引用</span></span><br><span class="line">    *s2 = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;s2); <span class="comment">// 运行成功，无论是编译器还是运行时，都是符合rust的借用规则的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s_ref</span> = RefCell::<span class="title function_ invoke__">new</span>(s);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(s_ref); <span class="comment">// 释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 RefCell，让一个结构体既有不可变字段，也有可变字段</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        name: RefCell&lt;<span class="type">String</span>&gt;,</span><br><span class="line">        age: <span class="type">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;L&quot;</span>)),</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// p.age = 22; 错误的，如果需要age可更改，需要p是可变的。</span></span><br><span class="line">    *p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;M&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">    *p.name.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;N&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;p:?&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rc与RefCell的结合使用，可以让rust变得像其他高级语言一样使用变量/值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    s1.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; ❌&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">    s1.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; 2&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s:?&#125;&quot;</span>);</span><br><span class="line">    *s2.<span class="title function_ invoke__">borrow_mut</span>() = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// RefCell 记录一次可变引用，不可变引用是0，可变引用是1，符合借用规则，正常运行。borrow_mut没有接收者意味着可变引用使用后被释放，可变引用计数归0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s:?&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器时，如果恰巧碰上需要修改迭代器内的数据，就会遇到两种情况：</span></span><br><span class="line">    <span class="comment">// 不可变引用与可变引用一起使用 iter() 与 修改迭代器数据</span></span><br><span class="line">    <span class="comment">// 可变引用与可变引用一起使用 iter_mut() 与 修改迭代器数据</span></span><br><span class="line">    <span class="comment">// 这两种情况都不能通过借用规则的检查</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|x| **x &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// nums[i] = *num; 错误的，不能同时使用可变引用与不可变引用</span></span><br><span class="line">        <span class="comment">// i += 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">filter</span>(|x| **x &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// nums[i] = *num; 错误的，不能同时使用多个可变借用</span></span><br><span class="line">        <span class="comment">// i += 1;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于迭代器出现的这两个场景，多个不可变引用与不可引用和可变引用同时使用的问题，可以通过索引来解决</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">0</span>..nums.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">if</span> (nums[j] &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用索引不符合迭代器的初衷，迭代器能够简化代码</span></span><br><span class="line">    <span class="comment">// 此时可以通过 `Cell` 解决这个问题，因此 Cell 可以提供 set get 方法设置数据。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="comment">// cell_slice 是一个 Cell 的引用类型，内部元素是切片</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nums_slice</span> = &amp;<span class="keyword">mut</span> nums[..];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cell_slice</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as_slice() 方法返回的是一个不可变的切片，这意味着返回的切片不能被修改，也就是nums不能被修改。</span></span><br><span class="line">    <span class="comment">// let cell_slice_ref = Cell::from_mut(&amp;mut nums.as_slice());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 内部元素是切片引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cell_slice_ref</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums.<span class="title function_ invoke__">as_slice</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 nums 中的元素变为 Cell 类型，就能够访问和设置元素数据</span></span><br><span class="line">    <span class="comment">// 手动声明形式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice_nums</span> = <span class="built_in">vec!</span>[Cell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">2</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">3</span>), Cell::<span class="title function_ invoke__">new</span>(<span class="number">4</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cell::from_mut 与 Cell::as_slice_of_cells 结合生成，两种写法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cell_slice</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice_cell</span> = Cell::<span class="title function_ invoke__">as_slice_of_cells</span>(cell_slice);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice_cell</span> = Cell::<span class="title function_ invoke__">from_mut</span>(&amp;<span class="keyword">mut</span> nums[..]).<span class="title function_ invoke__">as_slice_of_cells</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> slice_cell.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|x| (**x).<span class="title function_ invoke__">get</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        slice_cell[i].<span class="title function_ invoke__">set</span>(num.<span class="title function_ invoke__">get</span>()); <span class="comment">// 通过slice_cell改变nums的数据，避免直接修改nums让不可变引用和可变引用同时存在，导致借用规则检查失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;nums:?&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>canvas: measureText 函数与省略号</title>
      <link href="/2024/05/18/canvas-measureText-%E5%87%BD%E6%95%B0%E4%B8%8E%E7%9C%81%E7%95%A5%E5%8F%B7/"/>
      <url>/2024/05/18/canvas-measureText-%E5%87%BD%E6%95%B0%E4%B8%8E%E7%9C%81%E7%95%A5%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>.</p><h2 id="canvas-measureText-函数与省略号"><a href="#canvas-measureText-函数与省略号" class="headerlink" title="canvas: measureText 函数与省略号"></a>canvas: measureText 函数与省略号</h2><p>利用 <code>measureText</code> 可以做 canvas 的省略号功能，代码示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">drawText</span> = (<span class="params">text: <span class="built_in">string</span>, maxWidth: <span class="built_in">number</span>, x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> rawWidth = ctx.<span class="title function_">measureText</span>(text).<span class="property">width</span>;</span><br><span class="line">    <span class="keyword">let</span> textWidth = rawWidth;</span><br><span class="line">    <span class="keyword">while</span> (text &amp;&amp; textWidth &gt; maxWidth) &#123;</span><br><span class="line">        text = text.<span class="title function_">substring</span>(<span class="number">0</span>, text.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">        textWidth = ctx.<span class="title function_">measureText</span>(<span class="string">`<span class="subst">$&#123;text&#125;</span>...`</span>).<span class="property">width</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    text = rawWidth === textWidth ? text : <span class="string">`<span class="subst">$&#123;text&#125;</span>...`</span>;</span><br><span class="line">    ctx.<span class="title function_">fillText</span>(text, x, y);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> canvas </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rust: Rc 与 Arc 引用计数，多个不可变引用的释放管理</title>
      <link href="/2024/05/16/rust-Rc-%E4%B8%8E-Arc-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%8C%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E7%9A%84%E9%87%8A%E6%94%BE%E7%AE%A1%E7%90%86/"/>
      <url>/2024/05/16/rust-Rc-%E4%B8%8E-Arc-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%8C%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E7%9A%84%E9%87%8A%E6%94%BE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Rc-与-Arc-引用计数，多个不可变引用的释放管理"><a href="#Rc-与-Arc-引用计数，多个不可变引用的释放管理" class="headerlink" title="Rc 与 Arc 引用计数，多个不可变引用的释放管理"></a>Rc 与 Arc 引用计数，多个不可变引用的释放管理</h2><p>Rust 所有权机制要求<strong>一个值只能有一个所有者</strong>，在大多数情况下这个设定都没有问题，但是考虑以下情况：</p><ul><li>在图数据结构中，多条边可能会指向（拥有）同一个节点，该节点直到没有边指向它时，才应该被释放清理（多个不可变引用，怎么正确释放）</li><li>在多线程中，多个线程可能会持有同一个数据，但是受限于 Rust 的安全机制，无法同时获取该数据的可变引用（只能存在一个可变引用）</li></ul><p>以上场景不是很常见，但一旦遇到就非常棘手，为了解决此类问题，Rust 在所有权机制外引入了额外的措施**引用计数 (<code>reference counting</code>)**来简化相应的实现（只是简化实现，并不违背所有权的要求）。</p><p><strong>问题明确</strong><br>这一章先用 Rc 与 Arc 智能指针解决由于所有权机制导致维护共享不可变数据（不可变引用）方式非常复杂的问题，维护共享可变数据方式非常复杂的问题由下一章的 Cell 与 RefCell 解决。</p><p><strong>为什么维护共享不可变数据方式非常复杂？</strong><br>维护共享不可变数据方式非常复杂，这个复杂在于一个值存在<strong>多个不可变引用</strong>时，很难确定哪个不可变引用是最后一个使用者。<br>而为了内存安全，rust 又需要找到最后一个使用者（不可变引用），以便在<strong>最后一个使用者销毁时将此时已没有所有者的值一并销毁</strong>。</p><p>除此寻找最后一个使用者外，将不可变引用传递给其他函数，生命周期的标注也是需要注意的。</p><blockquote><p>编译器采用三条规则来判断引用何时不需要明确的标注。第一条规则适用于输入生命周期，第二、三条规则适用于输出生命周期。<br>如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。</p><ol><li><strong>每一个引用参数都有独自的生命周期。</strong><br>例如一个引用参数的函数就有一个生命周期标注: <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32)</code>，两个引用参数的有两个生命周期标注: <code>fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code>, 依此类推。</li><li><strong>若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期</strong>。也就是所有返回值的生命周期都等于该输入生命周期。<br>例如函数 <code>fn foo(x: &amp;i32) -&gt; &amp;i32</code>，x 参数的生命周期会被自动赋给返回值 &amp;i32，因此该函数等同于 <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code>。</li><li><strong>若存在多个输入生命周期，且其中一个是 &amp;self 或 &amp;mut self，则 &amp;self 的生命周期被赋给所有的输出生命周期</strong>。<br>拥有 &amp;self 形式的参数，说明该函数是一个 方法，该规则让方法的使用便利度大幅提升。</li></ol></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存在多个不可变引用时，很难确定哪个不可变引用是最后一个使用者</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = &amp;s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据消除的三条规则，生命周期不能消除隐藏，需要显式标注</span></span><br><span class="line"><span class="comment">// 1. 为每个参数标注生命周期</span></span><br><span class="line"><span class="comment">// 2. 不符合第二条规则</span></span><br><span class="line"><span class="comment">// 3. 不符合第三条规则</span></span><br><span class="line"><span class="comment">// fn display(s1: &amp;String, s2: &amp;String) -&gt; &amp;String &#123;</span></span><br><span class="line"><span class="comment">//     println!(&quot;&#123;s1&#125;, &#123;s2&#125;&quot;);</span></span><br><span class="line"><span class="comment">//     s1</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;, &#123;s2&#125;&quot;</span>);</span><br><span class="line">    s1</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">display</span>(s1, s2);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s4</span> = s2; <span class="comment">// 引用类型实现Copy，所以它的赋值是不会转移所有权，而是复制一份数据</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s2&#125;&quot;</span>); <span class="comment">// 正常访问，没有被转移所有权</span></span><br><span class="line"><span class="title function_ invoke__">drop</span>(s2);</span><br><span class="line"><span class="title function_ invoke__">drop</span>(s); <span class="comment">// 销毁s变量和对应的值</span></span><br><span class="line"><span class="title function_ invoke__">drop</span>(s1); 报错，因为引用的值已经被销毁，现在 s1 指向的是一个空</span><br></pre></td></tr></table></figure><p>很明显，除了复杂的生命周期标注外，很难确定最后一个使用者，只有当最后一个使用者释放时才能将对应的值释放，如果使用的销毁顺序不正确就会导致内存错误。</p><p>针对此类共享不可变数据（不可变引用）问题，引用计数 (<code>reference counting</code>) 通过<strong>记录一个数据被引用的次数</strong>来确定该数据是否正在被使用来解决。<br>当引用次数归零时，就代表该数据不再被使用，可以被清理释放。</p><p>rust 内置的不可变引用的引用计数的实现有 <code>Rc（reference counting）</code> 和 <code>Arc（atomic reference counting）</code> 两种，Rc 适用于单线程，Arc 适用于多线程，在大部分情况下二者的功能都是相同的。</p><h3 id="Rc-lt-T-gt"><a href="#Rc-lt-T-gt" class="headerlink" title="Rc&lt;T&gt;"></a>Rc&lt;T&gt;</h3><p>结构体（智能指针）Rc 的名称正是引用计数的英文缩写，当<strong>需要在堆上分配一个对象供程序的多个部分使用，并且无法确定哪个部分是最后一个结束时（释放）</strong>，<br>就可以使用 Rc 成为<strong>数据值的所有者（具有数据的所有权）</strong>，实现多个不可变引用使用值功能，并且无需关心最后一个使用者释放问题，可以认为 Rc 解决的是引用生命周期的复杂性。<br>因此在不可变引用中这个观点是错误的：<del>通过引用计数的方式，允许一个数据资源在同一时刻拥有<strong>多个所有者</strong></del>，并不是指数据有多个所有者，而是指多个不可变引用。</p><p>使用 Rc 创建一个智能指针：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">strong_count</span>(&amp;r1);</span><br></pre></td></tr></table></figure><p>使用 <code>Rc::new</code> 创建一个 <code>Rc&lt;String&gt;</code> 智能指针并赋给变量 r1，该指针指向底层的字符串数据。<br>智能指针 <code>Rc&lt;T&gt;</code> 在创建时，会将引用计数加 1，引用计数可以通过关联函数 <code>Rc::strong_count</code> 获取，这里关联函数 <code>Rc::strong_count(&amp;r1)</code> 返回 1。</p><p>在不定长类型 DST 和定长类型章节中提到过变量&#x2F;类型的两个关键点：</p><ul><li>不能简单的将变量与类型视为只是一块栈内存或一块堆内存数据，比如 Vec 类型，rust 将其分成两部分数据：存储在堆中的实际类型数据与存储在栈上的管理信息数据。</li><li>其中存储在栈上的管理信息数据是引用类型，包含实际类型数据的地址、元素的数量，分配的空间等信息，<strong>rust 通过栈上的管理信息数据掌控实际类型数据的信息</strong>。</li></ul><p>Rc 智能指针就是一种在堆栈均有存储数据的实现，它的原理是<strong>利用结构体存储底层数据的地址和引用次数</strong>，底层数据（实际类型数据）存放在堆上，结构体（胖指针，智能指针）存储在栈上作为管理信息数据管理实际类型数据。<br>智能指针在复制时，复制的内容是智能指针而不是底层数据，这种复制效率是非常高的。</p><h4 id="Rc-clone"><a href="#Rc-clone" class="headerlink" title="Rc::clone"></a>Rc::clone</h4><p>在使用上，直接通过多个不可变引用的方式在不同的作用域使用同一个值，这种方式需要考虑标注生命周期和最后一个所有者（使用者）的资源释放，非常复杂。<br>而通过智能指针，除了减少声明周期的标注外，语义和资源释放也更加清晰。</p><p>通过多个不可变引用的方式使用同一个值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = &amp;s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;, &#123;s2&#125;&quot;</span>);</span><br><span class="line">    s1</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">display</span>(s1, s2);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s2; <span class="comment">// 引用类型实现Copy，所以它的赋值是不会转移所有权，而是复制一份数据</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s2&#125;&quot;</span>); <span class="comment">// 正常访问，没有被转移所有权</span></span><br></pre></td></tr></table></figure><p>由于 s1 和 s2 是引用类型，引用类型实现了 Copy，所以 display 函数使用 s1 和 s2 时，s1 和 s2 均被复制了一次数据，这也意味着 s1 和 s2 未丢失所有权。</p><p>而 <code>Rc</code> 智能指针语义则会更清晰，因为智能指针是一个结构体，不是引用类型，在转移时需要考虑所有权。<br>Rc 智能指针通过 <code>Rc::clone</code> 复制栈上智能指针数据，虽然是 <code>clone</code>，但它不会复制底层数据。多个 Rc 智能指针让多个变量（不可变引用）都能访问底层的同一份实际数据。<br>与普通的复制相比，<code>Rc::clone</code> 会在<strong>智能指针的引用计数上增加 1</strong>，如果直接转移变量的所有权，引用计数不会改变！</p><p>通过多个 Rc 智能指针的方式访问同一份数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = r1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;r1); <span class="comment">// 等价于 r1.clone()，这是类型的隐式转换。为了语义更加明确，优先使用这种形式</span></span><br><span class="line"><span class="comment">// let s4 = s1; 如果直接转移所有权，s1变量将不能再次使用，并且引用计数不会发生变化！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display_rc</span>(r1: Rc&lt;<span class="type">String</span>&gt;, r2: Rc&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> Rc&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;r1&#125;, &#123;r2&#125;&quot;</span>);</span><br><span class="line">    r1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// display_rc(r1, r2); 直接转移变量的所有权，引用计数不会改变</span></span><br><span class="line"><span class="title function_ invoke__">display_rc</span>(r1.<span class="title function_ invoke__">clone</span>(), r2.<span class="title function_ invoke__">clone</span>()); <span class="comment">// 引用计数增加</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, r1, r2, r3);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;r1));</span><br><span class="line"><span class="title function_ invoke__">drop</span>(r1); <span class="comment">// 释放s1，由于s1是Rc智能指针，有自定义的Drop::drop，因此底层的数据不会改变，只是引用计数减一</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;r2));</span><br></pre></td></tr></table></figure><p><strong>通过多个不可变引用的方式使用同一个值</strong>与<strong>通过多个 Rc 智能指针的方式访问同一份数据</strong>，这两者性能是等价的，因为复制的都是栈上的数据，一份是指针，一份是胖指针。</p><p>Rc 智能指针比直接使用不可变引用的语义明确在于：<br>如果需要增加一个引用，就需要使用 <code>Rc::clone</code>，这样就会自动在智能指针的引用计数上增加 1，而如果直接转移变量所有权，它的副作用是让原有变量失去所有权，引用计数不会发生变化！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">display_rc</span>(r1, r2); 直接转移变量的所有权，引用计数不会改变</span><br><span class="line"><span class="title function_ invoke__">display_rc</span>(r1.<span class="title function_ invoke__">clone</span>(), r2.<span class="title function_ invoke__">clone</span>()); <span class="comment">// 引用计数增加</span></span><br></pre></td></tr></table></figure><h4 id="Rc-strong-count"><a href="#Rc-strong-count" class="headerlink" title="Rc::strong_count"></a>Rc::strong_count</h4><p>智能指针 <code>Rc&lt;T&gt;</code> 的引用计数可以通过关联函数 <code>Rc::strong_count</code> 获取：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;test ref counting&quot;</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> =  Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> =  Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br></pre></td></tr></table></figure><p>有几点值得注意：</p><ul><li>由于变量 c 在语句块内部声明，当离开语句块时它会因为超出作用域而被释放，所以引用计数会减少 1，事实上这个得益于 <code>Rc&lt;T&gt;</code> 实现了 Drop 特征</li><li>a、b、c 三个智能指针引用计数都是同样的，并且共享底层的数据，因此打印计数时用哪个都行</li><li>无法看到的是：当 a、b 超出作用域后，引用计数会变成 0，最终智能指针和它指向的底层字符串都会被清理释放</li></ul><h4 id="Rc-总结"><a href="#Rc-总结" class="headerlink" title="Rc 总结"></a>Rc 总结</h4><ul><li><code>Rc/Arc</code> 是不可变引用，无法修改它指向的值。如果要修改，需要配合后面章节的 RefCell 或互斥锁 Mutex</li><li><code>Rc&lt;T&gt;</code> 是一个智能指针，实现了 Deref 特征，因此可以直接使用 T 而无需先解开 Rc 指针</li><li>一旦 Rc 引用值对应的最后一个拥有者消失，则资源会自动被回收，这个生命周期是在编译期确定的</li><li>Rc 只能用于同一线程内部，想要用于线程之间的对象共享，你需要使用 Arc</li></ul><h3 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a>Arc</h3><p><code>Rc&lt;T&gt;</code> 不能在线程间安全的传递，是因为它没有实现 Send 特征，rust 提供的 Arc 实现了 Send 特征。<br>Arc 是 <code>atomic reference counting</code> 的缩写，它代表着原子化的 <code>Rc&lt;T&gt;</code> 智能指针。原子化是一种并发原语，它能保证数据能够安全的在线程间共享。</p><h4 id="Arc-的性能损耗"><a href="#Arc-的性能损耗" class="headerlink" title="Arc 的性能损耗"></a>Arc 的性能损耗</h4><p>原子化或者其它锁虽然可以带来的线程安全，但是有一定的性能损耗，而且这种性能损耗还不小。<br>这也就是为什么 Rust 的基本数据类型、标准库数据类型并不会自动实现原子化操作，而是交出选择权的原因，毕竟需要线程安全的代码其实占比并不高，大部分时候开发的程序都在一个线程内。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arc 适合在多线程中使用，它能够保证数据线程安全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="comment">// 利用thread创建多线程</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_s</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;s);</span><br><span class="line">    <span class="comment">// 由于线程可以在后台运行，因此要保证后台运行时变量是时刻有效的。需要使用 move 关键字将_s的所有权转移到闭包中，以时刻保证变量有效</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;_s&#125;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于线程可能会在后台运行，因此需要确保闭包中的变量能够在线程执行时仍然有效。通过在闭包中使用 move 关键字，将 Arc 指针所有权转移给闭包，这样就可以确保线程在后台运行时可以继续拥有对 Arc 指针的所有权，而不会造成编译错误或运行时错误。<br>这里的 move 只是<strong>所有权语义的转移</strong>，并不是将变量转移进闭包函数中，再一次理解：组成 rust 变量的不只是内存数据，还包括所有权信息，需要<strong>内存数据+所有权</strong>才能正常使用变量。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 rust 中，所有权机制保证了一个数据只会有一个所有者，但如果要在图数据结构、多线程等场景中共享数据，这种机制会需要高成本的维护。<br>所以通过引用计数 <code>reference counting</code> 的形式，rust 提供了智能指针 Rc 和 Arc，使用它们就能实现多个所有者共享一个数据的功能。</p><p>Rc 和 Arc 的区别在于，后者是原子化实现的引用计数，因此是线程安全的，可以用于多线程中共享数据。<br>这两者都是只读的，如果想要实现内部数据可修改，必须配合内部可变性 RefCell 或者互斥锁 Mutex 来一起使用。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 一个值只能有一个所有者</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1; <span class="comment">// s1 变量失去值的所有权</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s2;</span><br><span class="line">    <span class="comment">// let s3 = s1; s1 已经失去值的所有权，不能再使用没有值所有权的 s1 变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在多个不可变引用时，很难确定哪个不可变引用是最后一个使用者。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据消除的三条规则，生命周期不能消除隐藏，需要显式标注</span></span><br><span class="line">    <span class="comment">// 1. 为每个参数标注生命周期</span></span><br><span class="line">    <span class="comment">// 2. 不符合第二条规则</span></span><br><span class="line">    <span class="comment">// 3. 不符合第三条规则</span></span><br><span class="line">    <span class="comment">// fn display(s1: &amp;String, s2: &amp;String) -&gt; &amp;String &#123;</span></span><br><span class="line">    <span class="comment">//     println!(&quot;&#123;s1&#125;, &#123;s2&#125;&quot;);</span></span><br><span class="line">    <span class="comment">//     s1</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display_str_ref</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;, &#123;s2&#125;&quot;</span>);</span><br><span class="line">        s1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">display_str_ref</span>(s1, s2);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s4</span> = s2;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s2&#125;&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(s2);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(s); <span class="comment">// 销毁s变量和对应的值</span></span><br><span class="line">             <span class="comment">// drop(s1); 报错，因为引用的值已经被销毁，现在 s1 指向的是一个空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = r1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;r1);</span><br><span class="line">    <span class="comment">// let s4 = s1; 如果直接转移所有权，s1变量将不能再使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display_rc</span>(r1: Rc&lt;<span class="type">String</span>&gt;, r2: Rc&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> Rc&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;r1&#125;, &#123;r2&#125;&quot;</span>);</span><br><span class="line">        r1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传递的指针都是被复制了一次，两者性能是等价的。直接传递让原有变量失去所有权</span></span><br><span class="line">    <span class="comment">// display_rc(r1, r2);</span></span><br><span class="line">    <span class="title function_ invoke__">display_rc</span>(r1.<span class="title function_ invoke__">clone</span>(), r2.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, r1, r2, r3);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;r1));</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(r1); <span class="comment">// 释放s1，由于s1是Rc智能指针，有自定义的Drop::drop，因此底层的数据不会改变，只是引用计数减一</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;r2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display_num</span>(a: &amp;<span class="type">i32</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;a&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = &amp;<span class="number">32</span>;</span><br><span class="line">    <span class="title function_ invoke__">display_num</span>(num);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;num&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_2</span> = num;</span><br><span class="line">    <span class="title function_ invoke__">display_num</span>(num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观察引用计数的变化</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;test ref counting&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arc 适合在多线程中使用，它能够保证数据线程安全</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="comment">// 利用thread创建多线程</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_s</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;s);</span><br><span class="line">        <span class="comment">// 由于线程可以在后台运行，因此要保证后台运行时变量是时刻有效的。需要使用 move 关键字将_s的所有权转移到闭包中，以时刻保证变量有效</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;_s&#125;&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css: 常用的css选择规则</title>
      <link href="/2024/05/16/css-%E5%B8%B8%E7%94%A8%E7%9A%84css%E9%80%89%E6%8B%A9%E8%A7%84%E5%88%99/"/>
      <url>/2024/05/16/css-%E5%B8%B8%E7%94%A8%E7%9A%84css%E9%80%89%E6%8B%A9%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="不含有特定子元素的元素"><a href="#不含有特定子元素的元素" class="headerlink" title="不含有特定子元素的元素"></a>不含有特定子元素的元素</h3><p><strong>alias</strong></p><ul><li>某个元素（不包含 | 没有）指定后代</li></ul><p><strong>code</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:not</span>(:<span class="built_in">has</span>( .child )) </span><br><span class="line"><span class="selector-pseudo">:not</span>(&amp;:<span class="built_in">has</span>( .child ))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用 css 选择规则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git: rebase 重复提交问题</title>
      <link href="/2024/05/12/git-rebase-%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/12/git-rebase-%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><p>git rebase 出现重复提交的原因可能是：</p><p>有时候rebase会出现冲突，在解决冲突后可能会错误地再次使用 <code>git add</code> 命令将已经解决冲突的文件添加到暂存区，从而导致相同的提交重复应用到最终的提交历史。</p><p>解决方法：</p><ol><li>可以在解决冲突后，使用<code>git rebase --skip</code>命令跳过当前提交，避免将解决冲突的提交重复应用</li><li>在进行rebase操作之前，先使用<code>git log</code>命令查看提交历史，并使用交互式rebase来删除重复的提交</li></ol><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://geek-docs.com/git/git-questions/1298_git_git_commits_are_duplicated_in_the_same_branch_after_doing_a_rebase.html">https://geek-docs.com/git/git-questions/1298_git_git_commits_are_duplicated_in_the_same_branch_after_doing_a_rebase.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rust: Drop 释放资源</title>
      <link href="/2024/05/08/rust-Drop-%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90/"/>
      <url>/2024/05/08/rust-Drop-%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Drop-释放资源"><a href="#Drop-释放资源" class="headerlink" title="Drop 释放资源"></a>Drop 释放资源</h2><p>在 Rust 中可以指定在一个变量超出作用域时，执行一段特定的代码。<br>这段特定的代码可以由编译器自动插入，这样无需在每一个使用该变量的地方，都写一段代码来手动进行收尾工作和资源释放。<br>指定这样一段收尾工作靠的就是 Drop 特征。</p><p>一个作用域结束时，除返回值外的变量&#x2F;值外，变量和值有两种行为：</p><ul><li>栈上的变量和值，由于函数栈的退出，这些栈上的变量和值都会被销毁</li><li>堆上的变量和值，作用域内声明的被销毁，作用域外声明的保留</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(v: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="keyword">mut</span> MyBox&lt;<span class="type">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="number">1</span>; <span class="comment">// 作用域内的栈上变量和值都被销毁</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, s); <span class="comment">// 作用域外的堆上变量和值被保留</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 作用域内声明的堆上变量和值，包括所有权都会被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_ invoke__">display</span>(&amp;<span class="keyword">mut</span> v);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;v:#?&#125;&quot;</span>); <span class="comment">// 验证离开display函数后，变量所有权未变，值没有被销毁</span></span><br></pre></td></tr></table></figure><p>由于函数栈的退出，栈上的变量（包括外部传入的参数，具有所有权）存储在函数栈上，它被销毁是一定的，为什么作用域内声明的堆上变量被销毁，而作用域外被保留？</p><p>原因就在于 Drop 特征，Drop 特征为这些变量插入了一段收尾工作的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证drop特征自动插入一段收尾工作（销毁）的代码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HasDrop1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HasDrop2</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">HasDrop1</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;HasDrop1 dropping&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">HasDrop2</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;HasDrop2 dropping&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display_drop</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = HasDrop1 &#123;&#125;; <span class="comment">// 变量后被销毁</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = HasDrop2; <span class="comment">// 变量先被销毁</span></span><br><span class="line">    HasDrop1&#123;&#125;; <span class="comment">// 直接销毁</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;display_drop over&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">display_drop</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;main over&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">display_drop over</span><br><span class="line">HasDrop1 dropping</span><br><span class="line">HasDrop2 dropping</span><br><span class="line">HasDrop1 dropping</span><br><span class="line">main over</span><br></pre></td></tr></table></figure><p>display_drop 函数结束时正常自动销毁了 <code>HasDrop1</code> 和 <code>HasDrop2</code>，但注意<strong>销毁变量</strong>的时机是<strong>函数结束</strong>时，顺序是先销毁 HasDrop2，后销毁 HasDrop1，如果值没有变量接收则立即销毁。</p><p>因此<strong>函数内变量的销毁顺序是创建逆序的，先创建后销毁</strong>。如果是结构体中含有结构体（复杂类型），它销毁顺序呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HasDrop3</span> &#123;</span><br><span class="line">     bar: HasDrop2,</span><br><span class="line">     foo: HasDrop1,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">HasDrop3</span> &#123;</span><br><span class="line">     <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">         <span class="built_in">println!</span>(<span class="string">&quot;HasDrop3 dropping&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span> = HasDrop3 &#123; foo: HasDrop1, bar: HasDrop2 &#125;; <span class="comment">// 与struct定义顺序不同</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;main over&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main over</span><br><span class="line">HasDrop3 dropping</span><br><span class="line">HasDrop2 dropping</span><br><span class="line">HasDrop1 dropping</span><br></pre></td></tr></table></figure><p>从输出的顺序可以知道：<strong>结构体内部的销毁顺序是结构体属性定义的顺序</strong>，与创建结构体的字段顺序无关。</p><p>总结：<br>一个作用域结束时，除返回值外的变量&#x2F;值外，变量和值有两种行为：</p><ul><li>栈上的变量和值，由于函数栈的退出，这些栈上的变量和值都会被销毁</li><li>堆上的变量和值，作用域内声明的被销毁，作用域外声明的保留</li></ul><p>堆资源回收的顺序：</p><ul><li><strong>变量级别，按照逆序的方式</strong>，如果 X 在 Y 之前创建，那么 X 在 Y 之后被 drop</li><li><strong>结构体内部，按照顺序的方式</strong>，结构体 X 中的字段按照定义中的顺序依次 drop</li></ul><h3 id="没有实现-Drop-的结构体"><a href="#没有实现-Drop-的结构体" class="headerlink" title="没有实现 Drop 的结构体"></a>没有实现 Drop 的结构体</h3><p>实际上，<strong>Rust 自动为几乎所有的类型实现了 Drop 特征</strong>，因此即使不手动为结构体实现 Drop，它依然会调用默认实现的 drop 函数，同时再调用每个字段的 drop 方法。</p><p>移除 <code>HasDrop3</code> 的 Drop 实现，并再次调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HasDrop3</span> &#123;</span><br><span class="line">     bar: HasDrop2,</span><br><span class="line">     foo: HasDrop1,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span> = HasDrop3 &#123; foo: HasDrop1, bar: HasDrop2 &#125;; <span class="comment">// 与struct定义顺序不同</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;main over&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main over</span><br><span class="line">HasDrop2 dropping</span><br><span class="line">HasDrop1 dropping</span><br></pre></td></tr></table></figure><h3 id="手动销毁"><a href="#手动销毁" class="headerlink" title="手动销毁"></a>手动销毁</h3><blockquote><p>析构函数 destructor：一个用来<strong>清理实例</strong>的通用编程概念，与构造函数对应</p></blockquote><p>Drop 特征是编译器自动插入变量的收尾工作代码，编译器通过 <code>Drop::drop(&amp;mut self)</code> 释放资源。<br>但 Drop 特征有一个特殊限制：**不允许手动调用析构函数 <code>Drop::drop(&amp;mut self)</code>**。</p><p>即实现 Drop 特征的结构体，编译器可以自动插入收尾工作代码（释放资源 Drop::drop），但不允许手动调用 <code>Drop::drop(&amp;mut self)</code> 释放资源。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HasDrop3</span> &#123;</span><br><span class="line">     bar: HasDrop2,</span><br><span class="line">     foo: HasDrop1,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">HasDrop3</span> &#123;</span><br><span class="line">     <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">         <span class="built_in">println!</span>(<span class="string">&quot;HasDrop3 dropping&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">z</span> = HasDrop3 &#123; foo: HasDrop1, bar: HasDrop2 &#125;;</span><br><span class="line"></span><br><span class="line">z.<span class="title function_ invoke__">drop</span>(); 错误代码，不允许直接调用析构函数，等于下一行</span><br><span class="line"><span class="built_in">Drop</span>::<span class="title function_ invoke__">drop</span>(&amp;<span class="keyword">mut</span> z); 错误代码，不允许直接调用析构函数，属于上一行的类型转换</span><br></pre></td></tr></table></figure><p>以上报错是**不允许手动调用析构函数 <code>Drop::drop(&amp;mut self)</code>**引发的，它受到 rust 的所有权模型的限制：</p><p>如果允许手动调用 <code>Drop::drop(&amp;mut self)</code>，<code>Drop::drop(&amp;mut self)</code> 的接收者是 <code>&amp;mut self</code>。<br>因为 <code>&amp;mut self</code> 没有转移变量所有权，所以在手动调用 <code>Drop::drop</code> 释放变量后，编译器根据生命周期检查，发现变量的<strong>所有权未丢失</strong>，这样就会造成两个严重问题：</p><p><strong>1. 可能访问错误数据</strong></p><p>因为手动调用 <code>Drop::drop</code> 释放变量后，编译器根据生命周期检查发现变量所有权未丢失，变量可以正常使用，所以再次访问时，会访问到错误的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">z</span> = HasDrop3 &#123; foo: HasDrop1, bar: HasDrop2 &#125;;</span><br><span class="line">z.<span class="title function_ invoke__">drop</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Running!:&#123;:#?&#125;&quot;</span>, z); 访问错误的数据</span><br></pre></td></tr></table></figure><p><strong>2. 二次析构（释放）</strong></p><p>同样，编译器发现所有权未丢失，变量可以再次使用，且变量实现了 Drop 特征，因此在函数结束时，根据 Drop 特征自动释放变量，造成二次析构。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>() &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">z</span> = HasDrop3 &#123; foo: HasDrop1, bar: HasDrop2 &#125;;</span><br><span class="line">     z.<span class="title function_ invoke__">drop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">display</span>()</span><br></pre></td></tr></table></figure><h4 id="通过-drop-释放"><a href="#通过-drop-释放" class="headerlink" title="通过 drop 释放"></a>通过 drop 释放</h4><p><code>Drop::drop(&amp;mut self)</code> 可以释放资源，但根据所有权模型和生命周期，由于 <code>&amp;mut self</code> 没有转移变量所有权，手动调用会存在许多问题。</p><p>如果希望手动释放资源，<strong>需要转移变量所有权</strong>，让变量不能再使用，即让所有权模型和生命周期正常工作，rust 提供的手动释放函数 <code>mem::drop()</code> 函数非常简单：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">drop</span>&lt;T&gt;(_x: T) &#123;&#125;</span><br></pre></td></tr></table></figure><p>所有权通过参数传入 <code>drop()</code>，然后在 <code>drop()</code> 方法结束时(离开作用域)，调用 <code>Drop()::drop()</code> 释放掉形参（rust 为几乎所有的类型都实现了 Drop 特征），保证堆上的资源被释放。<br>也就是说，并不是 <code>mem::drop()</code> 导致的释放，而是在 <code>mem::drop()</code> 结束时编译器根据 Drop 特征自动插入的收尾工作代码（自动释放）。</p><p>它的核心目的就是把所有权带进来，而不传出来。这样就保证 <code>mem::drop</code> 函数正常释放变量，并且 <code>mem::drop</code> 函数外该变量不能再使用。</p><p>手动做一个 drop 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">z</span> = HasDrop3 &#123;</span><br><span class="line">    foo: HasDrop1,</span><br><span class="line">    bar: HasDrop2,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dropHeap</span>&lt;T&gt;(_v: T) &#123;&#125;</span><br><span class="line"><span class="title function_ invoke__">dropHeap</span>(z);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, z); 错误代码，所有权被 dropHeap 函数转移，不能再使用变量</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://doc.rust-lang.org/std/mem/fn.drop.html">https://doc.rust-lang.org/std/mem/fn.drop.html</a></p><p><a href="https://github.com/sunface/rust-course/pull/1254">https://github.com/sunface/rust-course/pull/1254</a></p><p>事实上，能被显式调用的 <code>drop(_x)</code> 函数只是个空函数，在拿走目标值的所有权后没有任何操作。<br>而由于其持有目标值的所有权，在 <code>drop(_x)</code> 函数结束之际，编译器会执行 <code>_x</code> 真正的析构函数，从而完成释放资源的操作。<br>换句话说，<code>drop(_x)</code> 函数只是帮助目标值的所有者提前离开了作用域。</p></blockquote><h3 id="Drop-drop-amp-mut-self-的-amp-mut-self"><a href="#Drop-drop-amp-mut-self-的-amp-mut-self" class="headerlink" title="Drop::drop(&amp;mut self) 的 &amp;mut self"></a>Drop::drop(&amp;mut self) 的 &amp;mut self</h3><p><code>Drop</code> 特征是 rust 自动清理的来源，它的职责是<strong>执行任何必要的清理逻辑，而不是处理内存释放细节</strong>。</p><p>为什么 <code>Drop()::drop(&amp;mut self)</code> 的接收者是 <code>&amp;mut self</code>，<code>&amp;self</code> <code>self</code> 作为接收者有什么缺陷？</p><blockquote><p><a href="https://www.zhihu.com/question/612370614">https://www.zhihu.com/question/612370614</a></p></blockquote><ol><li>不可能是 <code>&amp;self</code></li></ol><p>要清理结构体内部的数据，必须能具有变量所有权或可变引用才能改变结构体数据，因此只读引用不合适。</p><ol start="2"><li><code>self</code> 不适合</li></ol><p>在上面的提到过：<strong>堆上的变量和值，作用域内声明的被销毁，作用域外声明的保留</strong>。</p><p><code>self</code> 接收者会转移变量的所有权，即相当于在作用域内声明了变量，在函数栈退出时就会被释放：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomStruct</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomStruct</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;drop&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里由于函数栈的退出，当前的 `self` drop，又调用了析构，因此会无限打印&quot;drop&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从示例中可以预测到，将 <code>self: Self</code> 当作接收者，触发流程：</p><ul><li>第一次是外部函数的函数栈退出，调用了析构函数</li><li>第二次开始是析构函数 <code>Drop::drop</code> 的函数栈退出，又调用了析构函数，形成死循环调用</li></ul><p>因此 <code>self: Self</code> 是不适合作为析构函数的接收者，而接收者为 <code>&amp;mut self</code>，可以在清理时方便的修改实例内部的信息。</p><blockquote><p><a href="https://github.com/rtpacks/rust-note/blob/main/docs/unit%2047-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.md#%E7%82%B9%E6%93%8D%E4%BD%9C%E7%AC%A6">https://github.com/rtpacks/rust-note/blob/main/docs/unit%2047-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.md#%E7%82%B9%E6%93%8D%E4%BD%9C%E7%AC%A6</a></p><p><code>Drop::drop(&amp;mut self)</code> 是由 <code>x.drop()</code> 进行了隐式转换得来的。</p></blockquote><h3 id="互斥的-Copy-和-Drop"><a href="#互斥的-Copy-和-Drop" class="headerlink" title="互斥的 Copy 和 Drop"></a>互斥的 Copy 和 Drop</h3><blockquote><p><a href="https://github.com/sunface/rust-course/discussions/749#discussioncomment-3121717">https://github.com/sunface/rust-course/discussions/749#discussioncomment-3121717</a></p></blockquote><p>Drop 特征除了<strong>不允许手动调用析构函数 <code>Drop::drop(&amp;mut self)</code><strong>的限制外，还有一个限制是</strong>一个类型不能同时实现 Copy 特征和 Drop 特征</strong>。</p><p>这是因为实现了 Copy 特征的类型会被编译器隐式的复制，因此非常难以预测析构函数执行的时间和频率，因此这些实现了 Copy 特征的类型无法拥有析构函数。<br>但从根本上理解，<strong>一个类型不能同时实现 Copy 特征和 Drop 特征</strong>，更重要的是<strong>内存安全（资源正确释放）</strong>方面的考虑。</p><p>copy 可以理解为栈内存的简单复制，通常意义上的<strong>浅拷贝（trivial copy）</strong>。</p><p>简单举例：有一个结构体只包含一个指针，这个指针指向分配出来的堆内存，类似智能指针。<br>它实现了 Drop，作用是释放堆上的内存。编译器的工作是在栈上分配类或者结构体，在离开作用域时自动插入析构函数。<br>Copy 特征会在变量赋值时把这个指针复制一遍，这时候就有两个结构体在栈上。<br>结构体离开作用域会调用 drop，这个时候有两个结构体就会调用两遍析构，但是结构体管理的实际资源（堆上的一段内存）只有一个，此时资源就被释放两遍。<br>这是一种内存错误。</p><p>解决方法就是：</p><ol><li>不仅仅复制栈上的结构，我复制这个结构体的时候把资源也复制一份。也就是 clone trait。</li><li>使用智能指针，给资源做一个引用计数，结构体作为引用计数和资源的控制结构。每次出作用域的时候，就检查一遍引用计数，判断此时是否可以释放。</li><li>禁止复制，也就是 move 语义，资源的控制结构只存在一个，这个控制结构拥有所有权。move 语义的赋值其实也是仅仅复制栈上的结构，但是编译器帮我记住现有栈上有效的结构到底是哪一个。要是用错了，就报错。</li><li>有 gc 的，就用 gc 来释放。</li></ol><p>因此，Copy 和 Drop 互斥的最大原因是是在内存安全方面的考虑，而不仅仅因为 Copy 会复制资源。</p><h3 id="Drop-使用场景"><a href="#Drop-使用场景" class="headerlink" title="Drop 使用场景"></a>Drop 使用场景</h3><p>对于 Drop 而言，主要有两个功能：</p><ul><li>回收内存资源</li><li>执行一些收尾工作</li></ul><p>在绝大多数情况下无需手动 drop 回收内存资源，因为 Rust 会自动完成这些工作，它甚至会对复杂类型的每个字段都单独的调用 drop 进行回收！</p><p>但是确实有极少数情况，需要程序员手动回收资源的，例如文件描述符、网络 socket 等，当这些值超出作用域不再使用时，就需要进行关闭以释放相关的资源，在这些情况下，就需要使用者手动解决 Drop 的问题。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line">    <span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>(v: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">            <span class="title function_ invoke__">MyBox</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="keyword">mut</span> MyBox&lt;<span class="type">i32</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">n</span> = <span class="number">1</span>; <span class="comment">// 作用域内的栈上变量和值都被销毁</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, s); <span class="comment">// 作用域外的堆上变量和值被保留</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 作用域内声明的堆上变量和值，包括所有权都会被销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;<span class="keyword">mut</span> v);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;v:#?&#125;&quot;</span>); <span class="comment">// 验证离开display函数后，变量所有权未变，值没有被销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证drop特征自动插入一段收尾工作（销毁）的代码</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">HasDrop1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">HasDrop2</span>;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">HasDrop1</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;HasDrop1 dropping&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">HasDrop2</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;HasDrop2 dropping&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display_drop</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = HasDrop1 &#123;&#125;; <span class="comment">// 变量后被销毁</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y</span> = HasDrop2; <span class="comment">// 变量先被销毁</span></span><br><span class="line">        HasDrop1 &#123;&#125;; <span class="comment">// 直接销毁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;display_drop over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">display_drop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">HasDrop3</span> &#123;</span><br><span class="line">        bar: HasDrop2,</span><br><span class="line">        foo: HasDrop1,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">HasDrop3</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;HasDrop3 dropping&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构体内部的销毁</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = HasDrop3 &#123;</span><br><span class="line">        foo: HasDrop1,</span><br><span class="line">        bar: HasDrop2,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Drop::drop 不允许手动调用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">z</span> = HasDrop3 &#123;</span><br><span class="line">        foo: HasDrop1,</span><br><span class="line">        bar: HasDrop2,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// z.drop(); 错误代码，不允许直接调用析构函数，等于下一行</span></span><br><span class="line">    <span class="comment">// Drop::drop(&amp;mut z); 错误代码，不允许直接调用析构函数，属于上一行的类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">z</span> = HasDrop3 &#123;</span><br><span class="line">        foo: HasDrop1,</span><br><span class="line">        bar: HasDrop2,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dropHeap</span>&lt;T&gt;(_v: T) &#123;&#125;</span><br><span class="line">    <span class="title function_ invoke__">dropHeap</span>(z);</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:#?&#125;&quot;, z); 错误代码，所有权被转移，不能再使用变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rust: Deref 解引用</title>
      <link href="/2024/05/01/rust-Deref-%E8%A7%A3%E5%BC%95%E7%94%A8/"/>
      <url>/2024/05/01/rust-Deref-%E8%A7%A3%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Deref-解引用"><a href="#Deref-解引用" class="headerlink" title="Deref 解引用"></a>Deref 解引用</h2><p>在类型转换（二）通用类型转换中，有一个步骤是自动解引用，这里的自动解引用就和 Deref 特征相关：</p><ol><li>编译器检查它是否可以直接调用 T::foo(value)，即检查类型是否具有 foo 方法，称之为<strong>值方法调用</strong></li><li>如果值方法调用无法完成(例如方法类型错误或者类型没有对应函数的 Self 进行实现)，那么编译器会尝试<strong>增加自动引用</strong>，会尝试以下调用： <code>&lt;&amp;T&gt;::foo(value)</code> 和 <code>&lt;&amp;mut T&gt;::foo(value)</code>，称之为<strong>引用方法调用</strong></li><li>如果值方法和引用方法两个方法不工作，编译器会试着<strong>解引用 T</strong> ，然后再进行尝试。这里使用了 <code>Deref</code> 特征 —— 若 <code>T: Deref&lt;Target = U&gt;</code> (T 可以被解引用为 U)，那么编译器会使用 U 类型进行尝试，称之为<strong>解引用方法调用</strong></li><li>如果 T 不能被解引用，且 T 是一个定长类型(在编译期类型长度是已知的)，那么编译器也会尝试将 T 从<strong>定长类型转为不定长类型</strong>，例如将 [i32; 2] 转为 [i32]</li><li>如果以上方式均不成功，那编译器将报错</li></ol><h3 id="通过-获取引用背后的值"><a href="#通过-获取引用背后的值" class="headerlink" title="通过 * 获取引用背后的值"></a>通过 <code>*</code> 获取引用背后的值</h3><blockquote><p>Rust 会在方法调用和字段访问时自动应用解引用强制多态（deref coercions），在一些其他情况下，如在标准比较操作或赋值中，Rust 不会自动应用解引用：<strong>在表达式中不能自动地执行隐式 Deref 解引用操作</strong>。<br>println! 实际上调用的就是 Display 特征的方法，所以 println 时存在自动解引用</p></blockquote><p>Deref 特征不仅可以自动解引用智能指针（引用），还可以解引用常规引用。</p><p>常规引用是一个指针类型，<strong>包含目标数据存储的内存地址</strong>。对常规引用使用 <code>*</code> 操作符，就可以通过解引用的方式获取到内存地址对应的数据值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &amp;<span class="number">5</span>;</span><br><span class="line"><span class="comment">// println!(&quot;&#123;&#125;&quot;, x == y); 在标准比较或赋值中，rust不会自动应用解引用，因此不能直接比较</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, x, y, *y); <span class="comment">// 可以自动解引用</span></span><br></pre></td></tr></table></figure><h3 id="智能指针解引用"><a href="#智能指针解引用" class="headerlink" title="智能指针解引用"></a>智能指针解引用</h3><p>常规指针的解引用与大多数语言并无区别，但 Rust 的解引用功能更为丰富，Rust 将其提升到了一个新高度。</p><p>考虑一下智能指针，它是一个结构体类型，如果直接对它进行解引用 <code>*myStruct</code>，显然编译器不知道该如何解析。为了避免复杂的人工转换，rust 为智能指针结构体设计了 Deref 特征。</p><p>实现 Deref 后的智能指针结构体，就可以像普通引用一样，通过 <code>*</code> 进行解引用，例如 <code>Box&lt;T&gt;</code> 智能指针，智能指针 x 被 <code>*</code> 解引用为 i32 类型的值 1，然后再进行求和：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = *x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="实现自定义智能指针"><a href="#实现自定义智能指针" class="headerlink" title="实现自定义智能指针"></a>实现自定义智能指针</h4><p>在 newtype 和类型别名章节，曾对 <code>Meters</code> 和 <code>Millimeters</code> 实现 Add 特征重载 <code>+</code>，让<code>Meters</code> 和 <code>Millimeters</code> 类型能够使用 <code>+</code> 操作符：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newtype实现可读性的提升</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除Add默认只能使用相同类型的限制</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Millimeters&gt; <span class="keyword">for</span> <span class="title class_">Meters</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Millimeters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> * <span class="number">1000</span> + rhs.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;mm&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">diff</span> = <span class="title function_ invoke__">Meters</span>(<span class="number">3</span>) + <span class="title function_ invoke__">Millimeters</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, diff); <span class="comment">// 6000</span></span><br></pre></td></tr></table></figure><p>同样的，智能指针 <code>Box&lt;T&gt;</code> 实现 Deref 特征，能重载 <code>*</code> 操作符，使用 <code>*</code> 直接对结构体进行解引用操作。</p><p>既然实现某一特征后可以重载对应的操作符，那意味着只需要实现 Deref 特征，就能实现自定义智能指针，也就可以使用 <code>*</code> 操作符。</p><p>实现一个类似 <code>Box&lt;T&gt;</code> 的智能指针，分析：<code>Box&lt;T&gt;</code> 只是将实际值存储在堆上，结构体中没有包含长度、最大长度的其他信息，因此用元组结构体就能满足要求。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">     <span class="keyword">fn</span> <span class="title function_">new</span>(v: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">         <span class="title function_ invoke__">MyBox</span>(v)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = *x + <span class="number">1</span>; 错误代码，因为MyBox没有实现Deref特征，直接对结构体使用解引用操作符，编译器不知道该怎么解析</span><br></pre></td></tr></table></figure><p><strong>实现 Deref 特征，创建自定义指针</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">     <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::T &#123;</span><br><span class="line">         &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Deref特征后，可以使用 `*` 解引用操作符</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = *x + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 类型转换，实现Deref特征，自动增加引用并转换为值方法调用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = *(Deref::<span class="title function_ invoke__">deref</span>(&amp;x)) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="背后的原理"><a href="#背后的原理" class="headerlink" title="* 背后的原理"></a><code>*</code> 背后的原理</h4><p>很简单，当解引用 MyBox 智能指针时，根据通用类型转换流程：</p><blockquote><p>通用类型转换是熟悉 rust 的必备技能，涉及到操作符就需要考虑类型是否发生转换</p><ol><li>编译器检查它是否可以直接调用 T::foo(value)，即检查类型是否具有 foo 方法，称之为<strong>值方法调用</strong></li><li>如果值方法调用无法完成(例如方法类型错误或者类型没有对应函数的 Self 进行实现)，那么编译器会尝试<strong>增加自动引用</strong>，会尝试以下调用： <code>&lt;&amp;T&gt;::foo(value)</code> 和 <code>&lt;&amp;mut T&gt;::foo(value)</code>，称之为<strong>引用方法调用</strong></li><li>如果值方法和引用方法两个方法不工作，编译器会试着<strong>解引用 T</strong> ，然后再进行尝试。这里使用了 <code>Deref</code> 特征 —— 若 <code>T: Deref&lt;Target = U&gt;</code> (T 可以被解引用为 U)，那么编译器会使用 U 类型进行尝试，称之为<strong>解引用方法调用</strong></li><li>如果 T 不能被解引用，且 T 是一个定长类型(在编译期类型长度是已知的)，那么编译器也会尝试将 T 从<strong>定长类型转为不定长类型</strong>，例如将 [i32; 2] 转为 [i32]</li><li>如果以上方式均不成功，那编译器将报错</li></ol></blockquote><p>由于 <code>*</code> 操作符要求操作变量为引用类型，根据类型转换和 Deref 特征，<code>*x</code> 可以正常转换成 <code>*(Deref::deref(&amp;x))</code>，<code>deref</code> 方法返回元组结构体中的元素 <code>&amp;self.0</code>：</p><ul><li>在 Deref 特征中声明了关联类型 Target，关联类型主要是为了提升代码可读性</li><li>deref 返回的是一个<strong>常规引用</strong>，可以被 <code>*</code> 进行解引用<br>因此类型转换成功，<code>*</code> 操作符正常解析。</li></ul><p>Rust 为何要使用这个有点啰嗦的方式实现？原因在于<strong>所有权系统</strong>的存在。如果 deref 方法直接返回一个值，而不是引用，那么该值的所有权将被转移给调用者。<br>使用者不希望调用者仅仅只是 <code>*T</code> 一下，就拿走了智能指针中包含的值。</p><p>需要注意的是，<code>*</code> 不会无限递归替换，从 <code>*y</code> 到 <code>*(y.deref())</code> 只会发生一次，而不会继续进行替换然后产生形如 <code>*((y.deref()).deref())</code> 的怪物。这里会在连续解引用和引用归一化解释。</p><h3 id="函数和方法中的隐式-Deref-转换"><a href="#函数和方法中的隐式-Deref-转换" class="headerlink" title="函数和方法中的隐式 Deref 转换"></a>函数和方法中的隐式 Deref 转换</h3><p>对于函数和方法的传参，Rust 提供了一个极其有用的 Deref 隐式转换。</p><p>若一个类型实现了 Deref 特征，那么在<strong>类型的引用在传给函数或方法</strong>时，编译器会根据函数的参数签名来决定是否对实参进行隐式的 Deref 转换，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">display</span>(&amp;s);</span><br></pre></td></tr></table></figure><p>注意： <strong>必须使用类型引用 <code>&amp;</code> 的方式来触发 Deref，仅实参的引用类型才会触发自动解引用</strong>。</p><p>分析以上代码：</p><ul><li>String 实现了 Deref 特征，可以在需要时自动被转换为 <code>&amp;str</code> 类型</li><li>实参 <code>&amp;s</code> 是一个 <code>&amp;String</code> 类型，当它被传给 display 函数时，由于是类型的引用类型，并且实现了 Deref 特征，所以触发了编译器自动解引用，通过 Deref 转换将 <code>&amp;String</code> 成了 <code>&amp;str</code></li></ul><h3 id="连续的隐式-Deref-转换"><a href="#连续的隐式-Deref-转换" class="headerlink" title="连续的隐式 Deref 转换"></a>连续的隐式 Deref 转换</h3><p>Rust 对解引用操作的提升除了表现在自定义智能指针的解引用外，还表现在在<strong>连续隐式解引用</strong>上，即直到找到适合的参数形式为止。</p><p>Box 是一个智能指针（存储在栈的引用和存储在堆上的实际类型数据），对比 <code>&amp;String</code> 和 <code>&amp;Box&lt;String&gt;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">display</span>(&amp;s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="title function_ invoke__">display</span>(&amp;s);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>&amp;Box&lt;String&gt;</code> 和 <code>&amp;String</code> 一样，是能够正常被隐式转换的，关键在于<strong>连续隐式转换</strong>：<br>Box 实现了 Deref 特征，<strong>实参传递的是引用类型，触发编译器自动解引用操作</strong>，然后被 Deref 成 String 类型，结果编译器发现不能满足 display 函数参数 <code>&amp;str</code> 的要求，接着发现 String 实现 Deref 特征，把 String Deref 成 &amp;str，最终成功的匹配了函数参数。</p><p>如果不能连续隐式解引用，就需要手动拟合参数类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = &amp;(*s)[..];</span><br><span class="line"><span class="title function_ invoke__">display</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">display</span>(&amp;(*s)[..]);</span><br></pre></td></tr></table></figure><p>结果不言而喻，肯定是 &amp;s 的方式优秀得多。</p><p>总之，当参与其中的类型实现了 Deref 特征时，Rust 会分析该类型并且连续使用 Deref 直到最终获得一个引用来匹配函数或者方法的参数类型，这种行为是在编译期完成的，完全不会造成任何的性能损耗。</p><p>但是 Deref 并不是没有缺点，缺点就是：如果你不知道某个类型是否实现了 Deref 特征，那么在看到某段代码时，并不能在第一时间反应过来该代码发生了隐式的 Deref 转换。</p><p>事实上，不仅仅是 Deref，在 Rust 中还有各种 <code>From/Into</code> 等等会给阅读代码带来一定负担的特征。还是那句话，一切选择都是权衡，有得必有失，得了代码的简洁性，往往就失去了可读性，Go 语言就是一个刚好相反的例子。</p><p>这种隐式转换&#x2F;连续隐式转换不仅可以用在函数的参数类型上，还可以用在赋值过程中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>: &amp;<span class="type">str</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = &amp;s <span class="keyword">as</span> &amp;<span class="type">str</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure><ul><li>对于 s1，只是简单的取引用，因此类型是 <code>&amp;Box&lt;String&gt;</code>，</li><li>对于 s2，通过两次 Deref 将 &amp;str 类型的值赋给了它（<strong>赋值操作需要手动解引用</strong>，即在赋值过程中手动标注类型）</li><li>对于 s3，直接调用方法 to_string，实际上 Box 根本没有没有实现该方法，能调用 to_string，是因为编译器对 Box 应用了 Deref 的结果（<strong>方法调用会自动解引用</strong>），即通用类型转换（五个步骤）</li></ul><blockquote><p>Rust 会在方法调用和字段访问时自动应用解引用强制多态（deref coercions），在一些其他情况下，如在标准比较操作或赋值中，Rust 不会自动应用解引用：<strong>在表达式中不能自动地执行隐式 Deref 解引用操作</strong>。</p></blockquote><p>不仅是 Box 内置的智能指针，自定义智能指针 <code>MyBox</code> 也能实现相同的功能：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(v: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自定义类型实现Deref特征，变为智能指针</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="title function_ invoke__">display</span>(&amp;s); <span class="comment">// 通过传递实参的引用类型，触发编译器自动解引用操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>: &amp;<span class="type">str</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = &amp;s <span class="keyword">as</span> &amp;<span class="type">str</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure><h3 id="Deref-规则总结"><a href="#Deref-规则总结" class="headerlink" title="Deref 规则总结"></a>Deref 规则总结</h3><p>**一个类型为 T 的对象 <code>foo</code>，如果 <code>T: Deref&lt;Target=U&gt;</code> 即 T 实现了 Deref 特征，那么 foo 的引用 <code>&amp;foo</code> 在需要的时候会被自动转换为 <code>&amp;U</code>**。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>: &amp;<span class="type">str</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = &amp;s <span class="keyword">as</span> &amp;<span class="type">str</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure><h4 id="引用归一化"><a href="#引用归一化" class="headerlink" title="引用归一化"></a>引用归一化</h4><p>引用归一化 <code>T: Deref&lt;Target=U&gt;</code> 包含两部分内容：</p><p>第一是把<strong>内置智能指针（Box、Rc、Arc、Cow 等）或自定义智能指针</strong>，根据 <code>T: Deref&lt;Target=U&gt;</code> 重载的 Deref 特征的 <code>deref</code> 方法，从结构体脱壳，并将其变为内部类型的引用类型 <code>&amp;v</code></p><p>第二是针对多重引用归一化，如将引用类型的引用 <code>&amp;&amp;v</code> 归一成 <code>&amp;v</code>。这是因为在标准库中为引用类型实现了 Deref 特征：<code>&amp;T: Deref&lt;Target=U&gt;</code>，当 T 是一个引用类型时，<code>&amp;T</code> 就代表引用类型的引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; Deref <span class="keyword">for</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的实现就是将多重引用归一化的关键，为 <code>&amp;T</code> 实现 Deref 特征，意味着 Self 为 <code>Self: &amp;T</code> 类型，那么 deref 方法的接收者 <code>&amp;self == self: &amp;Self</code> 为 <code>self: &amp;(&amp;T)</code> 类型，输入为 <code>&amp;&amp;T</code> 返回为 <code>&amp;T</code> 类型，即针对引用的引用，最终归一化成 <code>&amp;T</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Self = &amp;T -&gt; &amp;self = self: &amp;Self = self: &amp;&amp;T -&gt; *self = *&amp;Self = *&amp;&amp;T = &amp;T</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>: &amp;<span class="type">str</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = &amp;s <span class="keyword">as</span> &amp;<span class="type">str</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s4</span> = (&amp;s1).<span class="title function_ invoke__">to_string</span>(); <span class="comment">// 归一化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>: &amp;<span class="type">str</span> = &amp;s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = &amp;s <span class="keyword">as</span> &amp;<span class="type">str</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s4</span> = (&amp;s1).<span class="title function_ invoke__">to_string</span>(); <span class="comment">// 归一化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">display</span>(&amp;s); <span class="comment">// 智能指针可以被自动脱壳为内部的 `String` 引用 `&amp;String`，然后 `&amp;String` 再自动解引用为 `&amp;str`</span></span><br></pre></td></tr></table></figure><h3 id="三种-Deref-转换"><a href="#三种-Deref-转换" class="headerlink" title="三种 Deref 转换"></a>三种 Deref 转换</h3><p>以上的案例都是不可变的 Deref 转换，Rust 除了支持不可变引用的 Deref 转换外，还支持以下两种引用的转换：</p><ul><li>一个可变的引用转换成另一个可变的引用</li><li>一个可变引用转换成不可变的引用</li></ul><p>转换的规则如下：</p><ul><li>当 <code>T: DerefMut&lt;Target=U&gt;</code>，可以将 <code>&amp;mut T</code> 转换成 <code>&amp;mut U</code>，即将可变引用 DerefMut 为可变引用</li><li>当 <code>T: Deref&lt;Target=U&gt;</code>，可以将 <code>&amp;mut T</code> 转换成 <code>&amp;U</code>，即将可变引用 Deref 不可变引用</li><li>当 <code>T: Deref&lt;Target=U&gt;</code>，可以将 <code>&amp;T</code> 转换成 <code>&amp;U</code>，即将不可变引用 Deref 不可变引用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(v: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自定义类型实现Deref特征，变为智能指针</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现DerefMut特征，DerefMut的前提是实现了Deref特征</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变引用Deref转换为不可变引用</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变引用DerefMut转换为可变引用，实现DerefMut的前提是实现了Deref特征，因为 `pub trait DerefMut: Deref`</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display_mut</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="title function_ invoke__">display</span>(&amp;s); <span class="comment">// 不可变引用Deref转换为不可变引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line"><span class="title function_ invoke__">display_mut</span>(&amp;<span class="keyword">mut</span> s); <span class="comment">// 可变引用通过DerefMut转换为新的可变引用</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">display</span>(&amp;<span class="keyword">mut</span> s); <span class="comment">// 可变引用通过Deref转换为新的不可变引用</span></span><br></pre></td></tr></table></figure><p>需要注意的几点：</p><ul><li>只有类型的引用才会触发编译器自动解引用功能</li><li>要实现 DerefMut 必须要先实现 Deref 特征：<code>pub trait DerefMut: Deref</code></li><li><code>T: DerefMut&lt;Target=U&gt;</code> 解读：将 <code>&amp;mut T</code> 类型通过 DerefMut 特征的方法转换为 <code>&amp;mut U</code> 类型，对应上例中，就是将 <code>&amp;mut MyBox&lt;String&gt;</code> 转换为 <code>&amp;mut String</code></li></ul><p>对于上述三条规则中的第二条，它比另外两条稍微复杂了点：Rust 可以把可变引用隐式的转换成不可变引用，但反之则不行。</p><p>如果从 Rust 的所有权和借用规则的角度考虑，当你拥有一个可变的引用，那该引用肯定是对应数据的唯一借用，那么此时将可变引用变成不可变引用并不会破坏借用规则；但是如果你拥有一个不可变引用，那同时可能还存在其它几个不可变的引用，如果此时将其中一个不可变引用转换成可变引用，就变成了可变引用与不可变引用的共存，最终破坏了借用规则。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Deref 可以说是 Rust 中最常见的<strong>隐式类型转换</strong>，它虽然复杂，但是还是属于类型转换中的一种。Deref 最重要的特点就是归一化，包含两个方面：</p><ul><li>只要链条上的类型实现了 Deref 特征，它可以实现如 <code>Box&lt;String&gt; -&gt; String -&gt; &amp;str</code> 连续的隐式转换</li><li>针对多重引用类型，如引用的引用类型 <code>&amp;&amp;T</code>，可以实现将 <code>&amp;&amp;T</code> 归一成 <code>&amp;T</code></li></ul><p>在程序中也可以为自定义类型实现 Deref 特征，但是原则上来说，只应该为<strong>自定义的智能指针</strong>实现 Deref。<br>例如，虽然可以为自定义数组类型实现 Deref 以避免 <code>myArr.0[0]</code> 的使用形式，但是 Rust 官方并不推荐这么做，特别是在开发三方库时。</p><blockquote><p>Box 是有很多特殊性质的, 完全可以把他当作原生类型看待. 比如他的 Deref 实现就很特殊,(明明看上去是无限递归, 但是编译器却明白他的含义)。</p><p>Box 的 Deref 的实现是对自身解引用后将引用传递出去，而且不会无限递归。。。看上去 Box 的解引用其实在编译器内另有黑魔法，和常规类型的 Deref 不是一回事</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;<span class="number">5</span>;</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;, x == y); 在标准比较或赋值中，rust不会自动应用解引用，因此不能直接比较</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, x, y, *y); <span class="comment">// 可以自动解引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line">    <span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>(v: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">            <span class="title function_ invoke__">MyBox</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// let y = *x + 1; 还未实现Deref特征，直接使用 `*` 解引用操作符，编译器不知道怎么解析，因此报错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为自定义类型实现Deref特征，变为智能指针</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">            &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现Deref特征后，可以使用 `*` 解引用操作符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = *x + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 类型转换，实现Deref特征，转换为值方法调用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = *(Deref::<span class="title function_ invoke__">deref</span>(&amp;x)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Deref::<span class="title function_ invoke__">deref</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实参需要传递引用类型才能触发编译器自动解引用操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s);</span><br><span class="line">    <span class="comment">// 连续解引用操作</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = &amp;(*s)[..];</span><br><span class="line">    <span class="title function_ invoke__">display</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐式转换和连续隐式转换可以用在赋值过程中</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span>: &amp;<span class="type">str</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s <span class="keyword">as</span> &amp;<span class="type">str</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义指针也能实现连续转换</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span>: &amp;<span class="type">str</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s <span class="keyword">as</span> &amp;<span class="type">str</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    s1.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">to_string</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    &amp;s.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现DerefMut特征，DerefMut的前提是实现了Deref特征</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target &#123;</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s); <span class="comment">// 不可变引用 Deref 变为不可变引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变引用转变为可变引用</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display_mut</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">display_mut</span>(&amp;<span class="keyword">mut</span> s); <span class="comment">// 可变引用通过DerefMut转换为新的可变引用</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;<span class="keyword">mut</span> s); <span class="comment">// 可变引用通过Deref转换为新的不可变引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rust: 智能指针（二）Box 对象分配</title>
      <link href="/2024/04/25/rust-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%88%E4%BA%8C%EF%BC%89Box-%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
      <url>/2024/04/25/rust-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%88%E4%BA%8C%EF%BC%89Box-%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针（二）Box-对象分配"><a href="#智能指针（二）Box-对象分配" class="headerlink" title="智能指针（二）Box 对象分配"></a>智能指针（二）Box 对象分配</h2><p><code>Box&lt;T&gt;</code> 是 Rust 中最常见的智能指针，功能是将一个值分配到堆上，然后在栈上保留一个<strong>智能指针</strong>指向堆上的数据。</p><p>要想用好 Box，需要深入了解计算机堆栈概念。</p><p><strong>栈</strong></p><p>栈内存从<strong>高位地址向下增长</strong>，且栈内存是连续分配的，一般来说操作系统对栈内存的大小都有限制，因此 C 语言中无法创建任意长度的数组（存储在栈）。<br>在 Rust 中，main 线程的栈大小是 8MB，普通线程是 2MB，在函数被调用时 Rust 会在线程内存中创建一个<strong>临时栈空间</strong>，调用结束后 Rust 会让这个栈空间里的所有对象自动进入 Drop 流程，最后栈顶指针自动移动到上一个调用栈顶，无需程序员手动干预，因而栈内存申请和释放是非常高效的。</p><p><strong>堆</strong></p><p>与栈相反，堆上内存则是从低位地址向上增长，堆内存通常只受物理内存限制，而且通常是不连续的，因此从性能的角度看，栈往往比堆更高。</p><p>相比其它语言，Rust 堆上对象还有一个特殊之处，它们都拥有一个所有者，因此<strong>受所有权规则的限制</strong>：当赋值时，发生的是<strong>所有权的转移</strong>（只需浅拷贝栈上的引用或智能指针即可）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(x: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, &quot;</span>.<span class="title function_ invoke__">to_string</span>() + x;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span></span><br><span class="line"><span class="variable">println</span>!(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">foo</span>(<span class="string">&quot;World&quot;</span>));</span><br></pre></td></tr></table></figure><p>在 foo 函数中，s 是一个 String 类型，它是由存储在堆中的实际类型数据和存储在栈中的智能指针结构体（指向堆数据）共同组成的。<br>当 s 被从 foo 函数转移给 x 变量时，只需要将 s 栈上的智能指针复制一份赋予给 x，而底层数据不发生改变即可完成堆数据的所有权从 foo 函数内部到 x 的转移。</p><h3 id="栈与堆的性能"><a href="#栈与堆的性能" class="headerlink" title="栈与堆的性能"></a>栈与堆的性能</h3><p>很多人可能会觉得栈的性能肯定比堆高，其实未必，这里有一个大概：</p><ul><li>小型数据，在栈上的分配性能和读取性能都要比堆上高</li><li>中型数据，栈上分配性能高，但是读取性能和堆上并无区别，因为无法利用寄存器或 CPU 高速缓存（空间非常小），最终还是要经过一次内存寻址</li><li>大型数据，只建议在堆上分配和使用</li></ul><p>总结：栈的<strong>分配速度</strong>比堆快，但是<strong>读取速度</strong>往往取决于数据能不能放入寄存器或 CPU 高速缓存。因此不要因为堆的性能不如栈这个印象，就总是优先选择使用栈，导致代码更复杂的实现。</p><h3 id="Box-的使用场景"><a href="#Box-的使用场景" class="headerlink" title="Box 的使用场景"></a>Box 的使用场景</h3><p>由于 Box 是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。而性能和功能往往是鱼和熊掌，因此 Box 相比其它智能指针，功能较为单一，可以在以下场景中使用它：</p><ul><li>特意的将数据分配在堆上</li><li>数据较大时，又不想在转移所有权时进行数据拷贝</li><li>类型的大小在编译期无法确定，但是我们又需要固定大小的类型时（递归对象，切片等）</li><li>特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</li></ul><h4 id="使用-Box-lt-T-gt-将数据存储在堆上"><a href="#使用-Box-lt-T-gt-将数据存储在堆上" class="headerlink" title="使用 Box&lt;T&gt; 将数据存储在堆上"></a>使用 <code>Box&lt;T&gt;</code> 将数据存储在堆上</h4><p>如果一个变量拥有一个数值，即直接声明变量 <code>let a = 3</code>，那变量 a 必然是存储在栈上的，如果想要 a 的值存储在堆上就需要使用 <code>Box&lt;T&gt;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a); <span class="comment">// a = 3</span></span><br><span class="line"><span class="comment">// let b = a + 1; // 代码将报错 cannot add `&#123;integer&#125;` to `Box&lt;&#123;integer&#125;&gt;`</span></span><br></pre></td></tr></table></figure><p>这样就可以创建一个智能指针指向了存储在堆上的 3，并且 a 持有了该智能指针，而智能指针往往都实现了 Deref 和 Drop 特征，因此：</p><ul><li>println! 可以正常打印出 a 的值，是因为它隐式地调用了 Deref 对智能指针 a 进行了解引用 <code>*a</code>，即 <code>println!(&quot;&#123;&#125;&quot;, *a);</code></li><li>最后一行代码 <code>let b = a + 1</code> 报错，是因为<strong>在表达式中不能自动地执行隐式 Deref 解引用操作</strong>，需要手动使用 <code>*</code> 操作符来显式的进行解引用 <code>let b = *a + 1</code></li><li>a 持有的智能指针将在作用域结束（main 函数结束）时，被释放掉，这是因为 <code>Box&lt;T&gt;</code> 实现了 Drop 特征</li></ul><blockquote><p>Rust 会在方法调用和字段访问时自动应用解引用强制多态（deref coercions），这意味着如果类型实现了 Deref trait，Rust 会自动将引用类型转换为目标类型。<br>在一些其他情况下，如在标准比较操作或赋值中，Rust 不会自动应用解引用：<strong>在表达式中不能自动地执行隐式 Deref 解引用操作</strong>，需要手动使用 <code>*</code> 操作符解引用。</p></blockquote><h4 id="避免栈上数据的拷贝"><a href="#避免栈上数据的拷贝" class="headerlink" title="避免栈上数据的拷贝"></a>避免栈上数据的拷贝</h4><p>当栈上数据转移所有权时，实际上是把<strong>底层数据拷贝了一份</strong>，最终新旧变量各自拥有不同的数据，因此<strong>所有权未转移</strong>。<br>而堆上则不然，底层数据并不会被拷贝，转移所有权仅仅是<strong>复制一份栈中的指针</strong>，再将新的指针赋予新的变量，然后让拥有旧指针的变量失效，最终完成了<strong>所有权转移</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">0</span>;<span class="number">1000</span>]; <span class="comment">// 在栈上创建一个长度为1000的数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr1</span> = arr; <span class="comment">// 将arr所有权转移arr1，由于 `arr` 分配在栈上，因此这里实际上是直接重新深拷贝了一份数据</span></span><br></pre></td></tr></table></figure><h4 id="将动态大小类型变为-Sized-固定大小类型"><a href="#将动态大小类型变为-Sized-固定大小类型" class="headerlink" title="将动态大小类型变为 Sized 固定大小类型"></a>将动态大小类型变为 Sized 固定大小类型</h4><p>Rust 需要在编译时知道类型占用多少空间，如果一种类型在编译时无法知道具体的大小，那么被称为动态大小类型 DST。<br>在闭包作为函数返回值（特征对象）和不定长类型（切片）章节中就曾使用 <code>Box</code> 将动态大小类型 DST 转化为定长类型（Sized）。</p><p>除了特征对象和切片外，这里还有一种无法在编译时知道大小的类型是<strong>递归类型</strong>：在类型定义中又使用到了自身，或者说该类型的值的一部分可以是相同类型的其它值。</p><p>这种值的嵌套理论上可以无限进行下去，所以 Rust 不知道递归类型需要多少空间，以函数式语言中常见的 Cons List 为例，它的每个节点包含一个 i32 值，还包含了一个新的 List，递归类型声明：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面这段代码声明是错误的，因为这种嵌套可以无限进行下去，Rust 认为该类型是一个 DST 类型：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recursive type `List` has infinite size //递归类型 `List` 拥有无限长的大小</span><br></pre></td></tr></table></figure><p>该数据类型可以无限拓展，因此要将 List 改成存储在堆上，可使用 <code>Box</code>, <code>Rc</code>, <code>&amp;</code> 阻断该数据类型在栈上的无限拓展的可能，即变为在栈上存储指针（固定大小），堆存储实际数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;), <span class="comment">// 固定大小，因为 i32 和 Box 都是固定大小</span></span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h4><p>特征是一种动态尺寸类型（Dynamically Sized Types，DST），即特征本身不具有固定的大小，因此不能直接实例化为对象。<br>在 Rust 中，特征通常通过指针（如 <code>Box&lt;T&gt;、&amp;T</code>）来使用，这些指针指向实现了该特征的具体类型的实例。<br>这些<strong>对动态尺寸类型的一种封装，使其可以通过具体的、已知大小的指针类型（如 <code>Box&lt;dyn Trait&gt;</code> 或 <code>&amp;dyn Trait</code>）来使用，这种封装类型就是一个特征对象</strong>。因此特征对象可以被视为具体的、已知大小的类型。</p><p>在这里需要更新前几章的描述：特征对象是动态尺寸类型，这是有误的。正确的认识是：特征是动态尺寸类型，而特征对象是对特征的一种封装，使特征可以通过具体的，已知大小的指针类型来描述，因此特征对象是一个定长类型（Sized）。</p><h3 id="Box-内存布局"><a href="#Box-内存布局" class="headerlink" title="Box 内存布局"></a>Box 内存布局</h3><p>前面提到过：<br>不能简单的将变量与类型视为只是一块栈内存或一块堆内存数据，比如 Vec 类型，rust 将其分成两部分数据：存储在堆中的实际类型数据与存储在栈上的管理信息数据。<br>其中存储在栈上的管理信息数据是引用类型，包含实际类型数据的地址、元素的数量，分配的空间等信息，<strong>rust 通过栈上的管理信息数据掌控实际类型数据的信息</strong>。</p><p>因此来看一下几种常见的类型的内存模型，首先是 <code>Vec&lt;i32&gt;</code> 的内存布局：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(stack)    (heap)</span><br><span class="line">┌──────┐   ┌───┐</span><br><span class="line">│ vec1 │──→│ 1 │</span><br><span class="line">└──────┘   ├───┤</span><br><span class="line">           │ 2 │</span><br><span class="line">           ├───┤</span><br><span class="line">           │ 3 │</span><br><span class="line">           ├───┤</span><br><span class="line">           │ 4 │</span><br><span class="line">           └───┘</span><br></pre></td></tr></table></figure><p>智能指针存储在栈中，然后指向堆上的数组数据，String 类型与 Vec 类型内存布局是类似的，栈上存储智能指针，堆上存储实际类型数据。</p><p>那如果数组中每个元素都是一个 Box 对象呢？来看看 <code>Vec&lt;Box&lt;i32&gt;&gt;</code> 的内存布局：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                    (heap)</span><br><span class="line">(stack)    (heap)   ┌───┐</span><br><span class="line">┌──────┐   ┌───┐ ┌─→│ 1 │</span><br><span class="line">│ vec2 │──→│B1 │─┘  └───┘</span><br><span class="line">└──────┘   ├───┤    ┌───┐</span><br><span class="line">           │B2 │───→│ 2 │</span><br><span class="line">           ├───┤    └───┘</span><br><span class="line">           │B3 │─┐  ┌───┐</span><br><span class="line">           ├───┤ └─→│ 3 │</span><br><span class="line">           │B4 │─┐  └───┘</span><br><span class="line">           └───┘ │  ┌───┐</span><br><span class="line">                 └─→│ 4 │</span><br><span class="line">                    └───┘</span><br></pre></td></tr></table></figure><p>看出智能指针 vec2 依然是存储在栈上，然后指针指向一个存储在堆上的数组，该数组中每个元素都是一个 Box 智能指针，Box 智能指针又指向了存储在堆上的实际值。<br>因此当我们从数组中取出某个元素时，取到的是对应的智能指针 Box，需要对该智能指针进行解引用，才能取出最终的值，以 B1 为例：B1 代表被 Box 分配到堆上的值 1。</p><blockquote><p>Rust 会在方法调用和字段访问时自动应用解引用强制多态（deref coercions），在一些其他情况下，如在标准比较操作或赋值中，Rust 不会自动应用解引用：<strong>在表达式中不能自动地执行隐式 Deref 解引用操作</strong>。<br>println! 实际上调用的就是 Display 特征的方法，所以 println 时存在自动解引用</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">1</span>), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>)];</span><br><span class="line"><span class="keyword">let</span> (first, second) = (&amp;arr[<span class="number">0</span>], &amp;arr[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = **first + **second;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, first, second, sum);</span><br></pre></td></tr></table></figure><p>以上代码有几个值得注意的点：</p><ul><li>使用 &amp; 借用数组中的元素，否则会报所有权错误</li><li><strong>表达式不能隐式的解引用</strong>，因此必须使用 ** 做两次解引用，第一次将 <code>&amp;Box&lt;i32&gt;</code> 类型转成 <code>Box&lt;i32&gt;</code>，第二次将 <code>Box&lt;i32&gt;</code> 转成 i32</li></ul><h3 id="Box-leak"><a href="#Box-leak" class="headerlink" title="Box::leak"></a>Box::leak</h3><blockquote><p><a href="https://course.rs/advance/smart-pointer/box.html#boxleak">https://course.rs/advance/smart-pointer/box.html#boxleak</a></p></blockquote><p>需要一个在运行期初始化的值，变成可以全局有效（即和整个程序活得一样久），那么就可以使用 <code>Box::leak</code>，例如有一个存储配置的结构体实例，它是在运行期动态插入内容，那么就可以将其转为全局有效，虽然 <code>Rc/Arc</code> 也可以实现此功能，但是 <code>Box::leak</code> 是性能最高的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Box 背后是调用 jemalloc 来做内存管理，所以堆上的空间无需我们的手动管理。与此类似，带 GC 的语言中的对象也是借助于 Box 概念来实现的，<strong>一切皆对象 &#x3D; 一切皆 Box</strong>， 只不过我们无需自己去 Box 罢了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr1</span> = [<span class="number">0</span>; <span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr2</span> = arr1; <span class="comment">// 由于数组存储在栈上，因此赋值转移时，深拷贝了一份数据</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;, &#123;:p&#125;&quot;</span>, &amp;arr1, &amp;arr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foo</span>(x: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, &quot;</span>.<span class="title function_ invoke__">to_string</span>() + x;</span><br><span class="line">        s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">foo</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 智能指针往往都实现了 Deref 和 Drop 特征</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a_deref</span> = *a;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, *a, a_deref);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免在栈上存储大型数据，以避免复制成本</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr1</span> = [<span class="number">0</span>, <span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr2</span> = arr1; <span class="comment">// 复制了一份arr1数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum1</span>: <span class="type">i32</span> = arr1.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum2</span> = arr2.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).sum::&lt;<span class="type">i32</span>&gt;();</span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, arr1[<span class="number">0</span>], arr2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将动态大小类型变为 Sized 固定大小类型</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">        <span class="comment">// Cons(i32, List), 错误的，因为这个类型可以无限拓展，因此要存储在堆上，可使用  `Box`, `Rc`, `&amp;`) 打断动态，即将在栈上存储指针，而不存储实际数据</span></span><br><span class="line">        <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">        Nil,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BOX内存布局，自动解引用和手动解引用</span></span><br><span class="line">    <span class="comment">// Rust 会在方法调用和字段访问时自动应用解引用强制多态（deref coercions），在一些其他情况下，如在标准比较操作或赋值中，Rust 不会自动应用解引用：**在表达式中不能自动地执行隐式 Deref 解引用操作**。</span></span><br><span class="line">    <span class="comment">// println! 实际上调用的就是Display特征的方法，所以println时存在自动解引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">0</span>), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">let</span> (first, second) = (&amp;arr[<span class="number">0</span>], &amp;arr[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = **first + **second;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, first, second, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wsl: wsl2无法调用systemctl</title>
      <link href="/2024/04/24/wsl-wsl2%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8systemctl/"/>
      <url>/2024/04/24/wsl-wsl2%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8systemctl/</url>
      
        <content type="html"><![CDATA[<p>wsl2 （debian）默认不支持systemctl，报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System has not been booted with systemd as init system (PID 1). Can&#x27;t operate</span><br></pre></td></tr></table></figure><p>在读完 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/wsl-config">WSL 中的高级设置配置 | Microsoft Learn</a> 配置方法后，发现只配置 <code>wsl.conf</code>  并不生效，还是以上错误：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[boot]</span></span><br><span class="line"><span class="attr">systemd</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>需要升级最新的wsl：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// powershell</span><br><span class="line">wsl --update</span><br></pre></td></tr></table></figure><p>关闭并重启wsl：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br><span class="line"></span><br><span class="line">wsl</span><br></pre></td></tr></table></figure><p>如果 <code>wsl --update</code> 卡住，可以按照以下方式进行：</p><ol><li>卸载WSL2，关闭虚拟机平台服务，Windows子系统服务，重启，这样才彻底卸载旧版本的WSL2。</li><li>去github上找到新版WSL2的安装包，开启上述关闭的两个服务，重启，然后安装；网好就微软商店直接上。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/352994199">WSL2开启systemctl命令简单方法，重启WSL2后仍生效 - 知乎 (zhihu.com)</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/systemd">使用 systemd 通过 WSL 管理 Linux 服务 | Microsoft Learn</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/wsl-config">WSL 中的高级设置配置 | Microsoft Learn</a></li><li><a href="https://blog.csdn.net/qq_43685040/article/details/112056242?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-112056242-blog-133523514.235%5Ev43%5Epc_blog_bottom_relevance_base4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-112056242-blog-133523514.235%5Ev43%5Epc_blog_bottom_relevance_base4">System has not been booted with systemd as init system (PID 1). Can‘t operate.问题解决方法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> wsl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 智能指针（一）</title>
      <link href="/2024/04/22/rust-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/04/22/rust-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针（一）"><a href="#智能指针（一）" class="headerlink" title="智能指针（一）"></a>智能指针（一）</h2><p>在各个编程语言中，指针的概念几乎都是相同的：<strong>指针是一个包含了内存地址的变量，该内存地址引用或者指向了另外的数据</strong>。</p><p>在 Rust 中，最常见的指针类型是引用，通过 <code>&amp;</code> 符号表示。不同于其它语言，引用在 Rust 中被赋予了更深层次的含义：<strong>借用其它变量的值</strong>。<br>引用本身很简单，除了指向某个值外并没有其它的功能，也不会造成性能上的额外损耗，因此是 Rust 中使用最多的指针类型。</p><p>智能指针虽然也号称指针(胖指针)，但是它是一个复杂的数据类型：<strong>通过比引用更复杂的数据结构，包含比引用更多的信息</strong>，例如元数据，当前长度，最大可用长度等。在 C++ 或者其他语言中也存在智能指针相似的概念。</p><p>前面提到过：<br>不能简单的将变量与类型视为只是一块栈内存或一块堆内存数据，比如 Vec 类型，rust 将其分成两部分数据：存储在堆中的实际类型数据与存储在栈上的管理信息数据。<br>其中存储在栈上的管理信息数据是引用类型，包含实际类型数据的地址、元素的数量，分配的空间等信息，<strong>rust 通过栈上的管理信息数据掌控实际类型数据的信息</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">vp</span> = &amp;v;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;, &#123;:p&#125;&quot;</span>, &amp;v, &amp;vp);</span><br></pre></td></tr></table></figure><p>上面的案例中 <code>v</code> 栈内存存储就是一个智能指针（胖指针），通过 <code>println!(&quot;&#123;:p&#125;&quot;, &amp;v)</code> 可获取指针信息。</p><p>功能上，引用在 rust 中被赋予更深的含义：借用其它变量的值，而智能指针比引用更强大：</p><ul><li>提供比引用更多的功能特性，例如引用计数智能指针，该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行计数，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。</li><li>提供比引用更多的服务特性，引用仅仅是借用了数据，而智能指针往往可以拥有它们指向的数据，然后再为其它人提供服务。例如动态字符串 String 和动态数组 Vec，它们的数据结构中不仅仅包含了指向底层数据的指针，还包含了当前长度、最大长度等信息，其中 String 智能指针还提供了一种担保信息：所有的数据都是合法的 UTF-8 格式。</li></ul><p>智能指针往往是基于结构体实现，它与自定义的结构体最大的区别在于它实现了 Deref 和 Drop 特征：</p><ul><li>Deref 可以让<strong>智能指针像引用那样工作</strong>，这样你就可以写出同时支持智能指针和引用的代码，例如 <code>*T</code>。正如 Index 特征，可以为自定义结构体实现 Index 特征，然后可以使用 <code>[number]</code> 操作。</li><li>Drop 允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作。</li></ul><p>智能指针在 Rust 中很常见，几个最常用、最有代表性的智能指针：</p><ul><li><code>Box&lt;T&gt;</code>，可以将值分配到堆上</li><li><code>Rc&lt;T&gt;</code>，引用计数类型，允许多所有权存在</li><li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，允许将借用规则检查从编译期移动到运行期进行</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vp</span> = &amp;v;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;, &#123;:p&#125;, &#123;:p&#125;&quot;</span>, v.<span class="title function_ invoke__">as_ptr</span>(), &amp;v, &amp;vp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 整数与枚举</title>
      <link href="/2024/04/21/rust-%E6%95%B4%E6%95%B0%E4%B8%8E%E6%9E%9A%E4%B8%BE/"/>
      <url>/2024/04/21/rust-%E6%95%B4%E6%95%B0%E4%B8%8E%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="整数与枚举"><a href="#整数与枚举" class="headerlink" title="整数与枚举"></a>整数与枚举</h2><p>在 Rust 中，从枚举到整数的转换很容易，但是反过来，就没那么容易，甚至部分实现还挺不安全, 例如使用 transmute。</p><p>在实际场景中，从整数到枚举的转换有时还是非常需要的，例如为了可读性，有一个枚举类型，然后需要从外面传入一个整数，用于控制后续的流程走向，此时就需要用整数去匹配相应的枚举。</p><h3 id="手动匹配"><a href="#手动匹配" class="headerlink" title="手动匹配"></a>手动匹配</h3><p>为了实现这个需求，不要求<strong>数字转换枚举</strong>，可以利用<strong>枚举容易转换数字</strong>的特性进行匹配：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    INIT = <span class="number">0</span>,</span><br><span class="line">    RUNNING = <span class="number">1</span>,</span><br><span class="line">    SUCCESS = <span class="number">2</span>,</span><br><span class="line">    ERROR = <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">status</span> = <span class="number">2u8</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">status_enum</span> = <span class="keyword">match</span> status &#123;</span><br><span class="line">    _ <span class="keyword">if</span> status == Status::INIT <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::INIT),</span><br><span class="line">    _ <span class="keyword">if</span> status == Status::RUNNING <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::RUNNING),</span><br><span class="line">    _ <span class="keyword">if</span> status == Status::SUCCESS <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::SUCCESS),</span><br><span class="line">    _ <span class="keyword">if</span> status == Status::ERROR <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::ERROR),</span><br><span class="line">    _ =&gt; <span class="literal">None</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上面的写法是一样的，只不过多了一个内部变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">status_enum</span> = <span class="keyword">match</span> status &#123;</span><br><span class="line">    x <span class="keyword">if</span> x == Status::INIT <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::INIT),</span><br><span class="line">    x <span class="keyword">if</span> x == Status::RUNNING <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::RUNNING),</span><br><span class="line">    x <span class="keyword">if</span> x == Status::SUCCESS <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::SUCCESS),</span><br><span class="line">    x <span class="keyword">if</span> x == Status::ERROR <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::ERROR),</span><br><span class="line">    _ =&gt; <span class="literal">None</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用三方库"><a href="#使用三方库" class="headerlink" title="使用三方库"></a>使用三方库</h3><p>在手动匹配中，是没有实现<strong>数字转换枚举</strong>流程的，可以使用第三方库 <code>num-traits</code> 和 <code>num-derive</code> 来实现这个过程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> num_derive::FromPrimitive;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用第三方库实现</span></span><br><span class="line"><span class="meta">#[derive(FromPrimitive)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status2</span> &#123;</span><br><span class="line">    INIT = <span class="number">1</span>,</span><br><span class="line">    RUNNING,</span><br><span class="line">    SUCCESS,</span><br><span class="line">    ERROR,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> FromPrimitive::<span class="title function_ invoke__">from_u8</span>(status) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(Status2::INIT) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;INIT&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;NOT INIT&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用第三方库后，可以无需手动转换，使用 Optional 即可完成匹配。另外还可以使用一个较新的库: num_enums：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> num_enum::&#123;IntoPrimitive, TryFromPrimitive&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(TryFromPrimitive, IntoPrimitive)]</span></span><br><span class="line"><span class="meta">#[repr(u8)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status3</span> &#123;</span><br><span class="line">    INIT = <span class="number">1</span>,</span><br><span class="line">    RUNNING,</span><br><span class="line">    SUCCESS,</span><br><span class="line">    ERROR,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span>: <span class="type">u8</span> = Status3::INIT.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;转换失败&quot;</span>); <span class="comment">// 枚举转换为数字</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">enum_item</span> = Status3::<span class="title function_ invoke__">try_from</span>(<span class="number">2u8</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;转换失败&quot;</span>); <span class="comment">// 数字转换为枚举</span></span><br></pre></td></tr></table></figure><h3 id="TryFrom-特征"><a href="#TryFrom-特征" class="headerlink" title="TryFrom 特征"></a>TryFrom 特征</h3><p>如果不希望使用第三方库，自己也可以使用 TryFrom 实现转换逻辑。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用TryFrom实现转换逻辑，将给定的数据结合给定的类型，使用TryFrom特征定义的逻辑进行转换</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status4</span> &#123;</span><br><span class="line">    INIT = <span class="number">1</span>,</span><br><span class="line">    RUNNING,</span><br><span class="line">    SUCCESS,</span><br><span class="line">    ERROR,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TryFrom</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Status4</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = ();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">try_from</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">match</span> value &#123;</span><br><span class="line">            x <span class="keyword">if</span> x == Status4::INIT <span class="keyword">as</span> <span class="type">i32</span> =&gt; <span class="title function_ invoke__">Ok</span>(Status4::INIT),</span><br><span class="line">            x <span class="keyword">if</span> x == Status4::RUNNING <span class="keyword">as</span> <span class="type">i32</span> =&gt; <span class="title function_ invoke__">Ok</span>(Status4::RUNNING),</span><br><span class="line">            x <span class="keyword">if</span> x == Status4::SUCCESS <span class="keyword">as</span> <span class="type">i32</span> =&gt; <span class="title function_ invoke__">Ok</span>(Status4::SUCCESS),</span><br><span class="line">            x <span class="keyword">if</span> x == Status4::ERROR <span class="keyword">as</span> <span class="type">i32</span> =&gt; <span class="title function_ invoke__">Ok</span>(Status4::ERROR),</span><br><span class="line">            _ =&gt; <span class="title function_ invoke__">Err</span>(()),</span><br><span class="line">        &#125;;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">enum_num</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">match</span> enum_num.<span class="title function_ invoke__">try_into</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(Status4::INIT) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;INIT&quot;</span>),</span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;NOT INIT&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为枚举实现 TryFrom 特征，i32 使用 try_into 方法，try_into 调用的是目标类型的 TryFrom 特征逻辑，再一次应证了 rust 强大的类型系统，它可以使用上下文信息，以进行转换。</p><p><strong>标注合适的类型 + try_into 方法 &#x3D; 类型自由</strong></p><p>上面还有一个问题，需要为每个类型都定义一遍匹配分支，可以使用宏来解决这个问题：<a href="https://course.rs/advance/into-types/enum-int.html#tryfrom--%E5%AE%8F">https://course.rs/advance/into-types/enum-int.html#tryfrom--%E5%AE%8F</a></p><h3 id="std-mem-transmute"><a href="#std-mem-transmute" class="headerlink" title="std::mem::transmute"></a>std::mem::transmute</h3><p>这个方法原则上并不推荐，但是有其存在的意义，如果要使用，需要清晰的知道自己为什么使用，这属于 unsafe 代码。</p><p>阅读：<a href="https://course.rs/advance/into-types/enum-int.html#%E9%82%AA%E6%81%B6%E4%B9%8B%E7%8E%8B-stdmemtransmute">https://course.rs/advance/into-types/enum-int.html#%E9%82%AA%E6%81%B6%E4%B9%8B%E7%8E%8B-stdmemtransmute</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>枚举非常容易转化成数字，但是数字不容易转换成枚举。可以利用枚举容易转化成数字特性来实现枚举与数字的匹配。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">        INIT = <span class="number">0</span>,</span><br><span class="line">        RUNNING = <span class="number">1</span>,</span><br><span class="line">        SUCCESS = <span class="number">2</span>,</span><br><span class="line">        ERROR = <span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">status</span> = <span class="number">2u8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">status_enum</span> = <span class="keyword">match</span> status &#123;</span><br><span class="line">        _ <span class="keyword">if</span> status == Status::INIT <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::INIT),</span><br><span class="line">        _ <span class="keyword">if</span> status == Status::RUNNING <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::RUNNING),</span><br><span class="line">        _ <span class="keyword">if</span> status == Status::SUCCESS <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::SUCCESS),</span><br><span class="line">        _ <span class="keyword">if</span> status == Status::ERROR <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::ERROR),</span><br><span class="line">        _ =&gt; <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 与上面的写法是一样的，只不过多了一个内部变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">status_enum</span> = <span class="keyword">match</span> status &#123;</span><br><span class="line">        x <span class="keyword">if</span> x == Status::INIT <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::INIT),</span><br><span class="line">        x <span class="keyword">if</span> x == Status::RUNNING <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::RUNNING),</span><br><span class="line">        x <span class="keyword">if</span> x == Status::SUCCESS <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::SUCCESS),</span><br><span class="line">        x <span class="keyword">if</span> x == Status::ERROR <span class="keyword">as</span> <span class="type">u8</span> =&gt; <span class="title function_ invoke__">Some</span>(Status::ERROR),</span><br><span class="line">        _ =&gt; <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用第三方库实现</span></span><br><span class="line">    <span class="meta">#[derive(FromPrimitive)]</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Status2</span> &#123;</span><br><span class="line">        INIT = <span class="number">1</span>,</span><br><span class="line">        RUNNING,</span><br><span class="line">        SUCCESS,</span><br><span class="line">        ERROR,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> FromPrimitive::<span class="title function_ invoke__">from_u8</span>(status) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(Status2::INIT) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;INIT&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;NOT INIT&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[derive(TryFromPrimitive, IntoPrimitive)]</span></span><br><span class="line">    <span class="meta">#[repr(u8)]</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Status3</span> &#123;</span><br><span class="line">        INIT = <span class="number">1</span>,</span><br><span class="line">        RUNNING,</span><br><span class="line">        SUCCESS,</span><br><span class="line">        ERROR,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 枚举转换为数字</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span>: <span class="type">u8</span> = Status3::INIT.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line">    <span class="comment">// 数字转换为枚举</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">enum_item</span> = Status3::<span class="title function_ invoke__">try_from</span>(<span class="number">2u8</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用TryFrom实现转换逻辑，将给定的数据结合给定的类型，使用TryFrom特征定义的逻辑进行转换</span></span><br><span class="line">    <span class="comment">// 为枚举实现TryFrom特征，i32使用try_into方法，try_into调用的是目标类型的TryFrom特征逻辑，再一次应证了rust强大的类型系统，它可以使用上下文信息，以进行转换</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Status4</span> &#123;</span><br><span class="line">        INIT = <span class="number">1</span>,</span><br><span class="line">        RUNNING,</span><br><span class="line">        SUCCESS,</span><br><span class="line">        ERROR,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">TryFrom</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Status4</span> &#123;</span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Error</span> = ();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">try_from</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::Error&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">match</span> value &#123;</span><br><span class="line">                x <span class="keyword">if</span> x == Status4::INIT <span class="keyword">as</span> <span class="type">i32</span> =&gt; <span class="title function_ invoke__">Ok</span>(Status4::INIT),</span><br><span class="line">                x <span class="keyword">if</span> x == Status4::RUNNING <span class="keyword">as</span> <span class="type">i32</span> =&gt; <span class="title function_ invoke__">Ok</span>(Status4::RUNNING),</span><br><span class="line">                x <span class="keyword">if</span> x == Status4::SUCCESS <span class="keyword">as</span> <span class="type">i32</span> =&gt; <span class="title function_ invoke__">Ok</span>(Status4::SUCCESS),</span><br><span class="line">                x <span class="keyword">if</span> x == Status4::ERROR <span class="keyword">as</span> <span class="type">i32</span> =&gt; <span class="title function_ invoke__">Ok</span>(Status4::ERROR),</span><br><span class="line">                _ =&gt; <span class="title function_ invoke__">Err</span>(()),</span><br><span class="line">            &#125;;</span><br><span class="line">            result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">enum_num</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">match</span> enum_num.<span class="title function_ invoke__">try_into</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Status4::INIT) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;INIT&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;NOT INIT&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust整数与枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 不定长类型 DST 和定长类型 Sized</title>
      <link href="/2024/04/21/rust-%E4%B8%8D%E5%AE%9A%E9%95%BF%E7%B1%BB%E5%9E%8B-DST-%E5%92%8C%E5%AE%9A%E9%95%BF%E7%B1%BB%E5%9E%8B-Sized/"/>
      <url>/2024/04/21/rust-%E4%B8%8D%E5%AE%9A%E9%95%BF%E7%B1%BB%E5%9E%8B-DST-%E5%92%8C%E5%AE%9A%E9%95%BF%E7%B1%BB%E5%9E%8B-Sized/</url>
      
        <content type="html"><![CDATA[<h2 id="不定长类型-DST-和定长类型-Sized"><a href="#不定长类型-DST-和定长类型-Sized" class="headerlink" title="不定长类型 DST 和定长类型 Sized"></a>不定长类型 DST 和定长类型 Sized</h2><blockquote><p>为了较低难度，这里的部分内容描述的是不太正确的，比如特征对象其实就是定长类型，特征才是不定长类型。这无伤大雅，可以在后续智能指针Box中学到更准确的描述。</p></blockquote><p>在 Rust 中类型有多种抽象的分类方式，如按照传统数据结构划分：基本类型、集合类型、复合类型等。如果从编译器何时能获知类型大小的角度出发，可以分成两类:</p><ul><li>定长类型( sized )，这些类型的大小在编译时是已知的，实现了 trait Sized。</li><li>不定长类型( unsized )，与定长类型相反，它的大小只有到了<strong>程序运行时</strong>才能动态获知，这种类型又被称之动态大小类型&#x2F;动态尺寸类型(dynamically sized type)（DST），或者非正式地称为非固定尺寸类型(unsized type)。切片和 trait 对象是 DSTs 的两个例子。</li></ul><h3 id="动态大小类型-DST"><a href="#动态大小类型-DST" class="headerlink" title="动态大小类型 DST"></a>动态大小类型 DST</h3><p><strong>动态大小类型&#x2F;动态尺寸类型(dynamically sized type)（DST），指的类型大小不确定，而不是指数据大小不确定</strong>。</p><p>不能简单的将变量与类型视为只是一块栈内存或一块堆内存数据，比如 Vec 类型，rust 将其分成两部分数据：存储在堆中的实际类型数据与存储在栈上的管理信息数据。<br>其中存储在栈上的管理信息数据是引用类型，包含实际类型数据的地址、元素的数量，分配的空间等信息，<strong>rust 通过栈上的管理信息数据掌控实际类型数据的信息</strong>。<br>这种<strong>存储自身大小信息的类型</strong>就可以称为定长类型（固定尺寸）。</p><p>反过来，不存储自身大小信息的就被称为动态尺寸类型（DST），如切片 <code>[T]</code> 与 特征对象 <code>trait object</code>。<br>以切片为例，<strong>切片就是数据本身，不包含自身大小信息</strong>，它可以在堆、栈、静态存储区，写作 <code>[T]</code>，常见的支持切片的类型有 String 类型、Array 类型和 Vec 类型。<br>在 <a href="https://www.cnblogs.com/88223100/p/Rust-memory-distribution.html">https://www.cnblogs.com/88223100/p/Rust-memory-distribution.html</a> 中有切片的 rust 内存分布，可以清楚的看到切片 <code>[T]</code> 就是原始数据本身的一部分，<strong>没有存储自身大小的信息</strong>。<br>所以在使用切片时，需要通过外部手段（如引用或智能指针）来管理长度信息，如胖指针包含了两份元数据：<strong>指向源数据中切片起点元素的指针和切片数据中包含的元素数量(切片的长度)<strong>。<br>这种</strong>不存储自身大小信息的类型</strong>就是动态尺寸类型（DST）。</p><p><strong>切片 [T]:</strong></p><ul><li>切片是一个动态尺寸类型（Dynamically Sized Type, DST），它不存储任何有关其长度的信息。</li><li>切片只是对一块连续内存的引用，其长度在使用时必须已知，但不是由切片本身直接存储的。<br>由于切片的长度不是在编译时已知的，所以不能单独作为一个值来存储；它通常通过某种形式的指针（如 &amp;[T] 或 Box&lt;[T]&gt;）来使用，这些指针包含了长度信息。</li></ul><p><strong>向量 <code>Vec&lt;T&gt;</code>:</strong></p><ul><li><code>Vec&lt;T&gt;</code> 是一个固定尺寸类型，它在内部维护了一个指向堆上分配的数组的指针、当前向量的长度以及它的容量。这意味着 <code>Vec&lt;T&gt;</code> 总是知道自己包含多少元素，并且这些元素占用了多少内存空间。</li><li><code>Vec&lt;T&gt;</code> 的这种设计使得它在运行时可以动态地增长或缩小，但其本身的大小（即存储指针、长度和容量的大小）在编译时是已知的。</li></ul><p>因此 Vec、String 和 HashMap 等数据类型，虽然底层数据可动态变化，但实际上这些底层数据只是保存在堆上，在栈中还存有一个引用类型，该引用包含了集合的内存地址、元素数目、分配空间信息，也就是类型本身就存储自身的大小信息。</p><p>总结来说，尽管 <code>Vec&lt;T&gt;</code> 可以动态地改变其存储的数据的大小，但它本身作为一个对象的大小是固定的，包括指向数据的指针、长度和容量。而切片 <code>[T]</code> 本身不存储这些信息，需要通过外部手段（如引用或智能指针）来管理这些数据，因此是一个动态尺寸类型。</p><p><strong>存储自身大小信息的类型</strong>称为定长类型，反之称为非定长类型。</p><blockquote><p>小知识</p><p>在 rust 中，切片不可直接使用，所以一般将切片引用简化称为切片。</p></blockquote><h4 id="str"><a href="#str" class="headerlink" title="str"></a>str</h4><p>str 既不是 String 动态字符串，也不是 &amp;str 字符串切片(切片引用)，而是一个字符串切片，是一个动态类型，是 String 和 <code>&amp;str</code> 的底层数据类型。</p><p>由于 str 是动态类型，因此它的大小直到运行期才知道，所以要使用字符串切片引用（常称为字符串切片）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let s1: str = &quot;Hello World!&quot;; 字符串切片，是String和&amp;str的底层数据类型，不可直接使用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>: &amp;<span class="type">str</span> = <span class="string">&quot;on?&quot;</span>; <span class="comment">// 字符串切片引用</span></span><br></pre></td></tr></table></figure><p>之前提到过：<strong>切片就是数据本身，不包含自身大小信息</strong>，它可以在堆、栈、静态存储区。<br>str（字符串切片）就是存储在静态存储区的一种<strong>动态尺寸类型</strong>，rust 通过 <code>&amp;str</code> （字符串切片引用）管理 str。<br><code>&amp;str</code>（字符串切片引用）存储在栈，属于定长类型，包含有实际数据的内存地址、长度等信息，常用<strong>字符串切片</strong>简化名称，易与真实的字符串切片混淆。</p><h4 id="特征对象-trait-object"><a href="#特征对象-trait-object" class="headerlink" title="特征对象 trait object"></a>特征对象 trait object</h4><blockquote><p><a href="https://github.com/rtpacks/rust-note/blob/main/docs/unit%2043-%E9%97%AD%E5%8C%85%20Closure%EF%BC%88%E4%B8%89%EF%BC%89%E5%BD%93%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%A0%87%E6%B3%A8%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D.md#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC">https://github.com/rtpacks/rust-note/blob/main/docs/unit%2043-%E9%97%AD%E5%8C%85%20Closure%EF%BC%88%E4%B8%89%EF%BC%89%E5%BD%93%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%A0%87%E6%B3%A8%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D.md#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC</a></p></blockquote><p>与其他语言不同，rust 的特征（类似接口）是不能直接作为类型使用的，因为很多类型都实现某个特征，即实现该特征的类型（特征对象 trait object）并不固定，意味着特征对象(trait object) 也是一个动态尺寸类型。<br>这很容里解释：Cat 和 Dog 都实现了 Speak，但是 Cat 和 Dog 的数据大小不相等，所以特征对象是一个动态尺寸类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">MyThing</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo_1</span>(thing: &amp;<span class="keyword">dyn</span> MyThing) &#123;&#125;     <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo_2</span>(thing: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyThing&gt;) &#123;&#125; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo_3</span>(thing: MyThing) &#123;&#125;          <span class="comment">// ERROR!</span></span><br></pre></td></tr></table></figure><p>在闭包章节中提到过函数无法实现非固定大小的数据类型，需要使用特征对象的 <code>Box&lt;dyn Fn(i32) -&gt; i32&gt;</code> 正确标注闭包作为返回值，就是因为特征对象 <code>dyn trait | trait object</code> 是一个动态尺寸类型，无法直接使用。</p><p>总结：只能间接使用的 DST，Rust 中常见的 DST 类型有: <code>str</code>、<code>[T]</code>、<code>dyn trait | trait object</code>，它们都无法单独被使用，必须要通过引用或 Box 来间接使用。</p><h3 id="Sized-定长类型"><a href="#Sized-定长类型" class="headerlink" title="Sized 定长类型"></a>Sized 定长类型</h3><p>在 rust 编写泛型代码，编译器会自动加上了 Sized 特征约束，表示泛型只能用于一切实现了 Sized 特征的类型上，而<strong>所有在编译时就能知道其大小的类型，都会自动实现 Sized 特征</strong>。</p><p>除 <code>slice | trait object</code> 外，基本上所有的类型都实现了 Sized 特征。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T&gt;(t: T) &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: <span class="built_in">Sized</span>&gt;(t: T) &#123;&#125; <span class="comment">// 编译器自动加上 Sized 特征约束</span></span><br></pre></td></tr></table></figure><p><strong>每一个特征都是一个可以通过名称来引用的动态大小类型</strong>。因此如果想把特征作为具体的类型来传递给函数，必须将其转换成一个特征对象：诸如 <code>&amp;dyn Trait</code> 或者 <code>Box&lt;dyn Trait&gt;</code> (还有 <code>Rc&lt;dyn Trait&gt;</code>)这些引用类型。</p><p>假如想在泛型函数中使用动态数据类型怎么办？可以使用 <code>?Sized</code> 特征。<br><strong>?Sized 特征用于表明类型 T 既有可能是固定大小的类型，也可能是动态大小的类型</strong>。<br>还有一点要注意的是，函数参数类型从 T 变成了 &amp;T，因为 T 可能是动态大小的，因此需要用一个固定大小的指针(引用)来包裹它：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: ?<span class="built_in">Sized</span>&gt;(t: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box<str></h3><blockquote><p><a href="https://course.rs/advance/into-types/sized.html#boxstr">https://course.rs/advance/into-types/sized.html#boxstr</a></p></blockquote><p>使用 Box 可以将一个动态大小的特征变成一个拥有特征对象的固定大小类型，能否故技重施，将 str 封装成一个固定大小类型？</p><p>而如何把一个动态大小类型转换成固定大小的类型？使用引用指向这些动态数据，然后在引用中存储相关的内存位置、长度等信息即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">box_str</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Hello World&quot;</span> <span class="keyword">as</span> <span class="type">str</span>);</span><br></pre></td></tr></table></figure><p>很明显上面的代码会报错，因为 str 是一个非定长类型，rust 不允许直接使用非定常类型。这意味着<strong>不可能存在手动转换并使用非定长类型的数据的方式</strong>。</p><p>手动方式不允许，还有编译器自动转换。回忆在闭包章节中使用 <code>collect</code> 方法，可以通过在变量接收者上标注类型实现让编译器自动转换类型，借助这个特性，使用 <code>into</code> 方法让编译器自动转换：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">box_str</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;Hello World&quot;</span>.<span class="title function_ invoke__">into</span>(); <span class="comment">// 标注接收者类型+into方法，实现编译器自动转换类型</span></span><br></pre></td></tr></table></figure><p>into 方法是一个强大的方法，一些不能手动转换使用的类型，可以通过标注接收者类型和 into 方法，实现让编译器自动转换类型。</p><p><strong>正确标注接收者类型 + into 方法 &#x3D; 类型自由</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="string">&quot;Hello World&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="string">&#x27;c&#x27;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = <span class="number">88u8</span>.<span class="title function_ invoke__">into</span>();</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">array</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="comment">// let slice = array[..2]; 这是错误的，因为切片是一个动态大小的数据，因此只能存放在堆中，并不能直接使用</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;array[..<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;, &#123;:p&#125;&quot;</span>, &amp;&amp;array, slice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let s1: str = &quot;Hello World!&quot;; 字符串切片，是String和&amp;str的底层数据类型，不可直接使用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span>: &amp;<span class="type">str</span> = <span class="string">&quot;on?&quot;</span>; <span class="comment">// 字符串切片引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">box_str</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;x&quot;</span>.<span class="title function_ invoke__">into</span>(); <span class="comment">// into 方法是一个强大的方法，一些不能手动转换使用的类型，可以通过标注接收者类型和into方法，实现让编译器自动转换类型。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="string">&#x27;c&#x27;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = <span class="number">88u8</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DST </tag>
            
            <tag> Sized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: newtype 和类型别名 TypeAlias</title>
      <link href="/2024/04/19/rust-newtype-%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D-TypeAlias/"/>
      <url>/2024/04/19/rust-newtype-%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D-TypeAlias/</url>
      
        <content type="html"><![CDATA[<h2 id="newtype-和类型别名-TypeAlias"><a href="#newtype-和类型别名-TypeAlias" class="headerlink" title="newtype 和类型别名 TypeAlias"></a>newtype 和类型别名 TypeAlias</h2><p>学习如何创建自定义类型，以及了解何为动态大小的类型</p><h3 id="newtype"><a href="#newtype" class="headerlink" title="newtype"></a>newtype</h3><blockquote><p><a href="https://course.rs/basic/compound-type/struct.html#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93tuple-struct">https://course.rs/basic/compound-type/struct.html#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93tuple-struct</a></p></blockquote><p>什么是 newtype？简单来说，就是使用<strong>元组结构体</strong>将已有的类型包裹起来，形成 <code>struct Meters(u32)</code> 的结构，此处 <code>Meters</code> 就是一个 newtype。</p><p>newtype 的设计主要是为了增强类型安全并提供更明确的<strong>语义区分</strong>。这种设计允许开发者从现有的类型<strong>派生出新的类型</strong>，而这些新类型在逻辑上虽然与原始类型相似，但在类型系统中被视为完全不同的类型，这有助于避免类型间的错误混用。</p><p>例如 <code>struct Millimeters(u32)</code> 和 <code>struct Meters(u32)</code> 在逻辑形式上是与 u32 相同的，但是它们在类型系统是完全不一样的类型。即使两个 newtype 底层都是使用 u32，它们也不能互相替换，除非进行显式的类型转换。</p><p>从三个方面来解释：</p><ul><li>自定义类型可以让我们给出更有意义和可读性的类型名，例如与其使用 u32 作为距离的单位类型，我们可以使用 Meters，它的可读性要好得多</li><li>对于某些场景，只有 newtype 可以很好地解决</li><li>隐藏内部类型的细节</li></ul><h4 id="为外部类型实现外部特征"><a href="#为外部类型实现外部特征" class="headerlink" title="为外部类型实现外部特征"></a>为外部类型实现外部特征</h4><blockquote><p><a href="https://rustwiki.org/zh-CN/book/ch10-02-traits.html#%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0-trait">https://rustwiki.org/zh-CN/book/ch10-02-traits.html#%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0-trait</a> </p><p>[rust-note&#x2F;docs&#x2F;unit 18-Trait 特征（二）.md at main · rtpacks&#x2F;rust-note (github.com)](<a href="https://github.com/rtpacks/rust-note/blob/main/docs/unit">https://github.com/rtpacks/rust-note/blob/main/docs/unit</a> 18-Trait 特征（二）.md#trait-作用域孤儿规则)</p></blockquote><p>在为类型实现 trait 中，提到过一个孤儿原则：如果你想要为类型 A 实现 Trait T，那么 A 或者 T 至少有一个是在<strong>当前作用域中定义</strong>的！也就是不能为外部类型实现外部 trait。</p><p>这是因为由于类型可以实现多个 Trait，而不同的 Trait 可能存在相同的方法名，因此类型实体调用 Trait 方法时，必须明确方法来自哪个 Trait，所以需要孤儿原则来保证调用明确的方法。</p><p>例如，如果想使用 <code>println!(&quot;&#123;&#125;&quot;, v)</code> 的方式去格式化输出一个动态数组 <code>Vec</code>，以期给用户提供更加清晰可读的内容，那么就需要为 Vec 实现 Display 特征。<br>但是这里有一个问题： <code>Vec</code> 类型定义在标准库中，<code>Display</code> 亦然，根据孤儿院则不能给外部类型实现外部特征，不能直接为 Vec 实现 Display 特征。</p><p>现在可以通过 newtype <strong>定义新类型</strong>来解决这个问题，定义一个元组结构体，通过 <code>.0</code> 访问原始类型数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>)) <span class="comment">// 访问元组中的元素，即原始数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>, w);</span><br></pre></td></tr></table></figure><p>通过 newtype 形式定义新类型 <code>struct Wrapper(Vec&lt;String&gt;)</code> 后，就满足孤儿原则的当前作用域必须存在类型或特征要求。</p><h4 id="更好的可读性及类型异化"><a href="#更好的可读性及类型异化" class="headerlink" title="更好的可读性及类型异化"></a>更好的可读性及类型异化</h4><p><strong>更好的可读性不等于更少的代码</strong>，但可读性的提升降低维护代码的难度。例如 <code>struct Millimeters(u32)</code> 和 <code>struct Meters(u32)</code> 在逻辑形式上是与 u32 相同的，但是它们在类型系统是完全不一样的，两个类型不允许直接相加。</p><p>如果需要两个类型实现相加操作，约定返回 Millimeters，可以为其实现 Add 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newtype实现可读性的提升</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除Add默认只能使用相同类型的限制</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Millimeters&gt; <span class="keyword">for</span> <span class="title class_">Meters</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Millimeters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> * <span class="number">1000</span> + rhs.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;mm&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">diff</span> = <span class="title function_ invoke__">Meters</span>(<span class="number">3</span>) + <span class="title function_ invoke__">Millimeters</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, diff); <span class="comment">// 6000</span></span><br></pre></td></tr></table></figure><h4 id="隐藏内部类型的细节"><a href="#隐藏内部类型的细节" class="headerlink" title="隐藏内部类型的细节"></a>隐藏内部类型的细节</h4><p>Rust 的类型有很多自定义的方法，假如把某个类型传给了用户，又不想用户调用类型方法，就可以使用 newtype：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i</span>: <span class="type">u32</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(i.<span class="title function_ invoke__">pow</span>(<span class="number">2</span>), <span class="number">4</span>); <span class="comment">// u32 具有 pow 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">Meters</span>(i);</span><br><span class="line"><span class="comment">// assert_eq!(n.pow(2), 4); 错误，Meters(u32) 没有 pow 方法</span></span><br></pre></td></tr></table></figure><p>虽然 newtype 能够隐藏方法，但是用户可以通过 <code>n.0.pow(2)</code> 的方式来绕过限制，并调用内部类型的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(i.<span class="title function_ invoke__">pow</span>(<span class="number">2</span>), <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="类型别名-TypeAlias"><a href="#类型别名-TypeAlias" class="headerlink" title="类型别名 TypeAlias"></a>类型别名 TypeAlias</h3><p>使用 newtype 可以创建新类型，也可以使用一个更传统的方式，用类型别名来创建<strong>新的类型名称</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用TypeAlias创建新的类型名称，与原有类型相等</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MetersType</span> = <span class="type">u32</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MillimetersType</span> = <span class="type">u32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">diff1</span>: MetersType = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">diff2</span>: MillimetersType = <span class="number">3000</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, diff1 * <span class="number">1000</span> + diff2);</span><br></pre></td></tr></table></figure><p><strong>类型别名并不是一个独立的全新的类型，而是某一个类型的别名</strong>，因此编译器依然会把类型别名视为原有类型。</p><p>与 newtype 的区别：</p><ul><li>类型别名只是别名，是为了让可读性更好，并不是全新的类型，而 newtype 是一个全新的类型</li><li>类型别名无法实现为外部类型实现外部特征等功能，因为类型别名还是等于原有类型，而 newtype 可以</li></ul><p>类型别名除了让类型可读性更好，还能<strong>减少模版代码的使用</strong>，在一些引用交叉类型的代码上：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_long_type</span>(f: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;) &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_long_type</span>() <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>f 是一个令人眼花缭乱的类型 <code>Box&lt;dyn Fn() + Send + &#39;static&gt;</code>，使用时标注非常的麻烦，此时就可以用类型别名来解决：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Thunk</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: Thunk = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_long_type</span>(f: Thunk) &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_long_type</span>() <span class="punctuation">-&gt;</span> Thunk &#123;&#125;</span><br></pre></td></tr></table></figure><p>常用的 <code>std::io</code> 的 Result 也是经过类型别名简化的，它实际上是 <code>std::result::Result&lt;T, std::io::Error&gt;</code> 的别名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = std::result::<span class="type">Result</span>&lt;T, std::io::Error&gt;;</span><br></pre></td></tr></table></figure><p>如果为了区分 <code>std::io</code> 和 <code>std::fmt</code> 的 Result 和 Error 类型，同时简化模板代码，那可以使用类型别名来简化代码中 <code>std::io</code> 和 <code>std::fmt</code> 两者的 Result 和 Error：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IOError</span> = std::io::Error;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FmtError</span> = std::fmt::Error;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IOResult</span>&lt;T&gt; = std::result::<span class="type">Result</span>&lt;T, IOError&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FmtResult</span>&lt;T&gt; = std::result::<span class="type">Result</span>&lt;T, FmtError&gt;;</span><br></pre></td></tr></table></figure><p><strong>类型别名并不是一个独立的全新的类型，而是某一个类型的别名</strong>，编译器依然会把类型别名视为原有类型，因此可以用类型别名来调用真实类型的所有方法。</p><h3 id="永不返回类型"><a href="#永不返回类型" class="headerlink" title="! 永不返回类型"></a>! 永不返回类型</h3><p>在 TypeScript 中有一个 <code>never</code> 类型，表示永不返回类型，永不返回类型可能发生在<strong>函数运行异常</strong>和<strong>程序死循环</strong>这两点上。</p><p>rust 用 <code>!</code> 表示永不返回类型，它除了在函数运行异常和程序死循环外，还能用在 match 匹配中。<br>以下是一段错误代码，要赋值给 v，就必须保证 match 的各个分支返回的值是同一个类型，第一个分支返回数值、另一个分支返回元类型 ()，所以会出错。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="keyword">match</span> i &#123;</span><br><span class="line">   <span class="number">0</span>..=<span class="number">3</span> =&gt; i,</span><br><span class="line">   _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;不合规定的值:&#123;&#125;&quot;</span>, i)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以用 <code>!</code> 永不返回类型解决这个问题，panic 的返回值是 !，代表它决不会返回任何值，既然没有任何返回值，那自然不会存在分支类型不匹配的情况。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="keyword">match</span> i &#123;</span><br><span class="line">   <span class="number">0</span>..=<span class="number">3</span> =&gt; i,</span><br><span class="line">   _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;不合规定的值:&#123;&#125;&quot;</span>, i)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//  newtype 使用元组结构体快速构建新类型，解决孤儿原则的限制</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Display</span> <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">            <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;w&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newtype实现可读性的提升</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除Add默认只能使用相同类型的限制</span></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Millimeters&gt; <span class="keyword">for</span> <span class="title class_">Meters</span> &#123;</span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Millimeters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">            <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> * <span class="number">1000</span> + rhs.<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">            <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;mm&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">diff</span> = <span class="title function_ invoke__">Meters</span>(<span class="number">3</span>) + <span class="title function_ invoke__">Millimeters</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, diff); <span class="comment">// 6000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以绕过类型限制，调用原有数据类型的方法</span></span><br><span class="line">    <span class="title function_ invoke__">Meters</span>(<span class="number">2</span>).<span class="number">0</span>.<span class="title function_ invoke__">pow</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用TypeAlias创建新的类型名称，与原有类型相等</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">MetersType</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">MillimetersType</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">diff1</span>: MetersType = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">diff2</span>: MillimetersType = <span class="number">3000</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, diff1 * <span class="number">1000</span> + diff2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型别名提升可读性和减少冗长的类型模板代码</span></span><br><span class="line">    <span class="comment">// 类型模板代码 std::result::Result&lt;T, std::io::Error&gt;</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">IOError</span> = std::io::Error;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">FmtError</span> = std::fmt::Error;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">IOResult</span>&lt;T&gt; = std::result::<span class="type">Result</span>&lt;T, IOError&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">FmtResult</span>&lt;T&gt; = std::result::<span class="type">Result</span>&lt;T, FmtError&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 永不返回的类型 !</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>..<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>..=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="keyword">match</span> i &#123;</span><br><span class="line">        <span class="number">0</span>..=<span class="number">2</span> =&gt; i,</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;不符合规定的值 &#123;i&#125;&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> newtype与类型别名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常：删除新版QQ无底线的游戏弹窗</title>
      <link href="/2024/04/19/%E6%97%A5%E5%B8%B8%EF%BC%9A%E5%88%A0%E9%99%A4%E6%96%B0%E7%89%88QQ%E6%97%A0%E5%BA%95%E7%BA%BF%E7%9A%84%E6%B8%B8%E6%88%8F%E5%BC%B9%E7%AA%97/"/>
      <url>/2024/04/19/%E6%97%A5%E5%B8%B8%EF%BC%9A%E5%88%A0%E9%99%A4%E6%96%B0%E7%89%88QQ%E6%97%A0%E5%BA%95%E7%BA%BF%E7%9A%84%E6%B8%B8%E6%88%8F%E5%BC%B9%E7%AA%97/</url>
      
        <content type="html"><![CDATA[<p>删除&#x2F;卸载下面文件夹中的文件</p><p><code>C:\Users\25410\AppData\Local\Programs\qq-play</code></p>]]></content>
      
      
      <categories>
          
          <category> QQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 类型转换（二）通用类型转换</title>
      <link href="/2024/04/17/rust-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2024/04/17/rust-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="类型转换-通用类型转换"><a href="#类型转换-通用类型转换" class="headerlink" title="类型转换 - 通用类型转换"></a>类型转换 - 通用类型转换</h2><p>虽然 as 和 TryInto 很强大，但是只能应用在数值类型上，因此需要考虑其他方案。</p><p>首先看手动转换的代码，如果属性数据量大或者深层嵌套对象时，会非常的麻烦且啰嗦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    x: <span class="type">u32</span>, y: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    a: <span class="type">u32</span>, b: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reinterpret</span>(foo: Foo) <span class="punctuation">-&gt;</span> Bar &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Foo</span> &#123; x, y &#125; = foo;</span><br><span class="line">    Bar &#123; a: x, b: y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>在某些情况下，类型是可以进行隐式强制转换的。虽然这些转换弱化了 Rust 的类型系统，但是它们的存在是为了让 Rust 在大多数场景可以工作，而不是报各种类型上的编译错误。</p><p>在强制类型转换中，有一个转换规则：在匹配特征时，不会做任何强制转换(除了方法)。一个类型 T 可以强制转换为 U，不代表 impl T 可以强制转换为 impl U。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Trait</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Trait <span class="keyword">for</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，trait特征是非固定大小的，rust不允许非固定大小的数据作为参数类型，即 trait 不能直接用作为类型。</span></span><br><span class="line"><span class="comment">// fn foo(t: Trait) &#123;&#125;</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>&lt;T: Trait&gt;(t: T) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mut是可以向 immut 变化的，但 immut 大部分情况下是不允许向mut变化的</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">t_1</span>: &amp;<span class="keyword">mut</span> <span class="type">i32</span> = &amp;<span class="keyword">mut</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t_2</span> = t_1 <span class="keyword">as</span> &amp;<span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo(t_1); 错误的</span></span><br><span class="line"><span class="title function_ invoke__">foo</span>(t_2);</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>trait 特征是非固定大小的，rust 不允许非固定大小的数据作为参数类型，即 trait 不能直接用作为类型。</li><li>mut 是可以向 immut 变化的，但 immut 大部分情况下是不允许向 mut 变化的</li></ul></blockquote><p>在上面的例子中，<code>&amp;i32</code> 实现了特征 <code>Trait</code>， <code>&amp;mut i32</code> 可以转换为 <code>&amp;i32</code>，但是 <code>&amp;mut i32</code> 依然无法作为 <code>Trait</code> 来使用，也就是即使 T 可以强制转换为 U，也不代表表 <code>impl T</code> 可以强制转换为 <code>impl U</code>。</p><h3 id="点操作符"><a href="#点操作符" class="headerlink" title="点操作符"></a>点操作符</h3><p>方法调用的点操作符看起来简单，实际上非常不简单，它在调用时，会发生很多<strong>魔法般的类型转换</strong>。例如：自动引用、自动解引用，强制类型转换直到类型能匹配等。</p><p>在方法(非函数)签名中，参数 Self 常放在第一个位置，它可被称为<strong>接收器（receiver）</strong>，代表着<strong>调用方法</strong>的实例，它的类型有三种 <code>self &amp;self &amp;mut self</code>。</p><p>假设 value 拥有类型 T（包括特征 trait 和 结构体 struct 等能作为类型的数据），T 拥有 foo 方法，如果调用 <code>value.foo()</code>，编译器在调用 foo 之前，根据完全限定语法和下面的流程来确定到底使用哪个 Self 类型来调用：</p><blockquote><p>完全限定语法：<a href="https://course.rs/basic/trait/advance-trait.html#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95">https://course.rs/basic/trait/advance-trait.html#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95</a><br>Deref 特征：<a href="https://kaisery.github.io/trpl-zh-cn/ch15-02-deref.html">https://kaisery.github.io/trpl-zh-cn/ch15-02-deref.html</a><br>Index 特征：<a href="https://doc.rust-lang.org/std/ops/trait.Index.html">https://doc.rust-lang.org/std/ops/trait.Index.html</a></p></blockquote><ol><li>编译器检查它是否可以直接调用 T::foo(value)，即检查类型是否具有 foo 方法，称之为<strong>值方法调用</strong></li><li>如果值方法调用无法完成(例如方法类型错误或者类型没有对应函数的 Self 进行实现)，那么编译器会尝试<strong>增加自动引用</strong>，会尝试以下调用： <code>&lt;&amp;T&gt;::foo(value)</code> 和 <code>&lt;&amp;mut T&gt;::foo(value)</code>，称之为<strong>引用方法调用</strong></li><li>如果值方法和引用方法两个方法不工作，编译器会试着<strong>解引用 T</strong> ，然后再进行尝试。这里使用了 <code>Deref</code> 特征 —— 若 <code>T: Deref&lt;Target = U&gt;</code> (T 可以被解引用为 U)，那么编译器会使用 U 类型进行尝试，称之为<strong>解引用方法调用</strong></li><li>如果 T 不能被解引用，且 T 是一个定长类型(在编译期类型长度是已知的)，那么编译器也会尝试将 T 从<strong>定长类型转为不定长类型</strong>，例如将 [i32; 2] 转为 [i32]</li><li>如果以上方式均不成功，那编译器将报错</li></ol><p>以下面代码为例，跑一遍流程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">array</span>: Rc&lt;<span class="type">Box</span>&lt;[T; <span class="number">3</span>]&gt;&gt; = ...;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first_entry</span> = array[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>array 数组的底层数据隐藏在了重重封锁之后，那么编译器如何使用 <code>array[0]</code> 这种数组原生访问语法通过重重封锁，准确的访问到数组中的第一个元素？</p><p>首先先了解 <code>array[0]</code> 只是 Index 特征的语法糖，最终编译器会将 array[0] 转换为 <code>array.index(0)</code> 调用。<br>然后根据点操作符魔法般的类型转换流程，确定 <code>array.index(0)</code> 是否能调用，以次确定 <code>array[0]</code> 是否能调用。</p><p>因此 <code>array[0]</code> 能不能转换成 <code>array.index(0)</code> 以及 <code>array.index(0)</code> 能不能调用成功都依赖于 array 是否实现了 Index 特征。<br>也就是转换&#x2F;调用前，需要先检查 array 是否实现了 Index 特征。</p><ol><li>编译器检查 <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> 是否有实现 Index 特征即是否具有 index 方法，<code>Index::index(array: Rc&lt;Box&lt;[T; 3]&gt;&gt;)</code>，结果是否，值方法调用失败。</li><li>不仅如此，<code>&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> 与 <code>&amp;mut Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> 也没有实现 Index 特征，即没有 index 方法，引用方法调用失败。</li><li>值方法和引用方法都失败了，编译器开始对 <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> 解引用，把它转变成 <code>Box&lt;[T; 3]&gt;</code>，然后对 <code>Box&lt;[T; 3]&gt;</code> 再尝试值方法和引用方法。</li><li><code>Box&lt;[T; 3]&gt;</code>， <code>&amp;Box&lt;[T; 3]&gt;</code>，和 <code>&amp;mut Box&lt;[T; 3]&gt;</code> 都没有实现 Index 特征，所以编译器开始对 <code>Box&lt;[T; 3]&gt;</code> 进行解引用，得到了 [T; 3]，再尝试值方法和引用方法。</li><li><code>[T; 3]</code> 以及它的各种引用都没有实现 Index 特征，它也不能再进行解引用，最后一种尝试定长变为不定长。(很反直觉:D，在直觉中，数组都可以通过索引访问，实际上只有数组切片才可以!)。</li><li>将定长转为不定长，<code>[T; 3]</code> 被转换成 <code>[T]</code>，也就是数组切片，它实现了 Index 特征，因此 <code>array: Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> 可以通过 index 方法访问到对应的元素。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arrayBox</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">arrayBox.<span class="title function_ invoke__">index</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// Index::index(&amp;arrayBox, 0); 错误，因为 Box&lt;[i32, 3]&gt; 没有实现 Index 特征，所以参数错误，也就是完全限定语法调用失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">array</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">array.<span class="title function_ invoke__">index</span>(<span class="number">0</span>);</span><br><span class="line">Index::<span class="title function_ invoke__">index</span>(&amp;array, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="意想不到的自动引用"><a href="#意想不到的自动引用" class="headerlink" title="意想不到的自动引用"></a>意想不到的自动引用</h4><p>看一个复杂的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">do_stuff</span>&lt;T: <span class="built_in">Clone</span>&gt;(value: &amp;T) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cloned</span> = value.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照<strong>点操作符魔法般的转换</strong>跑一遍流程：</p><ol><li>编译器检查能不能进行<strong>值方法调用</strong>，将 <code>value.clone()</code> 变为 <code>Clone::clone(value: &amp;T)</code>，由于 T 实现了 Clone 特征，能满足 <code>Clone::clone(&amp;self) -&gt; Self</code> 签名和接收者类型，因此调用的是 T 的 clone 方法，值方法调用成功，cloned 的类型是 T。</li></ol><p>如果去掉 <code>Clone</code> 限制，代码变为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">do_stuff</span>&lt;T&gt;(value: &amp;T) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cloned</span> = value.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直觉上这段代码会报错，因为 T 没有实现 Clone 特征。其实这是能正常运行的代码，易混淆点就在于<strong>点操作符魔法般的转换</strong>和<strong>调用谁的方法</strong>。</p><p>在推理前，需要牢牢记住：结合点操作符的转换流程和从<strong>原有类型</strong>下手，对比函数签名，结合接收者 <code>Self</code>，才能推出是否允许调用以及调用谁的方法</p><p>根据流程进行推理：</p><ol><li>给定 <code>&amp;T</code>，从原有类型 T 下手分析，<code>T</code> 没有实现 Clone 特征，没有 clone 方法，因此不能使用 <code>Clone::clone(&amp;self) -&gt; Self</code>，值方法调用失败</li><li>自动增加引用，<code>T</code> 变为 <code>&amp;T</code>，此时 <code>&amp;T</code> 实现了 <code>Clone</code> 类型 (所有的引用类型都可以被复制，其实是复制一份地址)，可以调用 clone 方法，根据 <code>Clone::clone(&amp;self) -&gt; Self</code> 签名，推出接收者 Self 为 <code>&amp;&amp;T</code>，具体形式为 <code>Clone::clone(&amp;self: &amp;&amp;T) -&gt; &amp;T</code>，引用方法调用成功<br>最终复制出一份引用指针，<code>cloned</code> 的类型是 <code>&amp;T</code> 。</li></ol><p>当然，也可以一步到位：给定的数据类型 <code>value: &amp;T</code> ，T 未实现 Clone 特征，但 <code>&amp;T</code> 是一个引用实现了 Clone，所以根据 <code>Clone::clone(&amp;self) -&gt; Self</code> 签名，推出接收者 Self 为 <code>&amp;&amp;T</code>，具体形式为 <code>Clone::clone(&amp;self: &amp;&amp;T) -&gt; &amp;T</code>，返回的类型为 <code>&amp;T</code>。</p><p>总结：结合点操作符的转换流程，先确定非引用的原有类型 <code>T</code>（非<code>&amp;T</code>） 是否实现了某个特征（是否允许调用该方法），再确定方法的接收者 <code>Self</code> 和返回类型，也就是先看非引用的原有类型，然后再对比方法的接收者和返回类型，这样才不会混淆能不能调用以及到底调用的是谁的方法。</p><p>一个更复杂的自动引用生效的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>&lt;T&gt;(Arc&lt;T&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">clone_containers</span>&lt;T&gt;(foo: &amp;Container&lt;<span class="type">i32</span>&gt;, bar: &amp;Container&lt;T&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foo_cloned</span> = foo.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bar_cloned</span> = bar.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂类型派生 Clone 的规则：<strong>一个复杂类型能否派生 Clone <code>#[derive(Clone)]</code>，取决于它内部的所有子类型是否都实现了 Clone 特征。</strong><br>因此确定 <code>Container&lt;T&gt;(Arc&lt;T&gt;)</code> 是否实现 Clone 的关键在于 T 类型是否实现了 Clone 特征。</p><p>按照<strong>点操作符魔法般的转换流程</strong>进行推理，推理前注意：结合点操作符的转换流程和从<strong>原有类型</strong>下手，对比函数签名，结合接收者 <code>Self</code>，才能推出是否允许调用以及调用谁的方法</p><p>clone_containers 函数的第一个参数 <code>foo: &amp;Container&lt;i32&gt;</code>，由于 i32 实现了 Clone 特征，所以 <code>Container&lt;i32&gt;</code> 能派生（实现） Clone 特征。推理：</p><ol><li>值方法调用，将 <code>foo.clone()</code> 转化为 <code>Clone::clone(foo: &amp;Container&lt;i32&gt;)</code>，由于 <code>Container&lt;i32&gt;</code> 能派生（实现） Clone 特征，根据 <code>Clone::clone(&amp;self) -&gt; Self</code>，推出返回类型为 <code>Container&lt;i32&gt;</code>，即调用的方法是 <code>Container&lt;i32&gt;</code> 派生的 Clone 特征的 clone 方法，复制的是一份 <code>Container</code>。</li></ol><p>clone_containers 函数的第二个参数 <code>bar: &amp;Containers&lt;T&gt;</code>，由于泛型 <code>T</code> 没有实现 Clone 特征，所以 <code>Containers&lt;T&gt;</code> 没有派生（实现）Clone 特征。</p><ol><li>值方法调用，将 <code>bar.clone()</code> 转化为 <code>Clone::clone(bar: &amp;Container&lt;T&gt;)</code>，由于 <code>Containers&lt;T&gt;</code> 没有派生（实现）Clone 特征，值方法调用失败。</li><li>自动增加引用，将 <code>bar.clone</code> 变为 <code>(&amp;bar).clone</code>，即等价于 <code>Clone::clone(&amp;bar: &amp;&amp;Container&lt;T&gt;)</code>，由于引用实现了 Clone 特征，根据 <code>Clone::clone(&amp;self) -&gt; Self</code>，推出返回的类型为 <code>&amp;Container&lt;T&gt;</code>，即调用的方法是 <code>&amp;Container&lt;T&gt;</code> 引用实现的 Clone 特征的 clone 方法，复制的是一份指针。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Clone</span>::<span class="title function_ invoke__">clone</span>(bar); 等价于 <span class="built_in">Clone</span>::<span class="title function_ invoke__">clone</span>(bar: &amp;Container&lt;T&gt;)，由于 Containers&lt;T&gt; 未实现 <span class="built_in">Clone</span> 特征，不含有 clone 方法，所以值方法调用失败</span><br><span class="line"><span class="built_in">Clone</span>::<span class="title function_ invoke__">clone</span>(&amp;bar); 等价于 <span class="built_in">Clone</span>::<span class="title function_ invoke__">clone</span>(&amp;bar: &amp;&amp;Container&lt;T&gt;)，由于引用实现了 <span class="built_in">Clone</span> 特征，根据 `<span class="built_in">Clone</span>::<span class="title function_ invoke__">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>`，推出返回的类型为 `&amp;Container&lt;T&gt;`，引用方法调用成功</span><br></pre></td></tr></table></figure><p>总结：结合点操作符的转换流程，先确定非引用的原有类型 <code>T</code>（非<code>&amp;T</code>） 是否实现了某个特征（是否允许调用该方法），再确定方法的接收者 <code>Self</code> 和返回类型，也就是先看非引用的原有类型，然后再对比方法的接收者和返回类型，这样才不会混淆能不能调用以及到底调用的是谁的方法。</p><h3 id="变形记（transmutes）"><a href="#变形记（transmutes）" class="headerlink" title="变形记（transmutes）"></a>变形记（transmutes）</h3><p>阅读：<a href="https://course.rs/advance/into-types/converse.html#%E5%8F%98%E5%BD%A2%E8%AE%B0transmutes">https://course.rs/advance/into-types/converse.html#%E5%8F%98%E5%BD%A2%E8%AE%B0transmutes</a></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">trait</span> <span class="title class_">Trait</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Trait <span class="keyword">for</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，trait特征是非固定大小的，rust不允许非固定大小的数据作为参数类型，即trait 不能直接用作为类型。</span></span><br><span class="line">    <span class="comment">// fn foo(t: Trait) &#123;&#125;</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foo</span>&lt;T: Trait&gt;(t: T) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mut是可以像unmut变化的，但unmut大部分情况下是不允许像mut变化的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t_1</span>: &amp;<span class="keyword">mut</span> <span class="type">i32</span> = &amp;<span class="keyword">mut</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t_2</span> = t_1 <span class="keyword">as</span> &amp;<span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// foo(t_1); 错误的</span></span><br><span class="line">    <span class="title function_ invoke__">foo</span>(t_2);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        age: <span class="type">u8</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">get_age</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.age</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;age = &#123;&#125;, age = &#123;&#125;&quot;</span>,</span><br><span class="line">        Person &#123; age: <span class="number">12</span> &#125;.<span class="title function_ invoke__">get_age</span>(),</span><br><span class="line">        Person::<span class="title function_ invoke__">get_age</span>(&amp;Person &#123; age: <span class="number">18</span> &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arrayBox</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    arrayBox.<span class="title function_ invoke__">index</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Index::index(&amp;arrayBox, 0); 错误，因为Box&lt;[i32, 3]&gt; 没有实现Index特征，所以参数错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">array</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    array.<span class="title function_ invoke__">index</span>(<span class="number">0</span>);</span><br><span class="line">    Index::<span class="title function_ invoke__">index</span>(&amp;array, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Clone</span>::<span class="title function_ invoke__">clone</span>(&amp;array);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">do_stuff</span>&lt;T&gt;(t: &amp;T) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cloned</span> = t.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        cloned</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">do_stuff</span>(&amp;<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = <span class="title function_ invoke__">do_stuff</span>(&amp;Person &#123; age: <span class="number">18</span> &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, person);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">do_stuff2</span>&lt;T: <span class="built_in">Clone</span>&gt;(value: &amp;T) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cloned</span> = value.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[derive(Clone)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Container</span>&lt;T&gt;(Arc&lt;T&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone_containers</span>&lt;T&gt;(foo: &amp;Container&lt;<span class="type">i32</span>&gt;, bar: &amp;Container&lt;T&gt;) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">foo_cloned</span> = foo.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">bar_cloned</span> = bar.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">eight</span> = &amp;<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">eight_cloned</span> = <span class="built_in">Clone</span>::<span class="title function_ invoke__">clone</span>(&amp;eight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 类型转换（一）数值类型转换</title>
      <link href="/2024/04/14/rust-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2024/04/14/rust-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Rust 是类型安全的语言，因此在 Rust 中做类型转换不是一件简单的事。</p><p>首先看一段错误的实例，a 和 b 拥有不同的类型，<strong>Rust 不允许两种不同的类型进行比较</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i32</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u16</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123; <span class="built_in">println!</span>(<span class="string">&quot;a &lt; b 执行&quot;</span>); &#125; 代码报错，因为a和b是不同的类型，不能直接用于比较</span><br></pre></td></tr></table></figure><p>解决方法很简单，把数据类型改成同一种就可以通过编译。针对数值类型（包括字符 ASCII），rust 提供了两种<strong>专属数值类型的转换方式 <code>as</code> 和 <code>TryInto</code></strong></p><h3 id="as-转换"><a href="#as-转换" class="headerlink" title="as 转换"></a>as 转换</h3><p>as 转换非常方便，但使用时需要小心。因为每个数值类型能表达的数据范围不同，如果把范围较大的类型转换成较小的类型，可能会造成数据溢出的错误。</p><p>因此<strong>尽量把范围较小的类型转换成较大的类型</strong>，来避免这些问题的发生。数值类型可以通过 <code>i8::MAX</code> 的形式查看该类型能表达的最大值。</p><h4 id="数值与数值"><a href="#数值与数值" class="headerlink" title="数值与数值"></a>数值与数值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i32</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u16</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">transformed_a</span> = a <span class="keyword">as</span> <span class="type">u16</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">transformed_b</span> = b <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;transformed_a&#125;, &#123;transformed_b&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="数值与字符"><a href="#数值与字符" class="headerlink" title="数值与字符"></a>数值与字符</h4><p>转换字符，只有 <code>u8</code> 类型的数据（ASCII 范围）才能转换成字符，但字符可以转换成包含 u8 范围的数值类型，如 i16，u16 等</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">transformed_a</span> = a <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span>: <span class="type">u8</span> = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">transformed_c</span> = c <span class="keyword">as</span> <span class="type">char</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;transformed_a&#125;, &#123;transformed_c&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="数值与内存指针"><a href="#数值与内存指针" class="headerlink" title="数值与内存指针"></a>数值与内存指针</h4><p>rust 指针可通过 <code>as_mut_ptr</code> 获取，它的形式与 <code>C</code> 一样，数组的指针也是第一个元素的指针。</p><p>指针常用 usize（4 bytes(32 bit) 或 8 bytes(64 bit）表示。</p><blockquote><p>数组指针偏移，第 N+1 元素地址 &#x3D; 第 N 元素地址 + 元素内存大小</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span>: *<span class="keyword">mut</span> <span class="type">i32</span> = v.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first_address</span> = p1 <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">second_address</span> = first_address + size_of::&lt;<span class="type">i32</span>&gt;(); <span class="comment">// 数组指针偏移，第N+1元素地址 = 第 N 元素地址 + 元素大小</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = second_address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    *p2 += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(</span><br><span class="line">    <span class="string">&quot;v = &#123;:?&#125;, second_address = &#123;:?&#125; p2 = &#123;:?&#125;&quot;</span>,</span><br><span class="line">    v, second_address, p2</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="强制类型转换的边角知识"><a href="#强制类型转换的边角知识" class="headerlink" title="强制类型转换的边角知识"></a>强制类型转换的边角知识</h4><ul><li>转换不具有传递性 就算 e as U1 as U2 是合法的，也不能说明 e as U2 是合法的（e 不能直接转换成 U2），因为 as 关键字执行的转换可能涉及到具体的转换逻辑和额外的步骤，这些逻辑在不同的转换路径中可能不适用。</li></ul><h3 id="TryInto-特征"><a href="#TryInto-特征" class="headerlink" title="TryInto 特征"></a>TryInto 特征</h3><p>在一些场景中，使用 as 关键字会有比较大的限制，比如转换失败直接 panic。如果希望在类型转换上拥有完全的控制而不依赖内置的转换，例如处理转换错误，那么可以使用 TryInto 特征。</p><p><strong>如果你要使用一个特征的方法，那么你需要引入该特征到当前的作用域中</strong>，如果希望使用 try_into 方法，需要引入对应的 TryInto 特征。</p><blockquote><p>在 1.75.0，TryInto 已通过 <code>std::prelude</code> 预导入，无需手动 use 手动导入。</p></blockquote><p>try_into 方法会尝试进行一次转换，并返回一个 Result，此时就可以对其进行相应的错误处理（使用时需要给结果标注转换后的类型）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::convert::TryInto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">8</span> <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u8</span> = a.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span>: <span class="type">u8</span> = <span class="keyword">match</span> a.<span class="title function_ invoke__">try_into</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(v) =&gt; v,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;expr&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;b&#125;, &#123;c&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>巩固 rust 认识<br>rust 编译的过程，会根据给定的类型生成对应的代码，给变量标注类型和给表达式指定类型的效果是一样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">8</span> <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u8</span> = <span class="number">8</span>;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i32</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u16</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// if a &lt; b &#123; println!(&quot;a &lt; b 执行了&quot;) &#125; 代码报错，因为 a 和 b是不同的类型，rust不允许两种不同的类型进行比较</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="type">i8</span>::MIN);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="type">u8</span>::MIN == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数值与数值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">transformed_a</span> = a <span class="keyword">as</span> <span class="type">u16</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">transformed_b</span> = b <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;transformed_a&#125;, &#123;transformed_b&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数值与字符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">transformed_a</span> = a <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="type">u8</span> = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">transformed_c</span> = c <span class="keyword">as</span> <span class="type">char</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;transformed_a&#125;, &#123;transformed_c&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数值与内存指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span>: *<span class="keyword">mut</span> <span class="type">i32</span> = v.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_address</span> = p1 <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second_address</span> = first_address + size_of::&lt;<span class="type">i32</span>&gt;();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = second_address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *p2 += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;v = &#123;:?&#125;, second_address = &#123;:?&#125; p2 = &#123;:?&#125;&quot;</span>,</span><br><span class="line">        v, second_address, p2</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">8</span> <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b_1</span>: <span class="type">u8</span> = a.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u8</span> = a.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="type">u8</span> = <span class="keyword">match</span> a.<span class="title function_ invoke__">try_into</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(v) =&gt; v,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;expr&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;b&#125;, &#123;c&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 迭代器的两种适配器-消费者适配器和迭代器适配器</title>
      <link href="/2024/04/13/rust-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%80%82%E9%85%8D%E5%99%A8-%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%82%E9%85%8D%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/"/>
      <url>/2024/04/13/rust-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%80%82%E9%85%8D%E5%99%A8-%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%82%E9%85%8D%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>rust 中，<strong>迭代器的方法</strong>可以细分为消费者适配器（consuming adaptors）和迭代器适配器（iterator adaptors），两者的区别在于是否消费迭代器，即是否调用迭代器的 next 方法。</p><h3 id="消费者适配器"><a href="#消费者适配器" class="headerlink" title="消费者适配器"></a>消费者适配器</h3><p>消费者适配器（consuming adaptors）是迭代器上的方法，它会消费掉迭代器和迭代器中的元素，然后返回其类型的值，因此被称为消费。<br>这些消费者（方法）都有一个共同的特点：在它们的定义中，都依赖 next 方法来消费元素。这也是为什么迭代器要实现 Iterator 特征时必须要实现 next 方法的原因。</p><p>只要迭代器上的某个方法 A 在其内部调用了 next 方法，那么 A 就可以被称为消费性适配器。这是因为 next 方法会消耗掉迭代器上的元素，所以方法 A 的调用也会消耗掉迭代器上的元素。</p><p>其中一个例子是 sum 方法，它会拿走迭代器的所有权，然后通过不断调用 next 方法对里面的元素进行求和：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">iter</span> = v.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = iter.<span class="title function_ invoke__">sum</span>(); <span class="comment">// 消费者适配器需要标注数据类型</span></span><br><span class="line"><span class="comment">// println!(&quot;&#123;:#?&#125;&quot;, iter); 不能再访问iter，因为sum消费了迭代器和迭代器中的元素</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;total&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到 sum 函数的定义 <code>fn sum(self) &#123;&#125;</code>，拿走了迭代器的所有权：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>&lt;S&gt;(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> S</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">    S: Sum&lt;<span class="keyword">Self</span>::Item&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    Sum::<span class="title function_ invoke__">sum</span>(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><p>迭代器适配器（iterator adapters）即迭代器方法会返回一个新的迭代器，这是实现链式方法调用的关键：<code>v.iter().map().filter()...</code>。<br>与消费者适配器不同，迭代器适配器是惰性的，意味着需要一个<strong>消费者适配器来收尾</strong>，最终将迭代器转换成一个具体的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// v.iter().map(|x| x + 1); 仅有迭代器适配器是不行的，需要消费者适配器收尾</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">newV</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>(); <span class="comment">// 正常</span></span><br></pre></td></tr></table></figure><blockquote><p>为什么要区分消费者适配器和迭代器适配器两种方法呢？</p><p>Rust 语言在设计上非常注重内存安全和效率，这种设计哲学体现在它对迭代器模式的处理上。Rust 区分消费性适配器（consuming adaptors）和迭代器适配器（iterator adaptors）主要是为了提供更细粒度的控制以及更明确的语义。</p><p>消费性适配器（Consuming Adaptors）</p><p>消费性适配器是那些会消耗迭代器的方法，它们会遍历迭代器并返回一个最终的结果。这意味着一旦调用了消费性适配器，原来的迭代器就不能再使用了。在 Rust 中，collect()就是一个消费性适配器的例子，它可以将迭代器中的元素收集到一个集合类型中，比如 Vec、HashMap 等。</p><p>迭代器适配器（Iterator Adaptors）</p><p>迭代器适配器则是对迭代器进行转换，但不会立即进行任何遍历操作。它们返回的是一个新的迭代器，这个新迭代器会在每次遍历时应用某种操作。在 Rust 中，map()就是一个迭代器适配器的例子，它会创建一个新的迭代器，这个迭代器会在每次访问时应用一个函数到原迭代器的每个元素上。</p><ol><li>性能优化：Rust 的迭代器设计允许编译器在编译时进行更多的优化，比如通过迭代器链的懒惰求值来减少中间集合的创建，这可以显著提高程序的性能。</li><li>内存管理：Rust 通过所有权系统来保证内存安全，区分消费性适配器和迭代器适配器有助于明确所有权和借用的规则，避免悬垂指针和数据竞争等问题。</li><li>明确的语义：在 Rust 中，当你使用 collect()时，你明确地表达了你想要从迭代器中消费所有元素并生成一个集合。这种明确性有助于代码的可读性和维护性。</li></ol></blockquote><h3 id="collect-方法"><a href="#collect-方法" class="headerlink" title="collect 方法"></a>collect 方法</h3><p>在上面的案例中使用了一个非常强大的 collect 方法，该方法就是一个消费者适配器，它可以将一个迭代器中的元素<strong>收集到指定类型中</strong>。</p><p>如为收集变量标注 <code>Vec&lt;_&gt;</code> 类型，是为了告诉 collect：把迭代器中的元素消费掉，然后把值收集成 <code>Vec&lt;_&gt;</code> 类型，至于为何使用 _，因为编译器会帮我们自动推导。</p><p>collect 在消费时必须显式的指定想要收集成的集合类型，是因为该方法可以收集成多种不同的集合类型，如 Vec 和 HashMap。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集成Vec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">newV</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, newV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集成HashMap</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">names</span> = [<span class="string">&quot;sunface&quot;</span>, <span class="string">&quot;sunfei&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ages</span> = [<span class="number">18</span>, <span class="number">18</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">map</span>: HashMap&lt;_, _&gt; = names.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">zip</span>(ages.<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure><p>zip 是一个迭代器适配器，它的作用就是将两个迭代器的内容压缩到一起，形成 <code>Iterator&lt;Item=(ValueFromA, ValueFromB)&gt;</code> 这样的新的迭代器，在此处就是形如 <code>[(name1, age1), (name2, age2)]</code> 的迭代器，可以类比 JavaScript 中的 Entries 类型。</p><p>然后再通过 collect 将新迭代器中 <code>(K, V)</code> 形式的值收集成 <code>HashMap&lt;K, V&gt;</code>，同样的，这里必须显式声明类型，然后 HashMap 内部的 KV 类型可以交给编译器去推导，最终编译器会推导出 <code>HashMap&lt;&amp;str, i32&gt;</code>。</p><h3 id="闭包作为适配器参数"><a href="#闭包作为适配器参数" class="headerlink" title="闭包作为适配器参数"></a>闭包作为适配器参数</h3><p>之前的 map 方法中，使用闭包来作为迭代器适配器的参数，它最大的好处不仅在于可以就地实现迭代器中元素的处理，还在于可以<strong>捕获环境值</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;_&gt; = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">10</span>]</span><br><span class="line">    .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|x| &#123;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        index</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">level</span> = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">standards</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|x| *x &gt;= level).<span class="title function_ invoke__">collect</span>(); <span class="comment">// 捕获环境变量</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, standards)</span><br></pre></td></tr></table></figure><p>filter 是迭代器适配器，用于对迭代器中的每个值进行审计，符合条件则保留，反之则剔除。最后通过 collect 收集为 <code>Vec&lt;i32&gt;</code> 类型。</p><h3 id="实现-Iterator-特征"><a href="#实现-Iterator-特征" class="headerlink" title="实现 Iterator 特征"></a>实现 Iterator 特征</h3><p>Iterator 特征不仅仅局限于 <code>vec</code> 等内置数据类型，还可以为自定义类型实现 Iterator 特征（要求实现 next 方法），使自定义类型变为迭代器。注意，是将自定义类型变成迭代器（Iterator），而不是可迭代对象（IntoIterator）。</p><p>创建一个 counter struct：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123; count: <span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 Counter 实现 Iterator 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">     <span class="keyword">type</span> <span class="title class_">Item</span>: <span class="type">i32</span>;</span><br><span class="line">     <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">             <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">             <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="literal">None</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试 Counter 迭代器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = Counter::<span class="title function_ invoke__">new</span>()</span><br><span class="line">    .<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|(x, y)| x + y)</span><br><span class="line">    .<span class="title function_ invoke__">sum</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, total);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">vector</span>: <span class="type">Vec</span>&lt;_&gt; = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>)).<span class="title function_ invoke__">filter</span>(|x| *x &gt; <span class="number">0</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, vector);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">vector</span>: <span class="type">Vec</span>&lt;_&gt; = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">3</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, vector);</span><br><span class="line"></span><br><span class="line"><span class="comment">// turbo fish 语法</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">vector</span> = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">3</span>).collect::&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt;()();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, vector);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">total</span> = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">3</span>).sum::&lt;<span class="type">i32</span>&gt;();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, total);</span><br></pre></td></tr></table></figure><ul><li>skip 是一个迭代器适配器，它的作用是跳过迭代器中的前 n 个元素，然后返回一个新的迭代器。</li><li>zip 是一个迭代器适配器，它的作用就是将两个迭代器的内容压缩到一起，形成 <code>Iterator&lt;Item=(ValueFromA, ValueFromB)&gt;</code> 也就是形如 <code>[(name1, age1), (name2, age2)]</code> 的迭代器，可以类比 JavaScript 中的 Entries 类型。两者迭代器长度不一样时，以最短长度为结束条件。</li></ul><blockquote><p>turbo fish 语法参考<br>turbofish 语法可以允许不在变量上标注类型，在调用函数时传递目标类型以完成类型指定。</p><ul><li><a href="https://www.cnblogs.com/rotk2022/p/16449651.html">https://www.cnblogs.com/rotk2022/p/16449651.html</a></li><li><a href="https://rustwiki.org/zh-CN/edition-guide/rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html#%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE">https://rustwiki.org/zh-CN/edition-guide/rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html#%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE</a></li><li><a href="https://rust-lang.github.io/impl-trait-initiative/explainer/apit_turbofish.html">https://rust-lang.github.io/impl-trait-initiative/explainer/apit_turbofish.html</a></li></ul></blockquote><h4 id="实现-Iterator-特征的其它方法"><a href="#实现-Iterator-特征的其它方法" class="headerlink" title="实现 Iterator 特征的其它方法"></a>实现 Iterator 特征的其它方法</h4><p><strong>其他迭代器方法都具有基于 next 方法的默认实现</strong>，所以无需像 next 这样手动去实现。如上面案例使用到的 <code>zip, map, filter, sum</code> 等方法。</p><h5 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h5><p>enumerate 方法（迭代器适配器）是常用的迭代器方法，它能生成带有索引的迭代器，返回的结构为 <code>Iterator&lt;Item=(ValueA, ValueB)&gt;</code> 的迭代器，即 <code>(index, value)</code> 索引在前，值在后的结构。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">index</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">enumerate</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, index);</span><br></pre></td></tr></table></figure><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>迭代器是 Rust 的 零成本抽象（zero-cost abstractions）之一，意味着抽象并不会引入运行时开销，这与 Bjarne Stroustrup（C++ 的设计和实现者）在 Foundations of C++（2012） 中所定义的 零开销（zero-overhead）如出一辙。</p><blockquote><p>In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.<br>一般来说，C++的实现遵循零开销原则：没有使用时，你不必为其买单。 更进一步说，需要使用时，你也无法写出更优的代码了。</p><p>阅读：<a href="https://course.rs/advance/functional-programing/iterator.html#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD">https://course.rs/advance/functional-programing/iterator.html#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD</a></p></blockquote><h3 id="更多迭代器方法"><a href="#更多迭代器方法" class="headerlink" title="更多迭代器方法"></a>更多迭代器方法</h3><p>阅读：<a href="https://course.rs/std/iterator">https://course.rs/std/iterator</a></p><blockquote><p>疑问<br>rust 类型和值的关系非常巧妙，编译器可以通过变量的类型确定函数调用表达式的值，这属于什么原理。比如 let vector: Vec&lt;<em>&gt; &#x3D; vec![1,2].into_iter().map(|x| x+1).collect(); 可以通过标注 vector 的类型让 collect 知道要收集什么数据。</em></p><p>GPT:<br>这属于 Rust 的类型推断和类型系统的特性。Rust 的类型系统是静态的，意味着所有变量的类型都是在编译时确定的。Rust 编译器使用强大的类型推断算法来帮助开发者减少必须显式指定的类型数量，同时保持类型安全。<br>在你提到的例子中，let vector: Vec&lt;_&gt; &#x3D; vec!.into*iter().map(|x| x+1).collect();，Rust 编译器利用类型推断来确定 * 应该是什么类型。这里的 _ 是一个类型占位符，告诉编译器我们希望它自动推断这个位置的具体类型。编译器查看整个表达式，特别是 collect 方法的调用，来确定需要收集的数据类型。<br>collect 方法是一个非常灵活的方法，它可以将迭代器中的元素收集成多种集合类型，比如 Vec<T>、HashMap&lt;K, V&gt; 等。Rust 编译器通过变量的类型注解 Vec&lt;_&gt; 来推断出 _ 应该是 i32 类型，因为 map(|x| x+1) 中的 x+1 表达式产生 i32 类型的值。因此，编译器能够推断出整个表达式的类型，使得 collect 方法能够正确地收集数据。<br>这种类型推断机制使得 Rust 代码既简洁又类型安全。它允许开发者编写出既富有表达力又不失严谨的代码，而不需要像在某些其他语言中那样频繁地显式指定类型。这也是 Rust 类型系统的一个强大之处，它能够在编译时捕获更多的错误，减少运行时的错误。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = iter.<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:#?&#125;&quot;, iter); 不能再访问iter，因为sum消费了迭代器和迭代器中的元素</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;total&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = iter.<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;total&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">newV</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, newV);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">names</span> = [<span class="string">&quot;sunface&quot;</span>, <span class="string">&quot;sunfei&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ages</span> = [<span class="number">18</span>, <span class="number">18</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">map</span>: HashMap&lt;_, _&gt; = names.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">zip</span>(ages.<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;_&gt; = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">10</span>]</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| &#123;</span><br><span class="line">            index += <span class="number">1</span>;</span><br><span class="line">            index</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">level</span> = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">standards</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|x| *x &gt;= level).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, standards);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现一个迭代器非常方便，只需要手动实现next方法，其他的迭代器方法都有基于next方法的默认实现</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">        count: <span class="type">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">        <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">i32</span>;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="literal">None</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = Counter::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(x, y)| x + y)</span><br><span class="line">        .<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, total);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vector</span>: <span class="type">Vec</span>&lt;_&gt; = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">4</span>)).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, vector);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vector</span>: <span class="type">Vec</span>&lt;_&gt; = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">3</span>).<span class="title function_ invoke__">filter</span>(|x| *x &gt; <span class="number">0</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, vector);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// turbo fish语法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vector</span> = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">3</span>).<span class="title function_ invoke__">filter</span>(|x| *x &gt; <span class="number">0</span>).collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, vector);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span> = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">3</span>).<span class="title function_ invoke__">filter</span>(|x| *x &gt; <span class="number">0</span>).sum::&lt;<span class="type">i32</span>&gt;();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, total);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enumerate 生成带有索引的方法（迭代器适配器）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">enumerate</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, index);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代器 </tag>
            
            <tag> 可迭代对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 迭代器(Iterator)&amp;可迭代对象(IntoIterator)</title>
      <link href="/2024/04/13/rust-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-IntoIterator/"/>
      <url>/2024/04/13/rust-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-IntoIterator/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>从用途来看，迭代器跟 for 循环颇为相似，都是去遍历一个集合，但是实际上它们存在不小的差别，其中最主要的差别就是：是否通过索引来访问集合。</p><p>在 JavaScript 中，<code>for</code> 和 <code>for..of</code> 就是 for 循环和迭代器的代表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`index = <span class="subst">$&#123;i&#125;</span>, value = <span class="subst">$&#123;arr[i]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`value = <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器，调用特殊的方法，它的key是Symbol.iterator，可以理解成 arr.into_iter() 形式，它将返回一个迭代器</span></span><br><span class="line">arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br></pre></td></tr></table></figure><p>JavaScript 生成迭代器和可迭代对象非常容易：</p><ul><li>迭代器是指实现迭代器协议的对象(iterator protocol)，其具有特殊属性 <code>next</code> 函数的对象，next 函数返回一个 <code>&#123;value: any, done: boolean&#125;</code> 形式的对象。</li><li>可迭代对象是指实现可迭代协议(iterable protocol)的对象，它具有特殊的属性 <code>Symbol.iterator</code> 函数，这个函数返回迭代器，一个对象能否使用迭代器就看是否实现 <code>Symbol.iterator</code>。<br>迭代协议：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> iter = &#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">1</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: index, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">null</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iter.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>(); <span class="comment">// &#123;value: null, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>迭代器 next 函数返回值是 {value: any, done: boolean} 形式，所以只需要实现一个函数，循环调用一个对象（迭代器） next 函数取出值，当 next 函数给出终止信号 done &#x3D; true 时，停止函数流程，就能伪实现可迭代。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">into_iter</span>(<span class="params">arr: number[]</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (index &lt; arr.<span class="property">length</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: arr[index], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">null</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = <span class="title function_">into_iter</span>(arr);</span><br><span class="line">iterator.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 0, done: false&#125;;</span></span><br><span class="line">iterator.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;;</span></span><br><span class="line">iterator.<span class="title function_">next</span>(); <span class="comment">// &#123;value: null, done: true&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>流程再分析</strong></p><p>持续迭代终止时需要一个终止信号，它首先需要一个询问的对象，再者需要固定方式来获取终止信息的流程如循环调用 next 函数，现在询问对象是迭代器，循环调用 next 函数的流程就是迭代，也就是迭代迭代器以获取终止信号。</p><p>至此，补上迭代迭代器的流程，整体的可迭代就完成了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">forOf</span>(<span class="params">arr: number[]</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> iterator = <span class="title function_">into_iter</span>(arr);</span><br><span class="line">  <span class="keyword">while</span> (iterator.<span class="title function_">next</span>().<span class="property">done</span> === <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的模拟流程中，可以将迭代器视为单元算子，将可迭代过程视为整体流程，启动迭代后当单元算子给出终止信号时停止流程。</p><h3 id="For-循环与迭代器"><a href="#For-循环与迭代器" class="headerlink" title="For 循环与迭代器"></a>For 循环与迭代器</h3><p>rust 的迭代器协议和可迭代协议也是不同的概念，可以先记住名词。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">v</span> <span class="keyword">in</span> arr &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust 的 <code>for..in</code> 没有使用索引，它把 arr 数组当成一个迭代器，直接去遍历其中的元素，从哪里开始，从哪里结束，都无需操心。因此严格来说，Rust 中的 <strong>for 循环是编译器提供的语法糖</strong>，最终还是对迭代器中的元素进行遍历。</p><p>同时值得关注数组不是迭代器，但数组实现了 IntoIterator （可迭代）特征，Rust 通过 for 语法糖，自动把实现了该特征的数组类型转换为迭代器，以方便 <code>for..in</code> 进行迭代。<br>类似的快捷操作有 <code>for i in 1..10</code> 直接对数值序列进行迭代。</p><p>IntoIterator 特征拥有一个 <code>into_iter</code> 方法，因此我们还可以显式的把数组转换成迭代器 <code>for v in arr.into_iter() &#123;&#125;</code>，迭代器是函数语言的核心特性，它赋予了 Rust 远超于循环的强大表达能力。</p><h3 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h3><p>在 Rust 中，迭代器是惰性的，意味着如果你不使用它，那么它将不会发生任何事,</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>(); <span class="comment">// 迭代器惰性初始化，不会立即加载，而是使用到时才会开始加载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> v1_iter &#123; <span class="comment">// 迭代器开始加载</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代过程之前，只是简单的创建了一个迭代器 v1_iter，此时不会发生任何迭代行为，只有在 for 循环开始后，迭代器才会开始迭代其中的元素。<br>这种惰性初始化的方式确保了创建迭代器不会有任何额外的性能损耗，其中的元素也不会被消耗，只有使用到该迭代器的时候，一切才开始。</p><h3 id="next-函数"><a href="#next-函数" class="headerlink" title="next 函数"></a>next 函数</h3><p>rust 中 for 循环通过调用迭代器的 <code>next</code> 函数取出迭代器内的元素，迭代器之所以成为迭代器，就是因为实现了 <code>Iterator</code> 特征，要实现该特征，最主要的就是实现其中的 next 方法，该方法控制如何从集合中取值，最终返回值的类型是关联类型 Item。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">    <span class="comment">// 省略其余有默认实现的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 JavaScript 手动创建迭代器对象非常相似，两者都有 <code>next</code> 函数， for 循环通过不停调用迭代器上的 next 方法，来获取迭代器中的元素。</p><p>当然也可以手动执行 <code>next</code> 函数来获取迭代器中的元素，因为涉及到 rust 的所有权模型，所以 rust 的 next 调用需要牢记几点：</p><ul><li><code>next(&amp;mut self)</code> 是可变引用，调用者必须要可变（mut）。即手动迭代必须将迭代器声明为 mut，因为调用 next 会改变迭代器其中的状态数据（当前遍历的位置等），而 for 循环迭代自动标注 mut 可变。</li><li>rust 中有 Option 没有 undefined&#x2F;null，next 的返回是一个 Option 类型，即有值为 Some，无值时为 None</li><li>next 方法对迭代器的遍历是<strong>消耗性</strong>的，每次消耗它一个元素，最终迭代器中将没有任何元素，只能返回 None。</li><li>遍历是按照迭代器中元素的排列顺序依次进行的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line">iter.<span class="title function_ invoke__">next</span>(); <span class="comment">// Some(1)</span></span><br><span class="line">iter.<span class="title function_ invoke__">next</span>(); <span class="comment">// Some(2)</span></span><br><span class="line">iter.<span class="title function_ invoke__">next</span>(); <span class="comment">// None</span></span><br></pre></td></tr></table></figure><p>JavaScript 代码实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr.<span class="title function_">values</span>();</span><br><span class="line">iter.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>对比 JavaScript 代码可以猜测到，rust 迭代也是通过循环调用迭代器的 next 函数来实现的。</p><h4 id="实现-for-伪迭代"><a href="#实现-for-伪迭代" class="headerlink" title="实现 for 伪迭代"></a>实现 for 伪迭代</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">     <span class="keyword">match</span> iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">         <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;x&#125;&quot;</span>);</span><br><span class="line">         <span class="literal">None</span> =&gt; <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 JavaScript 将可迭代对象转换成迭代器一样，使生成的对象拥有 next 函数，然后循环调用，最终完成迭代。将其改造成 <code>forFn</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">forFn</span>&lt;T&gt;(iter: T)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">     T: <span class="built_in">Iterator</span>,</span><br><span class="line">     T::Item: std::fmt::<span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">loop</span> &#123;</span><br><span class="line">         <span class="keyword">match</span> iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">             <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;#?&#125;&quot;</span>, x);</span><br><span class="line">             <span class="literal">None</span> =&gt; <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_ invoke__">forFn</span>(v.<span class="title function_ invoke__">into_iter</span>()); <span class="comment">// 调用forFn进行迭代</span></span><br></pre></td></tr></table></figure><p>rust 的所有权决定了 into_iter 函数不好实现，因此可以先参考 JavaScript 实现方式来理解整个流程。</p><p>此外，可迭代对象除了通过 <code>into_iter</code> 函数转换成迭代器，还可以通过完全限定的方式即 <code>IntoIterator::into_iter(values)</code> 生成迭代器，这种调用方式跟 <code>values.into_iter()</code> 是等价的：</p><blockquote><p>完全限定：<a href="https://course.rs/basic/trait/advance-trait.html#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95">https://course.rs/basic/trait/advance-trait.html#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95</a></p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">values</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">match</span> <span class="built_in">IntoIterator</span>::<span class="title function_ invoke__">into_iter</span>(values) &#123;</span><br><span class="line">        <span class="keyword">mut</span> iter =&gt; <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(x) =&gt; &#123; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); &#125;,</span><br><span class="line">                <span class="literal">None</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IntoIterator-特征"><a href="#IntoIterator-特征" class="headerlink" title="IntoIterator 特征"></a>IntoIterator 特征</h3><p>由于 Vec 动态数组实现了 IntoIterator 特征，因此可以通过 into_iter 将其转换为迭代器，那如果本身就是一个迭代器，该怎么办？实际上，迭代器自身也实现了 IntoIterator 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;I: <span class="built_in">Iterator</span>&gt; <span class="built_in">IntoIterator</span> <span class="keyword">for</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = I::Item;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">IntoIter</span> = I;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">into_iter</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> I &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，迭代器可以使用 <code>into_iter</code> 方法，能形成以下代码，<strong>迭代器能够调用 into_iter 方法，返回的还是迭代器</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">v</span> <span class="keyword">in</span> values.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">into_iter</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="into-iter-iter-iter-mut"><a href="#into-iter-iter-iter-mut" class="headerlink" title="into_iter, iter, iter_mut"></a>into_iter, iter, iter_mut</h4><p>在之前的代码中，只使用了 into_iter 的方式将数组转化为迭代器，除此之外，还有 iter 和 iter_mut 两种变体：</p><ul><li>into_iter 会夺走所有权，next 函数返回的是 Option<T>，即 Some<T>和 None</li><li>iter 是不可变借用，next 函数返回的是 Option&lt;&amp;T&gt;，即 Some&lt;&amp;T&gt;和 None</li><li>iter_mut 是可变借用，next 函数返回的是 Option&lt;&amp;mut T&gt;，即 Some&lt;&amp;mut T&gt;和 None</li></ul><p>rust 方法的命名一般都遵守这个规则：<strong>into_ 之类的都是拿走所有权，_mut 之类的都是可变借用，剩下的就是不可变借用</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">into_iter</span>(); <span class="comment">// 移除v所有权</span></span><br><span class="line"><span class="comment">// println!(&quot;&#123;:#?&#125;&quot;, v); v被移除所有权，无法再次使用</span></span><br><span class="line">iter.<span class="title function_ invoke__">next</span>(); <span class="comment">// Option&lt;i32&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">iter_mut</span>(); <span class="comment">// 对 values 中的元素进行可变借用，注意可变引用需要来自可变变量，因此要求v mut可变</span></span><br><span class="line">iter.<span class="title function_ invoke__">next</span>(); <span class="comment">// Option&lt;&amp;mut i32&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">values</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = values.<span class="title function_ invoke__">iter</span>(); <span class="comment">// 对 values 进行不可变借用（只读）</span></span><br><span class="line">iter.<span class="title function_ invoke__">next</span>(); <span class="comment">// Option&lt;&amp;i32&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Iterator-和-IntoIterator-的区别"><a href="#Iterator-和-IntoIterator-的区别" class="headerlink" title="Iterator 和 IntoIterator 的区别"></a>Iterator 和 IntoIterator 的区别</h4><p>Iterator 和 IntoIterator 两者与 JavaScript 迭代器中的迭代器协议和可迭代协议是类似的。</p><p>Iterator 是迭代器特征，只有实现了它才能称为迭代器，才能调用 next 方法。而 IntoIterator 可以称为可迭代对象特征，强调的是某一个类型如果实现了该特征，它可以通过 into_iter，iter_mut，iter 等方法变成一个迭代器。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line">    iter.<span class="title function_ invoke__">next</span>();</span><br><span class="line">    iter.<span class="title function_ invoke__">next</span>();</span><br><span class="line">    iter.<span class="title function_ invoke__">next</span>();</span><br><span class="line">    iter.<span class="title function_ invoke__">next</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap_or_default</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap_or_default</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap_or_default</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap_or_default</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现for循环迭代功能</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">forFn</span>&lt;T&gt;(<span class="keyword">mut</span> iter: T)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: <span class="built_in">Iterator</span>,</span><br><span class="line">        T::Item: std::fmt::<span class="built_in">Debug</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(x) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="literal">None</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">forFn</span>(iter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">forFn</span>(v.<span class="title function_ invoke__">into_iter</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:#?&#125;&quot;, v);</span></span><br><span class="line">    v.<span class="title function_ invoke__">into_iter</span>(); <span class="comment">// 移除v所有权</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// into_mut 移动所有权</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = iter.<span class="title function_ invoke__">next</span>(); <span class="comment">// 需要移动所有权，即需要iter可变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// iter_mut 可变借用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">iter_mut</span>();</span><br><span class="line">    <span class="comment">// 取出第一个元素，并修改为0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = iter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        *v = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iter 不可变借用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = v.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = iter.<span class="title function_ invoke__">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代器 </tag>
            
            <tag> 可迭代对象 </tag>
            
            <tag> Iterator </tag>
            
            <tag> IntoIterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue: 记录纯函数调用组件，jsx不生效的过程</title>
      <link href="/2024/04/12/vue-%E8%AE%B0%E5%BD%95%E7%BA%AF%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%8Cjsx%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/04/12/vue-%E8%AE%B0%E5%BD%95%E7%BA%AF%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%8Cjsx%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>今天遇到以函数调用形式调用 <code>tsx</code> 组件，没想到编译后的代码不能获取到对应的组件。这是因为 <code>resolveComponent</code> 只解析已在 Vue 实例中全局注册的组件。在 <code>template</code> 或 <code>script setup</code> 中能正常解析 <code>tsx</code> 组件是因为在 vite 中配置了对应的解析插件。</p><p>经过这个案例，加深了对 Vue 编译过程的了解。</p><p><strong>调用方式</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onDeleteRole</span> = <span class="keyword">async</span> (<span class="params">id: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">validatePasswd</span>(<span class="string">&quot;是否确认删除？&quot;</span>, <span class="keyword">async</span> (passwd) =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">deleteRole</span>(id, <span class="title function_">rsaEncrypt</span>(passwd) <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">        listRef.<span class="property">value</span>?.<span class="title function_">reload</span>();</span><br><span class="line">        <span class="title class_">Message</span>.<span class="title function_">success</span>(<span class="string">&quot;操作成功&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>错误代码</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, h &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useLoading <span class="keyword">from</span> <span class="string">&quot;@/hooks/loading&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Modal</span>, <span class="title class_">FormInstance</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@arco-design/web-vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">validatePasswd</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  title: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  callback: (passwd: <span class="built_in">string</span>) =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">unknown</span>&gt; | <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  validate?: (passwd: <span class="built_in">string</span>) =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">unknown</span>&gt; | <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; loading, setLoading &#125; = <span class="title function_">useLoading</span>();</span><br><span class="line">  <span class="keyword">const</span> form = <span class="title function_">ref</span>(&#123; <span class="attr">passwd</span>: <span class="string">&quot;&quot;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> formRef = ref&lt;<span class="title class_">FormInstance</span>&gt;();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">a-spin</span>&gt;</span><span class="tag">&lt;/<span class="name">a-spin</span>&gt;</span></span>); <span class="comment">// undefined</span></span><br><span class="line">  <span class="title class_">Modal</span>.<span class="title function_">confirm</span>(&#123;</span><br><span class="line">    title,</span><br><span class="line">    <span class="attr">hideCancel</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">440</span>,</span><br><span class="line">    <span class="attr">modalClass</span>: <span class="string">&quot;passwd-modal&quot;</span>,</span><br><span class="line">    <span class="attr">content</span>: <span class="function">() =&gt;</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">a-spin</span> <span class="attr">loading</span>=<span class="string">&#123;loading.value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;console.log(h(&quot;a-form&quot;))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a-form</span> <span class="attr">ref</span>=<span class="string">&#123;formRef&#125;</span> <span class="attr">model</span>=<span class="string">&#123;form.value&#125;</span> <span class="attr">auto-label-width</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a-form-item</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">label</span>=<span class="string">&quot;校验密码&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">required</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">rules</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">required:</span> <span class="attr">true</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">validator:</span> (<span class="attr">value:</span> <span class="attr">string</span>, <span class="attr">cb</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                if (value) &#123;</span></span><br><span class="line"><span class="language-xml">                  cb();</span></span><br><span class="line"><span class="language-xml">                &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">                  cb(&quot;当前用户密码不能为空&quot;);</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">              &#125;,</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          &gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">a-input-password</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">v-model</span>=<span class="string">&#123;[form.value.passwd,</span> &quot;<span class="attr">modelValue</span>&quot;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">placeholder</span>=<span class="string">&quot;请输入当前用户密码&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span><span class="tag">&lt;/<span class="name">a-input-password</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">a-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">a-form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">a-spin</span>&gt;</span></span></span><br><span class="line">    ),</span><br><span class="line">    <span class="attr">onBeforeOk</span>: <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> error = <span class="keyword">await</span> formRef.<span class="property">value</span>?.<span class="title function_">validate</span>();</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">const</span> passport1 = <span class="keyword">await</span> validate?.(form.<span class="property">value</span>.<span class="property">passwd</span>);</span><br><span class="line">        <span class="keyword">if</span> (passport1 === <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> passport2 = <span class="keyword">await</span> <span class="title function_">callback</span>(form.<span class="property">value</span>.<span class="property">passwd</span>);</span><br><span class="line">        <span class="keyword">if</span> (passport2 === <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> validatePasswd;</span><br></pre></td></tr></table></figure><p><strong>正确代码</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, h &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> useLoading <span class="keyword">from</span> <span class="string">&quot;@/hooks/loading&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">Modal</span>,</span><br><span class="line">  <span class="title class_">FormInstance</span>,</span><br><span class="line">  <span class="title class_">Spin</span>,</span><br><span class="line">  <span class="title class_">Form</span>,</span><br><span class="line">  <span class="title class_">FormItem</span>,</span><br><span class="line">  <span class="title class_">InputPassword</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;@arco-design/web-vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">validatePasswd</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  title: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  callback: (passwd: <span class="built_in">string</span>) =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">unknown</span>&gt; | <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  validate?: (passwd: <span class="built_in">string</span>) =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">unknown</span>&gt; | <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; loading, setLoading &#125; = <span class="title function_">useLoading</span>();</span><br><span class="line">  <span class="keyword">const</span> form = <span class="title function_">ref</span>(&#123; <span class="attr">passwd</span>: <span class="string">&quot;&quot;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> formRef = ref&lt;<span class="title class_">FormInstance</span>&gt;();</span><br><span class="line">  <span class="title class_">Modal</span>.<span class="title function_">confirm</span>(&#123;</span><br><span class="line">    title,</span><br><span class="line">    <span class="attr">hideCancel</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">440</span>,</span><br><span class="line">    <span class="attr">modalClass</span>: <span class="string">&quot;passwd-modal&quot;</span>,</span><br><span class="line">    <span class="attr">content</span>: <span class="function">() =&gt;</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Spin</span> <span class="attr">loading</span>=<span class="string">&#123;loading.value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Form</span> <span class="attr">ref</span>=<span class="string">&#123;formRef&#125;</span> <span class="attr">model</span>=<span class="string">&#123;form.value&#125;</span> <span class="attr">auto-label-width</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">FormItem</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">label</span>=<span class="string">&quot;校验密码&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">required</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">field</span>=<span class="string">&quot;passwd&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">rules</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">required:</span> <span class="attr">true</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">validator:</span> (<span class="attr">value:</span> <span class="attr">string</span>, <span class="attr">cb</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                if (value) &#123;</span></span><br><span class="line"><span class="language-xml">                  cb();</span></span><br><span class="line"><span class="language-xml">                &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">                  cb(&quot;当前用户密码不能为空&quot;);</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">              &#125;,</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          &gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">InputPassword</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">v-model</span>=<span class="string">&#123;[form.value.passwd,</span> &quot;<span class="attr">modelValue</span>&quot;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">placeholder</span>=<span class="string">&quot;请输入当前用户密码&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span><span class="tag">&lt;/<span class="name">InputPassword</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Spin</span>&gt;</span></span></span><br><span class="line">    ),</span><br><span class="line">    <span class="attr">onBeforeOk</span>: <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> error = <span class="keyword">await</span> formRef.<span class="property">value</span>?.<span class="title function_">validate</span>();</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">const</span> passport1 = <span class="keyword">await</span> validate?.(form.<span class="property">value</span>.<span class="property">passwd</span>);</span><br><span class="line">        <span class="keyword">if</span> (passport1 === <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> passport2 = <span class="keyword">await</span> <span class="title function_">callback</span>(form.<span class="property">value</span>.<span class="property">passwd</span>);</span><br><span class="line">        <span class="keyword">if</span> (passport2 === <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> validatePasswd;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成长：简历问题</title>
      <link href="/2024/03/28/%E6%88%90%E9%95%BF%EF%BC%9A%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/28/%E6%88%90%E9%95%BF%EF%BC%9A%E7%AE%80%E5%8E%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li><p>简历模板可以选简洁风格的，极简简历那种风格就行。研发还是将版面留给技术介绍吧，复杂的第一印象其实是不太想看。</p></li><li><p>求职意向可以合并到基本信息，有经验和求职意向的信息就可以。</p></li><li><p>专业技能看起来挺多的，但其实找不到具体会什么，给一个个人例子：每一项给出具体技术栈后用精简语句描述成果，可以选几个往自己身上套一下。</p><blockquote><p>专业技能</p><ul><li>良好的项目组织能力，能总结形成规范的开发流程，降低二次开发类似流程的成本。如使用配置驱动视图的思想对嵌套表单进行全体校验和部分校验。</li><li>良好的代码风格，有目的性的应用设计模式降低维护成本，如使用责任链模式开发二次验证流程。</li><li>优秀的编码能力和准确的开发估时，拥有数据可视化的经验，有节奏的推动开发进度，曾在三天内支持客户完成巡检大屏。</li><li>深入理解 JavaScript、ES6+、原型，熟悉 CSS，了解浏览器渲染原理，熟悉 Web 安全。</li><li>熟练掌握 Vue 技术栈，在项目中配合 TSX 提高开发效率，同时在博客中归纳多个常见问题的解决方案。个人项目技术栈为React。</li><li>熟悉 TypeScript，在 npmjs.org 中发布常用 hooks 和工具函数，特别的个人的 useExtRouter hook 使用依赖倒置原则实现了零侵入router但拓展其功能配置。</li><li>良好的算法基础，对常见的算法有自己的理解逻辑，在 leetcode 和 Github 上发布近百篇算法博客。</li><li>熟悉前后端分离开发，个人拥有后端基础开发经验，熟悉 SprintBoot 和 Nestjs，了解 Rust 和 Electron，能搭建完整的 CI&#x2F;CD。</li></ul></blockquote></li><li><p>工作经验主要写自己产出的价值以及你是怎么协调开发时间的，如支持开发对接并准时完成四个客户的项目。工作经验是大视角下总结你在公司的经历，不需要细化到项目技术上。突出你对项目的负责任的态度、产出的价值，已经你怎么规划自己在项目中的位置。</p></li><li><p>项目经验我认为可以不用很多，因为作为开发，其实技术栈总是那么几个。这个部分我认为需要突出在开发项目时遇到的困难点、展示技术实力以及解决问题的方式，比如遇到了流程编排的难点，我负责某个框架解决了问题，突出这是别人替代不了的。</p><p>项目职责可以改成工作内容/成果，其实我觉得工作经历和项目经验还是不分开为好，在一个部分中写完重要的部分，不会显得很零碎，结合着写产出和技术栈会更有说服力。写的时候再配合专业技能提到的点继续展开技术和业务（比如简历提到的注册、登录功能，可以展开说用了什么设计模式，怎么规划代码的），这样感觉就挺好的。</p></li><li><p>建议</p><ol><li>简历统一技术栈的大小写和分隔符号</li><li>简历统一结尾的符号，要么不填</li><li><code>用户未登录时可以浏览商品</code> 这个描述的是需求，应该描述为：设计合理的权限模型，如xxx，让用户体验良好</li><li><code>支持优惠券，满减多种支付方式</code> 这个就可以用策略模式展开说</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript: 循环和迭代器</title>
      <link href="/2024/03/27/JavaScript-%E5%BE%AA%E7%8E%AF%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2024/03/27/JavaScript-%E5%BE%AA%E7%8E%AF%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="循环和迭代器"><a href="#循环和迭代器" class="headerlink" title="循环和迭代器"></a>循环和迭代器</h2><p>从用途来看，迭代器跟 for 循环颇为相似，都是去遍历一个集合，但是实际上它们存在不小的差别，其中最主要的差别就是：是否通过索引来访问集合。</p><p>在 JavaScript 中，<code>for</code> 和 <code>for..of</code> 就是 for 循环和迭代器的代表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`index = <span class="subst">$&#123;i&#125;</span>, value = <span class="subst">$&#123;arr[i]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`value = <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器，调用特殊的方法，它的key是Symbol.iterator，可以理解成 arr.into_iter() 形式，它将返回一个迭代器</span></span><br><span class="line">arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br></pre></td></tr></table></figure><p>JavaScript 生成迭代器和可迭代对象非常容易：</p><ul><li>迭代器是指实现迭代器协议的对象(iterator protocol)，其具有特殊属性 <code>next</code> 函数的对象，next 函数返回一个 <code>&#123;value: any, done: boolean&#125;</code> 形式的对象。</li><li>可迭代对象是指实现可迭代协议(iterable protocol)的对象，它具有特殊的属性 <code>Symbol.iterator</code> 函数，这个函数返回迭代器，一个对象能否使用迭代器就看是否实现 <code>Symbol.iterator</code>。<br>迭代协议：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> iter = &#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">1</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: index, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">null</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iter.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>(); <span class="comment">// &#123;value: null, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>迭代器 next 函数返回值是 {value: any, done: boolean} 形式，所以只需要实现一个函数，循环调用一个对象（迭代器） next 函数，当 next 函数给出终止信号 done &#x3D; true 时，停止函数流程，就能伪实现可迭代。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_ invoke__">into_iter</span>(arr: number[]) &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">         next: () =&gt; &#123;</span><br><span class="line">             <span class="title function_ invoke__">if</span>(index &lt; arr.length) <span class="keyword">return</span> &#123; value: arr[index], done: <span class="literal">false</span> &#125;;</span><br><span class="line">             <span class="keyword">return</span> &#123; value: null, done: <span class="literal">true</span> &#125;;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = <span class="title function_ invoke__">into_iter</span>(arr);</span><br><span class="line">iterator.<span class="title function_ invoke__">next</span>(); <span class="comment">// &#123;value: 0, done: false&#125;;</span></span><br><span class="line">iterator.<span class="title function_ invoke__">next</span>(); <span class="comment">// &#123;value: 1, done: false&#125;;</span></span><br><span class="line">iterator.<span class="title function_ invoke__">next</span>(); <span class="comment">// &#123;value: null, done: true&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>流程再分析</strong></p><p>持续迭代终止时需要一个终止信号，它首先需要一个询问的对象，再者需要固定方式来获取终止信息的流程如循环调用 next 函数，现在询问对象是迭代器，循环调用 next 函数的流程就是迭代，也就是迭代迭代器以获取终止信号。</p><p>至此，补上迭代迭代器的流程，整体的可迭代就完成了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">forOf</span>(<span class="params">arr: number[]</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> iterator = <span class="title function_">into_iter</span>(arr);</span><br><span class="line">  <span class="keyword">while</span> (iterator.<span class="title function_">next</span>().<span class="property">done</span> === <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的模拟流程中，可以将迭代器视为单元算子，将可迭代过程视为整体流程，启动迭代后当单元算子给出终止信号时停止流程。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 闭包 Closure（三）当闭包作为函数参数或函数返回值时正确标注函数签名</title>
      <link href="/2024/03/26/rust-%E9%97%AD%E5%8C%85-Closure%EF%BC%88%E4%B8%89%EF%BC%89%E5%BD%93%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%88%96%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%A0%87%E6%B3%A8%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/"/>
      <url>/2024/03/26/rust-%E9%97%AD%E5%8C%85-Closure%EF%BC%88%E4%B8%89%EF%BC%89%E5%BD%93%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%88%96%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%A0%87%E6%B3%A8%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包-Closure（三）当闭包作为函数参数或函数返回值时正确标注函数签名"><a href="#闭包-Closure（三）当闭包作为函数参数或函数返回值时正确标注函数签名" class="headerlink" title="闭包 Closure（三）当闭包作为函数参数或函数返回值时正确标注函数签名"></a>闭包 Closure（三）当闭包作为函数参数或函数返回值时正确标注函数签名</h2><blockquote><p>本章内容较长，且在本章内容尾部更新了对闭包的认识，读者应读完全章，不要取其中部分。</p></blockquote><p>闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值。</p><p>Rust 闭包在形式上借鉴了 Smalltalk 和 Ruby 语言，与函数最大的不同就是它的参数是通过 |parm1| 的形式进行声明，如果是多个参数就 |param1, param2,…|，闭包的形式定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|param1, param2,...| &#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    返回表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包作为函数返回值"><a href="#闭包作为函数返回值" class="headerlink" title="闭包作为函数返回值"></a>闭包作为函数返回值</h3><p>在实现 <code>Cacher</code> 中我们将闭包作为参数传递给函数（方法），现在考虑如何将闭包应用在函数的返回值上，因为只有这样，才能将内部值传递出去。</p><p>闭包在 Rust 中有一个独特的特性：每个闭包都有其自己独特的匿名类型（这个类型就是类似 <code>i32 String</code> 的一种数据格式类型），这是因为<strong>闭包类型不仅仅是由其参数和返回类型定义</strong>的，还包括它捕获的环境。每个闭包根据其捕获的环境（变量、生命周期等）具有不同的类型。<br>即使两个闭包有相同的签名，它们也被认为是不同的类型。这意味着直接返回闭包类型（<code>Fn(i32) -&gt; i32</code>）是不可能的，因为闭包的具体类型是未知的，且无法直接命名。</p><h4 id="正确标注闭包作为函数返回值"><a href="#正确标注闭包作为函数返回值" class="headerlink" title="正确标注闭包作为函数返回值"></a>正确标注闭包作为函数返回值</h4><p>使用 impl Trait 语法允许我们返回一个实现了指定 trait 的类型，而不需要指定具体的类型。（impl Trait 形式来说明一个函数返回了一个类型，该类型实现了某个特征，外部使用时只能使用该特征已声明的属性）(函数返回中的 impl trait)[<a href="https://course.rs/basic/trait/trait.html#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%AD%E7%9A%84-impl-trait]">https://course.rs/basic/trait/trait.html#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%AD%E7%9A%84-impl-trait]</a><br>使用 <code>impl trait</code> 形式将闭包标识为实现了某个特征的类型后就可以返回。在闭包的场景中，Fn、FnMut、FnOnce 它们分别对应不同的闭包类型。通过返回 impl Fn(参数类型) -&gt; 返回值类型，这将告诉 Rust 编译器，返回一个实现了 Fn trait 的类型，但不指定具体是哪个类型。<br>简而言之，impl 关键词的使用是因为闭包的类型是匿名且不可直接命名的，而 impl Trait 语法允许我们以一种抽象的方式返回实现了特定 trait 的闭包，而无需关心闭包的具体类型。这大大增加了代码的灵活性和可重用性。</p><p>为什么闭包作为函数的参数时不需要显式的指定 impl ？<br>当闭包作为参数传递给函数时，<strong>不需要</strong>使用 impl 关键字，是因为在这种情况下可以直接指定闭包参数遵循的特定 trait（如 Fn、FnMut 或 FnOnce）。<br>这是通过使用<strong>trait 界定（trait bounds）</strong>来实现的(简单理解为自动推断和实现)，它允许函数接受任何实现了指定 trait 的类型。这种方式提供了足够的灵活性，同时避免了 impl Trait 在参数位置的使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">factory</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">move</span> |x| x + num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">factory</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">answer</span> = <span class="title function_ invoke__">f</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">6</span>, answer);</span><br></pre></td></tr></table></figure><p>用 <code>impl trait</code> 形式实现闭包作为返回值返回，最大的问题是 <code>impl trait</code> 要求返回只能有一个具体的类型。而闭包即使签名一致也可能是不同的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">编译错误 error</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">factory</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">1</span> &#123;</span><br><span class="line">        |x| x + num</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         |x| x - num</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 impl trait 相对应的，动态特征对象不限制某一个具体的类型，因此可改为使用动态特征对象解决这个问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">factory</span>(x:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">1</span>&#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> |x| x + num) <span class="comment">// 仅实现了Fn特征，需要将所有权强制移入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> |x| x - num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当闭包作为函数参数或函数返回值时如何正确的标注函数签名？</p><p>首先，Rust 要求函数的参数和返回值的内存大小是固定的，因此闭包作为 Trait，它的内存大小不固定，如 <code>Fn(i32) -&gt; i32</code> 是不能够直接作为参数和返回值的。<br>但有特殊情况，把闭包当作参数时，可以直接声明为闭包类型如 <code>Fn(i32) -&gt; i32</code>，这是因为函数体内的<strong>参数闭包</strong>有且只有一种闭包类型，Rust 通过使用<strong>trait 界定（trait bounds）</strong>允许函数接受任何实现了指定 trait 的类型。<br>可以理解成 Rust 自动推断为 <code>impl trait</code> 形式。这种参数闭包直接声明为闭包类型的方式提供了足够的灵活性，同时避免了 impl Trait 直接在参数位置的使用。</p><p>其次，闭包作为返回值时，为了遵守 “Rust 要求函数的参数和返回值的内存大小是固定的” 的原则，不能直接将闭包类型作为函数的返回值声明，而应该使用 <code>impl trait</code> 或特征对象。<br>如果只有一种闭包，那么可以直接使用 <code>impl trait</code> 形式，如 <code>impl Fn(i32) -&gt; i32</code>，表明返回一个实现了指定 trait 的类型，impl Trait 形式来说明一个函数返回了一个类型，该类型实现了某个特征，外部使用时只能使用该特征已声明的属性，因此是固定大小的。(函数返回中的 impl trait)[<a href="https://course.rs/basic/trait/trait.html#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%AD%E7%9A%84-impl-trait]">https://course.rs/basic/trait/trait.html#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%AD%E7%9A%84-impl-trait]</a><br>如果存在多个闭包类型，那么可以使用特征对象 <code>Box&lt;dyn Fn(i32) -&gt; i32&gt;</code> 来作为函数的返回值。</p><blockquote><p>多个闭包类型即多个位置声明定义的闭包，每个闭包都有其自己独特的匿名类型（这个类型就是类似 <code>i32 String</code> 的一种数据格式类型），这是因为<strong>闭包类型不仅仅是由其参数和返回类型定义</strong>的，还包括它捕获的环境。每个闭包根据其捕获的环境（变量、生命周期等）具有不同的类型。</p></blockquote><p>同时，当函数返回闭包时，需要注意返回的闭包是否具有变量的所有权，因为只有闭包获取了变量的所有权，在当前函数执行结束返回后，变量才不会被释放，才不会出现引用问题。当闭包作为函数的返回值返回时，常见的闭包都会有 <code>move</code> 关键字强制获取变量的所有权。</p><h3 id="amp-mut-amp-mut-的各种位置认识"><a href="#amp-mut-amp-mut-的各种位置认识" class="headerlink" title="&amp; mut &amp;mut 的各种位置认识"></a>&amp; mut &amp;mut 的各种位置认识</h3><p>阅读：<a href="https://github.com/sunface/rust-course/discussions/619#discussioncomment-2623736">https://github.com/sunface/rust-course/discussions/619#discussioncomment-2623736</a></p><ul><li>fn do1(c: String) {}：表示实参会将所有权传递给 c</li><li>fn do2(c: &amp;String) {}：表示实参的不可变引用（指针）传递给 c，实参需带 &amp; 声明</li><li>fn do3(c: &amp;mut String) {}：表示实参可变引用（指针）传递给 c，实参需带 let mut 声明，且传入需带 &amp;mut</li><li>fn do4(mut c: String) {}：表示实参会将所有权传递给 c，且在函数体内 c 是可读可写的，实参无需 mut 声明</li><li>fn do5(mut c: &amp;mut String) {}：表示实参可变引用指向的值传递给 c，且 c 在函数体内部是可读可写的，实参需带 let mut 声明，且传入需带 &amp;mut</li></ul><p>一句话总结：在函数参数中，冒号左边的部分，如：mut c，这个 mut 是对 🪄 函数体内部有效 🪄；冒号右边的部分，如：&amp;mut String，这个 &amp;mut 是针对 🪄 外部实参传入时的形式（声明）说明 🪄。</p><h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><ul><li><a href="https://course.rs/basic/trait/intro.html">泛型、特征、特征对象</a></li><li><a href="https://www.cnblogs.com/lilpig/p/17022845.html#%E5%A4%8D%E6%9D%82%E4%B8%80%E7%82%B9%E6%8A%8A%E9%97%AD%E5%8C%85%E7%94%A8%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%8A">闭包的使用案例</a></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">factory</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">closure</span> = <span class="keyword">move</span> |a| x + a;</span><br><span class="line">        closure</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="title function_ invoke__">factory</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">f</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// impl trait 只允许一种具体的类型，在有多种类型返回值时不适用</span></span><br><span class="line">    <span class="comment">// fn factory(x: i32) -&gt; impl Fn(i32) -&gt; i32 &#123;</span></span><br><span class="line">    <span class="comment">//     let num = 5;</span></span><br><span class="line">    <span class="comment">//     if x &gt; 1 &#123;</span></span><br><span class="line">    <span class="comment">//         |x| x + num</span></span><br><span class="line">    <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//         |x| x - num</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">factoryDyn</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> |x| x + num)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> |x| x - num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>rust: 闭包 Closure（二）重新认识闭包</title>
      <link href="/2024/03/25/rust-%E9%97%AD%E5%8C%85-Closure%EF%BC%88%E4%BA%8C%EF%BC%89%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E9%97%AD%E5%8C%85/"/>
      <url>/2024/03/25/rust-%E9%97%AD%E5%8C%85-Closure%EF%BC%88%E4%BA%8C%EF%BC%89%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包-Closure（二）重新认识闭包"><a href="#闭包-Closure（二）重新认识闭包" class="headerlink" title="闭包 Closure（二）重新认识闭包"></a>闭包 Closure（二）重新认识闭包</h2><blockquote><p>本章内容较长，且在本章内容尾部更新了对闭包的认识，读者应读完全章，不要取其中部分。</p></blockquote><p>闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值。</p><p>Rust 闭包在形式上借鉴了 Smalltalk 和 Ruby 语言，与函数最大的不同就是它的参数是通过 |parm1| 的形式进行声明，如果是多个参数就 |param1, param2,…|，闭包的形式定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|param1, param2,...| &#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    返回表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种-Fn-特征"><a href="#三种-Fn-特征" class="headerlink" title="三种 Fn 特征"></a>三种 Fn 特征</h3><p>闭包捕获变量有三种途径，恰好对应函数参数的三种传入方式：转移所有权、可变借用、不可变借用，因此相应的 Fn 特征也有三种：FnOnce、FnMut、Fn。</p><h3 id="FnOnce"><a href="#FnOnce" class="headerlink" title="FnOnce"></a>FnOnce</h3><p>FnOnce，该类型的闭包会拿走<strong>被捕获变量的所有权</strong>，因此该闭包只能运行一次，这也是 Once 的来源。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fn_once</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_ invoke__">fn_once</span>(|z| &#123; z == x.<span class="title function_ invoke__">len</span>() &#125;)</span><br></pre></td></tr></table></figure><p>仅实现 FnOnce 特征的闭包在调用时会转移被捕获变量的所有权，因此不能对闭包进行二次调用（内部被捕获的变量失去所有权，调用会出错）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>(<span class="number">4</span>)); <span class="comment">// 调用报错，在调用func(3)后，x变量已经失去所有权，再次使用x变量导致出错</span></span><br></pre></td></tr></table></figure><p>如何解决这个问题呢？只需要给传入的闭包加上 Copy 特征，闭包就能够对被捕获的变量自动 Copy，这样就不存在所有权的问题了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fn_once</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> + <span class="built_in">Copy</span> <span class="comment">// 增加Copy Trait，闭包能够对被捕获的变量自动Copy，就不存在所有权的问题了。</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>另外：如果想强制闭包取得捕获变量的所有权，可以在参数列表前添加 move 关键字，这种用法通常用于闭包的生命周期大于捕获变量的生命周期时，例如将闭包返回或移入其他线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_ invoke__">fn_once</span>(<span class="keyword">move</span> |z| &#123; z == x.<span class="title function_ invoke__">len</span>() &#125;); <span class="comment">// 强制闭包取得捕获变量的所有权</span></span><br></pre></td></tr></table></figure><h3 id="FnMut"><a href="#FnMut" class="headerlink" title="FnMut"></a>FnMut</h3><p>FnMut，它以可变借用的方式捕获了环境中的值，因此可以修改该值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">update_string</span> =  |<span class="type">str</span>| s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>);</span><br><span class="line"><span class="title function_ invoke__">update_string</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>在闭包中，我们调用 s.push_str 去改变外部 s 的字符串值，<code>push_str(&amp;mut self)</code> 需要变量的可变借用，因此这里闭包捕获了它的可变借用的<strong>使用</strong>操作。<br>执行后报错了，想要在闭包内部捕获**可变借用&lt;操作&gt;**，需要把该闭包变量声明为可变类型，也就是 update_string 要修改为 mut update_string：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">update_string</span> = |<span class="type">str</span>| s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>);</span><br><span class="line"><span class="title function_ invoke__">update_string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>闭包捕获变量的可变借用的<strong>使用</strong>操作，闭包就会变为 FnMut 类型，对应的变量也需要设置为可变才能够调用闭包。注意：FnMut 是类型。<br>这种写法有点反直觉，但如果把闭包变量仅仅当成一个普通变量，那么这种声明就比较合理了（可变需要来自可变）。</p><h3 id="Fn"><a href="#Fn" class="headerlink" title="Fn"></a>Fn</h3><p>仅需要不可变地访问其上下文的函数属于 Fn trait，并且只要上下文在作用域中存在，就可以在任意位置调用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包类型只与闭包怎么**使用**被捕获变量的操作有关系，与变量自己的类型、捕获变量的方式没有直接关系</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">update_string</span> = |<span class="type">str</span>| s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>); <span class="comment">// FnMut</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">update_string</span> = |<span class="type">str</span>| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>()); <span class="comment">// Fn</span></span><br><span class="line"><span class="title function_ invoke__">update_string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>为什么是不可变引用的使用操作？从 len 函数的第一个参数 Self 中可以看到 <code>&amp;self</code> 是一个不可变引用。</p><h3 id="闭包是所有权状态的描述"><a href="#闭包是所有权状态的描述" class="headerlink" title="闭包是所有权状态的描述"></a>闭包是所有权状态的描述</h3><p>闭包其实就是所有权各种状态的描述：拥有所有权、所有权的可变引用、所有权的独不可变引用、没有所有权，对应到闭包的类型就为 FnOnce、FnMut、Fn、fn。<br>所以闭包的类型与被捕获的变量类型没有关系，而是与闭包怎么<strong>使用</strong>被捕获变量有关系，捕获操作简单来说是怎么使用变量。</p><p>比如上述（FnMut）的例子中，闭包捕获到变量进行了可变引用的使用操作这个动作，那么闭包就成为 FnMut 类型，这意味着闭包被调用时会修改被捕获的变量。如果改成以下示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包类型只与闭包怎么**使用**被捕获变量的操作有关系，与变量自己的类型、捕获变量的方式没有直接关系</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">update_string</span> = |<span class="type">str</span>| s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>); <span class="comment">// FnMut</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">update_string</span> = |<span class="type">str</span>| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>()); <span class="comment">// Fn</span></span><br><span class="line"><span class="title function_ invoke__">update_string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>变量的可变引用可以进行可变引用操作 <code>s.push_str()</code>，因为 <code>push_str</code> 的 <code>Self</code> 为 <code>&amp;mut self</code>，被闭包捕获可变引用的使用操作，那么闭包就为 FnMut；</li><li>变量的可变引用也可以进行不可变引用操作 <code>s.len()</code>，因为 <code>len</code> 的 <code>Self</code> 为 <code>&amp;self</code>，被闭包捕获不可变引用的使用操作，那么闭包就为 Fn。</li></ul><p>又或者以下例子，闭包捕获不可变引用的使用操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">compare_len_with_s</span> = |<span class="type">str</span>: &amp;<span class="type">str</span>| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="type">str</span>.<span class="title function_ invoke__">len</span>() == s.<span class="title function_ invoke__">len</span>());</span><br><span class="line"><span class="title function_ invoke__">compare_len_with_s</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>为什么是不可变引用的使用操作？从 len 函数的第一个参数 Self 中可以看到 <code>&amp;self</code> 是一个不可变引用。</p><p>也就是理解闭包使用被捕获变量的操作：看变量怎么用（函数的<code>Self</code>是什么），Self 是什么类型，它所代表的使用操作被闭包捕获，闭包就是什么类型。<br>比如 <code>s.len()</code> len 函数的 <code>&amp;self</code> 意味着闭包捕获的是一个不可变引用的使用操作，闭包就是 Fn，对应的闭包变量可以不 mut。<br>又比如 <code>s.push_str()</code> 的 <code>&amp;mut self</code> 意味着闭包捕获的是一个可变引用的使用操作，闭包就是 FnMut，对应的闭包变量需要 mut。</p><p><a href="https://zhuanlan.zhihu.com/p/288626364">https://zhuanlan.zhihu.com/p/288626364</a> 这张图属于从闭包范围的角度来解释闭包的关系。<br>fn&gt;Fn&gt;FnMut&gt;FnOnce，fn extends Fn extends FnMut extends FnOnece，如能实现 FnMut 的一定能实现 Fn。</p><p>既然 fn extends Fn extends FnMut extends FnOnce，那么从继承和多态的角度上解释闭包的关系：<a href="https://zhuanlan.zhihu.com/p/341815515%E3%80%82">https://zhuanlan.zhihu.com/p/341815515。</a><br>FnOnce 被 FnMut 继承，那么 FnMut 类型就可以赋值给 FnOnce 类型（多态），同样，Fn 能够赋值给 FnMut、FnOnce 类型。</p><blockquote><p>为什么需要设计成 Fn extends FnMut extends FnOnce 呢？</p><p>来自 GPT 的回答：这种继承关系的设计允许 Rust 在编译时进行更精确的借用检查，确保内存安全。它反映了一个从“可能完全消耗捕获的变量（FnOnce）”到“可能改变捕获的变量（FnMut）”再到“不改变捕获的变量（Fn）”的权限层次。这样的设计使得 Rust 的闭包既灵活又安全，能够根据不同的需求选择合适的闭包类型。</p></blockquote><h3 id="move-和-Fn"><a href="#move-和-Fn" class="headerlink" title="move 和 Fn"></a>move 和 Fn</h3><p>move 常与 FnOnce 搭配使用，但实际上使用了 move 的闭包依然可能实现了 Fn 或 FnMut 特征。</p><p>因为，一个闭包实现了哪种 Fn 特征取决于该闭包如何<strong>使用</strong>被捕获的变量，而不是取决于闭包如何捕获它们。move 本身强调的就是后者，闭包如何捕获变量：</p><p>符合直觉的 move 和 FnOnce 示例，move 强制转移变量的所有权，FnOnce 需要消耗变量的所有权：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">exec</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt;(f: F)  &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">update_string</span> =  <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"><span class="title function_ invoke__">exec</span>(update_string);</span><br></pre></td></tr></table></figure><p>但是如果保留 move，将 FnOnce 改成 Fn，编译也是可以正常的：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- fn exec&lt;F: FnOnce()&gt;(f: F)  &#123;&#125;</span></span><br><span class="line"><span class="addition">+ fn exec&lt;F: Fn()&gt;(f: F)  &#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">exec</span>&lt;F: <span class="title function_ invoke__">Fn</span>()&gt;(f: F)  &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">update_string</span> =  <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"><span class="title function_ invoke__">exec</span>(update_string);</span><br></pre></td></tr></table></figure><p>为什么可以正常运行？明确 move 是闭包捕获变量的方式，不是闭包使用变量的方式。</p><p>闭包的类型取决于闭包如何使用变量（闭包使用变量的方式），即变量操作时函数的 <code>Self</code> 的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>); <span class="comment">// Fn</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>); <span class="comment">// Fn</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>()); <span class="comment">// Fn</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>()); <span class="comment">// Fn，因为 `len(&amp;self)` 只需要不可变引用，所以属于Fn</span></span><br></pre></td></tr></table></figure><p>闭包捕获变量的方式是什么意思呢，看以下代码，闭包的三种捕获方式，捕获变量，捕获可变引用，捕获不可变引用。<br>虽然捕获方式不同，但是由于使用方式 <code>len(&amp;self)</code> 中 <code>&amp;self</code>，所以三者都是 Fn 闭包类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>()); <span class="comment">// Fn</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, (&amp;s).<span class="title function_ invoke__">len</span>()); <span class="comment">// Fn</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>()); <span class="comment">// Fn</span></span><br></pre></td></tr></table></figure><p>上面的示例再一次验证：一个闭包实现了哪种 Fn 特征取决于该闭包如何<strong>使用</strong>被捕获的变量，而不是取决于闭包如何捕获它们。</p><blockquote><p>注意，<code>(&amp;mut s).len()</code> 使用方式是先创建可变引用，也就是 FnMut 和 Fn 都存在，所以闭包类型是 FnMut。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">closure</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, (&amp;<span class="keyword">mut</span> s).<span class="title function_ invoke__">len</span>()); <span class="comment">// FnMut</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="三种-Fn-的关系"><a href="#三种-Fn-的关系" class="headerlink" title="三种 Fn 的关系"></a>三种 Fn 的关系</h3><p>实际上，一个闭包并不仅仅实现某一种 Fn 特征，Fn extends FnMut extends FnOnce：</p><ul><li><strong>所有的闭包都自动实现了 FnOnce 特征，因此任何一个闭包都至少可以被调用一次</strong></li><li><strong>没有移除所捕获变量的所有权的闭包自动实现了 FnMut 特征</strong></li><li><strong>不需要对捕获变量进行改变的闭包自动实现了 Fn 特征</strong></li></ul><p>上述的规则是对闭包所有权状态的描述，在使用闭包时可快速判断，但其根本在 <code>闭包是所有权状态的描述</code> 章节的分析中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fn_once_type</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt;(f: F) &#123;</span><br><span class="line">     <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fn_mut_type</span>&lt;F: <span class="title function_ invoke__">FnMut</span>()&gt;(<span class="keyword">mut</span> f: F) &#123; <span class="comment">// 接收并使用可变实参参数，需要使用可变形参（这样才能保证语法分析器分析可变实参带来的印象，需要使用的状态下才需要表示mut，如果不使用可变参数可以不标识mut）</span></span><br><span class="line">     <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fn_type</span>&lt;F: <span class="title function_ invoke__">Fn</span>()&gt;(f: F) &#123;</span><br><span class="line">     <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"><span class="title function_ invoke__">fn_once_type</span>(closure);</span><br><span class="line"><span class="title function_ invoke__">fn_mut_type</span>(closure);</span><br><span class="line"><span class="title function_ invoke__">fn_type</span>(closure);</span><br></pre></td></tr></table></figure><p>对第二条规则的用例分析：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">exec</span>&lt;<span class="symbol">&#x27;a</span>, F: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>&gt;(<span class="keyword">mut</span> f: F) &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">update_string</span> = |<span class="type">str</span>| <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>); s &#125;; error 在<span class="built_in">FnMut</span>和<span class="built_in">FnOnce</span>都显式存在的情况下取交集为<span class="built_in">FnOnce</span>，而<span class="built_in">FnOnce</span>闭包不能使用两次变量，因为第一次使用时消耗了变量所有权！</span><br><span class="line"><span class="title function_ invoke__">exec</span>(update_string);</span><br></pre></td></tr></table></figure><p>上面的例子再一次更新对闭包的认识：<strong>一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们。</strong></p><p>这其中的使用方式是指一个闭包中，闭包类型是什么，那么使用变量时他的规则就是什么，比如上面的例子中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">update_string</span> = |<span class="type">str</span>| <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>); s &#125;;</span><br></pre></td></tr></table></figure><p>这个闭包编译就会错误，因为在 FnMut 和 FnOnce 都显式存在的情况下取交集为 FnOnce，而 FnOnce 闭包不能使用两次变量，因为第一次使用时消耗了变量所有权！<br>它什么时候使用了两次变量呢？<code>s.push_str</code> 和 <code>s</code>这两次。虽然 <code>s.push_str</code> 是 <code>&amp;mut self</code>，对应 FnMut 类型，<br>但在 <code>FnMut&amp;FnOnce = FnOnce</code> 中闭包的最终的类型是 <code>FnOnce</code>，这就意味着闭包使用变量一次就会消耗变量的所有权。因为<strong>一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们。</strong></p><p>所以更新闭包捕获变量的方式和闭包使用变量的方式这两种理解：<br>闭包<strong>捕获变量的方式</strong>是指闭包每一次<strong>捕获</strong>变量时，对应的函数如 <code>fn push_str(&amp;mut self)</code> 或 <code>fn len(&amp;self)</code> 中 <code>Self</code> 的类型；<br>闭包<strong>使用变量的方式</strong>是指整个闭包中单个或多个捕获方式综合下来的交集类型，闭包每一次使用变量都会按照这个交集类型对应的规则处理。如 <code>FnOnce</code> 使用会消耗变量所有权。</p><p>这两条规则结合上述的三条规则，可以快速确定闭包的类型，在实际项目中，建议先使用 Fn 特征，然后编译器会告诉你正误以及该如何选择。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>闭包（closure）是函数指针（function pointer）和上下文（context）的组合。<br>没有上下文的闭包就是一个函数指针。<br>带有不可变上下文（immutable context）的闭包属于 Fn<br>带有可变上下文（mutable context）的闭包属于 FnMut<br>拥有其上下文的闭包属于 FnOnce</p><p>闭包<strong>捕获变量的方式</strong>是指闭包每一次<strong>捕获</strong>变量时，对应的函数如 <code>fn push_str(&amp;mut self)</code> 或 <code>fn len(&amp;self)</code> 中 <code>Self</code> 的类型；<br>闭包<strong>使用变量的方式</strong>是指整个闭包中单个或多个捕获方式综合下来的交集类型，闭包每一次使用变量都会按照这个交集类型对应的规则处理。如 <code>FnOnce</code> 使用会消耗变量所有权。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fn_once</span>&lt;F&gt;(func: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>(<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> + <span class="built_in">Copy</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>(<span class="number">3</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">fn_once</span>(|z| z == x.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="comment">// let update_string = |str| s.push_str(str); 闭包捕获可变借用，需要闭包变量也设置为可变</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">update_string</span> = |<span class="type">str</span>| s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>);</span><br><span class="line">    <span class="title function_ invoke__">update_string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 闭包类型只与闭包怎么捕获变量的操作有关系，与变量自己的类型没有直接关系。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">update_string</span> = |<span class="type">str</span>| s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>); <span class="comment">// FnMut</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">update_string</span> = |<span class="type">str</span>| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>()); <span class="comment">// Fn</span></span><br><span class="line">    <span class="title function_ invoke__">update_string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">compare_len_with_s</span> = |<span class="type">str</span>: &amp;<span class="type">str</span>| <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="type">str</span>.<span class="title function_ invoke__">len</span>() == s.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="title function_ invoke__">compare_len_with_s</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">closure</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, &amp;<span class="keyword">mut</span> s);</span><br><span class="line">        s</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">closure</span> = <span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, &amp;<span class="keyword">mut</span> s);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ss</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">closure</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, (&amp;s).<span class="title function_ invoke__">len</span>());</span><br><span class="line">        <span class="comment">// println!(&quot;&#123;&#125;&quot;, (&amp;mut s).len());</span></span><br><span class="line">        <span class="comment">// println!(&quot;&#123;&#125;&quot;, &amp;mut 11);</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ss.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fn_once_type</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt;(f: F) &#123;</span><br><span class="line">        <span class="title function_ invoke__">f</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fn_mut_type</span>&lt;F: <span class="title function_ invoke__">FnMut</span>()&gt;(<span class="keyword">mut</span> f: F) &#123;</span><br><span class="line">        <span class="comment">// 接收并使用可变实参参数，需要使用可变形参（这样才能保证语法分析器分析可变实参带来的印象，需要使用的状态下才需要表示mut，如果不使用可变参数可以不标识mut）</span></span><br><span class="line">        <span class="title function_ invoke__">f</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fn_type</span>&lt;F: <span class="title function_ invoke__">Fn</span>()&gt;(f: F) &#123;</span><br><span class="line">        <span class="title function_ invoke__">f</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    <span class="title function_ invoke__">fn_once_type</span>(closure);</span><br><span class="line">    <span class="title function_ invoke__">fn_mut_type</span>(closure);</span><br><span class="line">    <span class="title function_ invoke__">fn_type</span>(closure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust: 闭包 Closure（一） 认识闭包</title>
      <link href="/2024/03/25/rust-%E9%97%AD%E5%8C%85-Closure%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A4%E8%AF%86%E9%97%AD%E5%8C%85/"/>
      <url>/2024/03/25/rust-%E9%97%AD%E5%8C%85-Closure%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A4%E8%AF%86%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包-Closure（一）-认识闭包"><a href="#闭包-Closure（一）-认识闭包" class="headerlink" title="闭包 Closure（一） 认识闭包"></a>闭包 Closure（一） 认识闭包</h2><p>闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值。</p><p>Rust 闭包在形式上借鉴了 Smalltalk 和 Ruby 语言，与函数最大的不同就是它的参数是通过 |parm1| 的形式进行声明，如果是多个参数就 |param1, param2,…|，闭包的形式定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|param1, param2,...| &#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    返回表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果闭包只有一个返回表达式，可以简化定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|param1| 返回表达式</span><br></pre></td></tr></table></figure><p>特别注意：闭包中最后一行表达式返回的值，就是闭包执行后的返回值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">sum</span> = |y| x + y;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">sum</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中闭包 sum，它拥有一个入参 y，同时捕获了作用域中的 x 的值，因此调用 sum(2) 意味着将 2（参数 y）跟 1（x）进行相加，最终返回它们的和：3。</p><p>可以看到 sum 非常符合闭包的定义：可以赋值给变量，允许捕获调用者作用域中的值。</p><h3 id="闭包类型推导"><a href="#闭包类型推导" class="headerlink" title="闭包类型推导"></a>闭包类型推导</h3><p>Rust 是静态语言，因此所有的变量都具有类型，但是得益于编译器的强大类型推导能力，在很多时候我们并不需要显式地去声明类型。</p><p>但显然函数并不在此列，因为函数往往会作为 API 提供给你的用户，你的用户必须在使用时知道传入参数的类型和返回值类型，<strong>因此必须手动为函数的所有参数和返回值指定类型</strong>。</p><p>与函数相反，闭包并不会作为 API 对外提供，因此它可以享受编译器的类型推导能力，<strong>无需标注参数和返回值的类型</strong>。</p><p>为了增加代码可读性，有时候我们会显式地给类型进行标注，出于同样的目的，也可以给闭包标注类型，在下面 sum 函数中，定义两个参数 <code>x y</code> 和返回值为 i32 类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = |x: <span class="type">i32</span>, y: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之相比，不标注类型的闭包声明会更简洁些：let sum &#x3D; |x, y| x + y，需要注意的是，针对 sum 闭包，如果你只进行了声明，但是没有使用，编译器会提示你为 x, y 添加类型标注，因为它缺乏必要的上下文：</p><p>这是因为虽然类型推导很好用，但是它不是泛型，当编译器推导出一种类型后，它就会一直使用该类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>首先，在 s 中，编译器为 x 推导出类型 String，但是紧接着 n 试图用 5 这个整型去调用闭包，跟编译器之前推导的 String 类型不符，因此报错。</p><h3 id="结构体中的闭包"><a href="#结构体中的闭包" class="headerlink" title="结构体中的闭包"></a>结构体中的闭包</h3><p>假设我们要实现一个简易缓存，功能是获取一个值，然后将其缓存起来，那么可以这样设计：</p><ul><li>一个闭包用于获取值</li><li>一个变量，用于存储该值</li></ul><p>可以使用结构体来代表缓存对象，最终设计如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    query: T,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T 是一个泛型，<code>Fn(u32) -&gt; u32</code> 这一长串是 T 的特征约束，即 Fn(u32) -&gt; u32 是一个特征，用来表示 T 是一个<strong>闭包类型</strong>。<br>特征 <code>Fn(u32) -&gt; u32</code> 从表面来看，就对闭包形式进行了显而易见的限制：该闭包拥有一个 u32 类型的参数，同时返回一个 u32 类型的值。<br>需要注意的是，其实 Fn 特征不仅仅适用于闭包，还适用于函数，因此上面的 query 字段除了使用闭包作为值外，还能使用一个具名的函数来作为它的值。</p><blockquote><p>熟悉 JavaScript 的同学知道，在 JavaScript 中闭包的声明和函数是一样的，闭包只是比函数访问了外部的变量。</p></blockquote><p>接着为结构体实现方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(query: T) <span class="punctuation">-&gt;</span> Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123; query, value: <span class="literal">None</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.query)(arg);</span><br><span class="line">                <span class="comment">// 闭包是实现了 Fn trait 的类型，而不是直接的函数指针。因此不能直接使用self.query形式，需要用(self.query)标识</span></span><br><span class="line">                <span class="comment">// let v = self.query(arg);</span></span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以修改 u32 类型为泛型，让结构体通用，<code>E: Copy</code></p></blockquote><p>调用 Cacher，验证缓存：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">call_with_different_values</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = Cacher::<span class="title function_ invoke__">new</span>(|a| a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = c.<span class="title function_ invoke__">value</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = c.<span class="title function_ invoke__">value</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">call_with_different_values</span>();</span><br></pre></td></tr></table></figure><h3 id="捕获作用域中的值"><a href="#捕获作用域中的值" class="headerlink" title="捕获作用域中的值"></a>捕获作用域中的值</h3><p>前面提到过，闭包相比较函数多出来的一个功能就是能够访问作用域中的值：</p><p>x 并不是闭包 equal_to_x 的参数，但是它依然可以去使用 x，因为 equal_to_x 在 x 的作用域范围内。<br>而对于函数来说，就算你把函数定义在 main 函数体中，它也不能访问 x。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn equal_to_x(z: i32) -&gt; bool &#123;</span></span><br><span class="line"><span class="comment">//    z == x</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// assert!(equal_to_x(y));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函数的表示很简单，它是一段编译之后就不会变化的代码段，我们可以用一个简单的地址就能代表它。<br>而闭包则不一样，存放了什么数据、存放的数据类型是什么、数据存放在哪里、存放的数据是否可以修改、其生命周期如何，这些都是需要考虑的事情。<br>所以在区分闭包和函数这点上，动态语言 JavaScript 可以做到统一函数和闭包，因为只有在执行时才确定数据。<br><a href="https://www.zhihu.com/question/628166233">https://www.zhihu.com/question/628166233</a></p></blockquote><h3 id="闭包对内存的影响"><a href="#闭包对内存的影响" class="headerlink" title="闭包对内存的影响"></a>闭包对内存的影响</h3><p>当闭包从环境中捕获一个值时，会分配内存去存储这些值。对于有些场景来说，这种额外的内存分配会成为一种负担。<br>与之相比，函数就不会去捕获这些环境值，因此定义和使用函数不会拥有这种内存负担。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure</span> = |x| x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">closure</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;, closure(String::from(&quot;x&quot;))); 如果再次使用closure则会报错，因为closure的类型已经被确定了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加缓存结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;T, E&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: <span class="title function_ invoke__">Fn</span>(E) <span class="punctuation">-&gt;</span> E,</span><br><span class="line">        E: <span class="built_in">Copy</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        query: T,</span><br><span class="line">        value: <span class="type">Option</span>&lt;E&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;T, E&gt; Cacher&lt;T, E&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: <span class="title function_ invoke__">Fn</span>(E) <span class="punctuation">-&gt;</span> E,</span><br><span class="line">        E: <span class="built_in">Copy</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>(query: T) <span class="punctuation">-&gt;</span> Cacher&lt;T, E&gt; &#123;</span><br><span class="line">            Cacher &#123; query, value: <span class="literal">None</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: E) <span class="punctuation">-&gt;</span> E &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">                <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.query)(arg);</span><br><span class="line">                    <span class="comment">// 闭包是实现了 Fn trait 的类型，而不是直接的函数指针。因此不能直接使用self.query形式，需要用(self.query)标识</span></span><br><span class="line">                    <span class="comment">// let v = self.query(arg);</span></span><br><span class="line">                    <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                    v</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_with_different_values</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = Cacher::<span class="title function_ invoke__">new</span>(|a| a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1</span> = c.<span class="title function_ invoke__">value</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v2</span> = c.<span class="title function_ invoke__">value</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(v2, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">call_with_different_values</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure_to</span> = |z| z == x; <span class="comment">// 访问作用域中的变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">closure_to</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript：原始数据类型toString问题</title>
      <link href="/2024/03/24/JavaScript%EF%BC%9A%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BtoString%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/24/JavaScript%EF%BC%9A%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BtoString%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>今天遇到一个有趣的事情，当以 <code>1.toString</code> 的方式调用 <code>toString</code> 方法时，会遇到一个语法错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure><p>这是因为 JavaScript 解析器会将数字后面的点视为小数点的一部分，而不是属性访问符。因此，它尝试将 <code>1.</code> 解析为一个浮点数，接着遇到了 <code>toString</code>，这并不符合语法规则，从而导致错误。</p><p>为了正确地调用数字字面量的方法，可以使用以下几种方式：</p><ol><li><p>使用两个点 <code>..</code>，第一个点被视为小数点，第二个点被解析为属性访问符。这样，解析器能够正确地识别出你是想访问数字的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>.<span class="title function_">toString</span>(); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>将数字放在括号中，这样JavaScript解析器会将其视为一个表达式，从而可以直接访问其方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).<span class="title function_">toString</span>(); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>使用数字对象的构造函数 <code>Number</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="number">1</span>).<span class="title function_">toString</span>(); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>[]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>[<span class="string">&#x27;toString&#x27;</span>]() <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li></ol><p>以上方法都可以避免初始的语法错误，能够正确地调用数字的 <code>toString</code> 方法。</p><h3 id="装箱（Boxing）"><a href="#装箱（Boxing）" class="headerlink" title="装箱（Boxing）"></a>装箱（Boxing）</h3><p>为什么看似原始数据类型，也能够调用方法呢？</p><p>在 JavaScript 中，原始数据类型（如数字、字符串、布尔值）虽然不是对象，但它们在访问方法或属性时会被临时包装成相应的<strong>对象类型</strong>，这个过程称为装箱（Boxing）。这就是为什么可以在原始数据类型上调用 <code>.toString</code> 方法或其他方法的原因。</p><p>当执行 <code>1[&#39;toString&#39;]</code> 时，JavaScript 引擎会临时将数字 <code>1</code> 转换为 <code>Number</code> 对象，然后在这个临时创建的 <code>Number</code> 对象上调用 <code>toString</code> 方法。完成调用后，这个临时对象就会被丢弃。这个过程是自动发生的，对开发者来说是透明的。</p><p>这种行为不仅适用于数字，还适用于其他原始数据类型。例如，字符串会被临时转换为 <code>String</code> 对象，布尔值会被转换为 <code>Boolean</code> 对象，从而允许在这些原始数据类型上访问方法和属性。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成长：要把自己的努力摆到台面上，让领导看见</title>
      <link href="/2024/03/13/%E6%88%90%E9%95%BF%EF%BC%9A%E8%A6%81%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%AA%E5%8A%9B%E6%91%86%E5%88%B0%E5%8F%B0%E9%9D%A2%E4%B8%8A%EF%BC%8C%E8%AE%A9%E9%A2%86%E5%AF%BC%E7%9C%8B%E8%A7%81/"/>
      <url>/2024/03/13/%E6%88%90%E9%95%BF%EF%BC%9A%E8%A6%81%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%AA%E5%8A%9B%E6%91%86%E5%88%B0%E5%8F%B0%E9%9D%A2%E4%B8%8A%EF%BC%8C%E8%AE%A9%E9%A2%86%E5%AF%BC%E7%9C%8B%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>要把自己的努力摆到台面上，让领导看见</p></blockquote><h3 id="状态理解"><a href="#状态理解" class="headerlink" title="状态理解"></a>状态理解</h3><p>在工作中，很多的烦恼都是来自自己的工作没有被领导或其他同事看见，或者说没有被他们认同。</p><p>很多时候，老板就是通过认可或者不认可我们的某部分想法，让我们保持在争相给老板表现努力的状态，如没事就加班，重复造轮子，高管互斗等。</p><p>常见的场景：</p><ul><li>这我感觉没啥难的呀，这也难？这不挺简单的吗？</li><li>大部分 <code>ToB</code> 的前端像个流水线一样，完全能在不理解业务的情况下开发需求，因为前端工作是直接面向用户的，只需要关注怎么呈现给用户就可以。在这个业务场景中前端是被当作资源池的，他们提出的建议不会被考虑，因而也不会考虑怎么去深入理解业务，做出更好的产品细节。</li><li>测试专挑小细节，一些需求文档以外的细节也被测试当作bug提出，测试想通过这一部分体现自己工作努力。</li></ul><p>这几天回顾自己经历的事情：</p><p>测试提出的 “bug+需要修改的不合理的现象（需求）”，希望以此证明自己的工作量，但这部分需求对于研发是隐形的工作。所以测试在提出未经过需求文档确定的需求时，研发不愿意修改。</p><p>因为这些没有经过领导的评审，是隐形的工作量。在有限的开发时间内，可能会被领导指责为什么开发速度这么慢，为什么一个需求就会有这么多的bug。</p><p>要把自己的努力摆到台面上，我们都希望自己的工作能被看见和理解。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程：思考编码的方式</title>
      <link href="/2024/03/13/%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%80%9D%E8%80%83%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/03/13/%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%80%9D%E8%80%83%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端：利用生成器和迭代器实现分离逻辑</title>
      <link href="/2024/03/05/%E5%89%8D%E7%AB%AF%EF%BC%9A%E5%88%A9%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB%E9%80%BB%E8%BE%91/"/>
      <url>/2024/03/05/%E5%89%8D%E7%AB%AF%EF%BC%9A%E5%88%A9%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<hr><p>工作半年了常没时间、没动力学习新东西，每天就在忙着写业务逻辑，非常的枯燥。即使考虑到可以用新东西来实现某个需求，但为了保证业务的快速迭代，只能选择更稳妥的方式。</p><h3 id="生成器和迭代器"><a href="#生成器和迭代器" class="headerlink" title="生成器和迭代器"></a>生成器和迭代器</h3><p>今天完善一个需求，统一检索中，检索的各个实体tab依次弹出，实现类似RXJS弹珠图的效果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TabIterabor</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">        <span class="keyword">private</span> models: <span class="built_in">string</span>[],</span></span><br><span class="line"><span class="params">        <span class="keyword">private</span> query: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">        <span class="keyword">private</span> index = <span class="number">0</span></span></span><br><span class="line"><span class="params">    </span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// asyncIterator 标识是一个异步迭代器，next函数返回一个Promise对象</span></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">async</span> ()=&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">null</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以使用生成器来构造自定义迭代器</span></span><br><span class="line">    <span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Iterator/Iterator</span></span><br><span class="line">    <span class="comment">// *[Symbol.iterator]() &#123;</span></span><br><span class="line">    <span class="comment">//   for (let value = this.#start; value &lt;= this.#end; value += this.#step) &#123;</span></span><br><span class="line">    <span class="comment">//     yield value;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="权限和菜单交互的设计"><a href="#权限和菜单交互的设计" class="headerlink" title="权限和菜单交互的设计"></a>权限和菜单交互的设计</h3><ul><li><p>隐藏菜单</p><ul><li>控制子菜单提升效果</li><li>空权限时不允许登录</li></ul></li><li><p>不隐藏菜单，将指定的路由页面设置成404或者403页面</p></li></ul><h3 id="退出登录时应该要清空store和router的信息"><a href="#退出登录时应该要清空store和router的信息" class="headerlink" title="退出登录时应该要清空store和router的信息"></a>退出登录时应该要清空store和router的信息</h3><p>封装hooks，增强router功能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Router</span>, <span class="title class_">RouteRecordRaw</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useExtRouter</span> = (<span class="params">router: Router</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@function</span> 退出登陆后，需要清空路由</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Router</span>&#125; <span class="variable">router</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; excludes name | path</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment">   * 在登录情况下，用户一定存在404路由用来显示不存在的或被过滤的路由页面，同时由于404路由应该放在异步路由后面</span></span><br><span class="line"><span class="comment">   * 所以在重置router时，需要清除404路由以避免后续添加异步路由时添加到404路由后面</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">resetRouter</span> = (<span class="params">excludes: <span class="built_in">string</span>[]</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> routes = router.<span class="title function_">getRoutes</span>();</span><br><span class="line">    routes.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!excludes.<span class="title function_">find</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x === item.<span class="property">path</span> || x === item.<span class="property">name</span>)) &#123;</span><br><span class="line">        router.<span class="title function_">removeRoute</span>(item.<span class="property">name</span> <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除嵌套路由</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">route</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">deepDelete</span> = (<span class="params">route: RouteRecordRaw</span>) =&gt; &#123;</span><br><span class="line">    route.<span class="property">children</span>?.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="title function_">deepDelete</span>(item));</span><br><span class="line">    router.<span class="title function_">removeRoute</span>(route.<span class="property">name</span> <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加嵌套路由</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">routes</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addRoutes</span> = (<span class="params">routes: RouteRecordRaw[]</span>) =&gt; &#123;</span><br><span class="line">    routes.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">deepDelete</span>(item); <span class="comment">// 避免重复添加路由</span></span><br><span class="line">      router.<span class="title function_">addRoute</span>(item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    resetRouter,</span><br><span class="line">    deepDelete,</span><br><span class="line">    addRoutes,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useExtRouter;</span><br></pre></td></tr></table></figure><h3 id="路由别名"><a href="#路由别名" class="headerlink" title="路由别名"></a>路由别名</h3><p>在权限菜单的控制中，会存在前后登录的用户权限不一样导致可见的菜单不一样的问题。怎么动态的控制用户跳转的主页呢？</p><p>因为在404页面和登录成功后跳转都是 <code>/</code>，那就想到让 <code>/</code>跳转到 <code>/home</code>，在清洗权限路由（菜单）时，给找到的第一个有权限的路由标识路由别名，至此所有跳转到主页面 <code>/</code> 的都会跳转到 <code>/home</code>，而 <code>/home</code> 属于动态设置的路由别名，就可以动态的控制主页面了。</p><h3 id="统一检索多个状态"><a href="#统一检索多个状态" class="headerlink" title="统一检索多个状态"></a>统一检索多个状态</h3><p>tabs加载中，不允许输入新的query，也不允许发起新的query</p><p>tabs加载完成，第一个count非0的tab内容列表加载中，此时请求新query，加载新的tabs，此时上一次tabs中第一个count非0的tab请求完成，而当前tabs的第一个非0tab还没有发出请求（requestCount没有变化），所以会导致列表内容变化，展示不合理。</p><p>这个现象的主要问题在新tabs的第一个count非0的tab还没有发出请求，导致requestCount没有变化，所以达不到丢弃旧数据的效果。</p><p>解决方案：</p><p>不能简单的判断extTabLoading处于loading就丢弃数据，因为存在第一个Tab发出的请求快于extTabs的请求。</p><p>通过判断extTabs的请求次数来决定是否赋值。</p><p>因为此时count非0的tab已经发出请求，此时再发新extTabs的请求，然后再发count非0的tab请求，count非0的tab请求可能快于extTabs，所以不能简单将extLoading时的列表内容丢弃，可能丢弃的就是需要请求的内容。并且在新的tab发出请求后，旧tab发出的请求一定会被丢弃（requestCount）。</p><p>最终明确需要解决的问题时不同的extTabs请求，决定是否赋值数据。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端：window.history修改URL后，跳转再回退不是最后一次的URL</title>
      <link href="/2023/11/18/%E5%89%8D%E7%AB%AF%EF%BC%9Awindow-history%E4%BF%AE%E6%94%B9URL%E5%90%8E%EF%BC%8C%E8%B7%B3%E8%BD%AC%E5%86%8D%E5%9B%9E%E9%80%80%E4%B8%8D%E6%98%AF%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E7%9A%84URL/"/>
      <url>/2023/11/18/%E5%89%8D%E7%AB%AF%EF%BC%9Awindow-history%E4%BF%AE%E6%94%B9URL%E5%90%8E%EF%BC%8C%E8%B7%B3%E8%BD%AC%E5%86%8D%E5%9B%9E%E9%80%80%E4%B8%8D%E6%98%AF%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E7%9A%84URL/</url>
      
        <content type="html"><![CDATA[<p>vue2 (<code>vue-router3</code>) 没有去 debug 源码，但是在公司的另外一个项目通过 history (window.history.replaceState) 去修改URL，vue-router3 是实时更新内部的 <code>currentRoute</code>，所以在修改参数后，去跳转再回退，是最后一次的URL。</p><p>今天 debug <code>vue-router4</code> 发现，它的逻辑是记录当前页面最后一次通过 <code>popstate</code> 事件变化的 URL，也就是只处理 <code>popstate</code> 事件发生时的状态，通过 window.history 的 pushState 和 replaceState 去修改 URL 不会触发 popstate 事件，所以 vue-router4 没有感知是这个原因。</p><p>目前来看解决办法：</p><ol><li>给当前的路由加上 state，在通过 window.history.replaceState 修改参数后，给当前的路由对象加上 state，返回再把 state 取出来然后回显状态。</li><li>不通过 window.history.replaceState 无刷新修改参数，而是通过 vue-router 修改参数，达到更新路由的目的。</li><li>既然 vue-router4 通过 popstate 事件处理逻辑，那手动触发 <code>popstate</code> 事件就可以了，在通过 window.history 修改参数后，手动 <code>dispatch popstate</code> 事件 <code>window.dispatchEvent(new PopStateEvent(&quot;popstate&quot;))</code> 达到触发 router 的目的，这个和第二种类似。目前副作用未知，我用的这种方式。</li><li>手动 hack vue router，让它实时更新，这个我没做尝试。</li></ol><p>参考：</p><ol><li><p><a href="https://github.com/vuejs/router/issues/366">https://github.com/vuejs/router/issues/366</a></p></li><li><p><a href="https://github.com/vuejs/router/issues/2035">https://github.com/vuejs/router/issues/2035</a></p></li><li><p><a href="https://github.com/vuejs/router/issues/1270">https://github.com/vuejs/router/issues/1270</a></p></li><li><p><a href="https://github.com/single-spa/single-spa/pull/291">https://github.com/single-spa/single-spa/pull/291</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> vue-router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-router </tag>
            
            <tag> history </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理财：《指数基金投资指南》- 第三章笔记</title>
      <link href="/2023/10/13/%E7%90%86%E8%B4%A2%EF%BC%9A%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/13/%E7%90%86%E8%B4%A2%EF%BC%9A%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-指数基金的分类"><a href="#1-指数基金的分类" class="headerlink" title="1. 指数基金的分类"></a>1. 指数基金的分类</h3><p>指数基金最常见的一种分类，就是分为宽基指数和行业指数。这两者是如何区分的呢？</p><p>有的指数基金在挑选股票的时候，并不限制非得是投资哪些行业；但有的指数基金在挑选股票的时候，会要求只投资哪些行业的股票。例如消费行业指数基金，就要求主要投资消费行业的公司，这种指数基金就是行业指数基金。而像沪深300指数基金，它挑选股票的时候，并不限制行业，这种就是宽基指数基金。</p><p>为何要做这样的区分呢？因为行业指数基金受行业特性的影响非常大。例如当油价大幅下跌的时候，石油开采行业的盈利就会大幅下滑，因为开采出来的石油卖不出好价格。但油价下跌对沪深300这种宽基指数的影响就比较小。</p><p>在选取基金时，一般都遵循一些潜规则，例如：上市不满一个季度的股票不选；暂停上市的股票不选；财务上有问题的股票不选；多年亏损的股票不选。这些规则基本国内的指数都会默认遵循，可以一定限度地保护指数基金投资者的利益不受损失。</p><h3 id="2-常见宽基指数基金"><a href="#2-常见宽基指数基金" class="headerlink" title="2. 常见宽基指数基金"></a>2. 常见宽基指数基金</h3><h4 id="1-上证50指数"><a href="#1-上证50指数" class="headerlink" title="1). 上证50指数"></a>1). 上证50指数</h4><p>上证50指数是从上交所挑选沪市规模最大、流动性好、最具代表性的50只股票组成样本股，以综合反映沪市最具影响力的一批优质大盘企业的整体状况。这种大公司也被称为蓝筹股。什么是蓝筹股？蓝筹这个词来自西方赌场。在西方赌场里，一般有三种颜色的筹码，其中蓝色筹码最为值钱。后来就用蓝筹股，代表规模较大、有较大影响力的公司。上证50指数是从2003年12月31日，从1 000点开始起步的，在此之前没有上证50这个指数可供追溯。上证50一个比较明显的特点，是只有上交所的股票，没有深交所的股票，所以没有办法反映国内股市整体的走势。</p><h4 id="2-沪深300指数"><a href="#2-沪深300指数" class="headerlink" title="2). 沪深300指数"></a>2). 沪深300指数</h4><p>沪深300指数（简称沪深300）是由中证指数公司开发的，从上交所和深交所挑选规模最大、流动性最好的300只股票。它的成份股数目比上证50多，也都是以大公司为主。沪深300指数所包括的公司，从市值规模上来说，占到国内股市全部规模的60%以上，比较有代表性，所以沪深300也被认为是国内股市最具代表性的指数。沪深300指数的代码有两个：000300和399300。这是因为沪深300指数同时包括上海和深圳两个交易所的股票，所以沪深300在上交所的代码是000300，在深交所的代码是399300。这两个代码其实都是代表沪深300指数的。</p><h4 id="3-中证500指数"><a href="#3-中证500指数" class="headerlink" title="3). 中证500指数"></a>3). 中证500指数</h4><p>中证500指数简称为中证500，代码是000905和399905。它是从2004年12月31日1 000点开始的。将全部沪深300指数的300家公司排除，然后将最近一年日均总市值排名前300名的企业也排除，这样可以最大限度地避免选入大公司。在剩下的公司中，选择日均总市值排名前500名的企业，这就是中证500指数。中证500指数跟沪深300没有重合，是国内中型公司的代表。</p><h4 id="4-创业板相关指数"><a href="#4-创业板相关指数" class="headerlink" title="4). 创业板相关指数"></a>4). 创业板相关指数</h4><p>什么是创业板呢？我们都知道国内有上交所和深交所，我们平时说的股票，其实说的就是在这两个证券交易所上市交易的股票，它们大多在主板上市交易。在主板上市交易，门槛是很高的，公司需要达到一定规模，而且也要有足够的盈利才可以。但是有一些小公司，目前盈利还不好，达不到主板上市的条件。国家就给这类公司提供了一个门槛更低的市场：创业板市场。创业板市场是放在深交所下面的。什么是主板和创业板？主板市场也被称为一板，对发行人的营业期限、股本大小、盈利水平、最低市值等方面的要求标准较高，上市企业多为大型成熟企业，具有较大的资本规模以及稳定的盈利能力。想要在国内的主板上市，上市公司必须达到最近3个会计年度净利润为正并且累积超过人民币3000万元，最近3个会计年度经营活动产生的现金流量净额累计超过人民币5000万元，或者最近3个会计年度营业收入累计超过人民币3亿元。这些条件对于很多小公司来说还是非常高的门槛。如果达不到主板的上市条件，可以退而求其次，选择在二板上市。国内的二板市场就是创业板了。</p><p>创业板在国内的历史还比较短，是2009年10月30日正式上市，目的是为中小型企业&#x2F;创业型企业&#x2F;高科技产业公司提供一个上市融资渠道。从世界范围来看，二板的上市公司，其长期的经营风险还是要高于主板的上市公司的。在投资的时候，需要注意这一点。创业板指数，就是为了衡量创业板的整体股价表现情况而设立的。</p><p>创业板相关的指数有两个，一个是创业板综指，另一个是创业板指数。这两个指数的名字非常相似，所以很多投资者都将其混淆了。创业板综指是为了衡量创业板所有上市公司的股价平均表现而设立的，代码是399102。它包括创业板全部的500多家企业。而创业板指数是为了衡量创业板最主要的100家企业的平均表现而设立的，代码是399006。创业板指数限制了成份股的数量，只从创业板上市公司中，挑选出规模最大、流动性最好的100只股票。</p><p>最近几年，还出现了创业板50指数，是从创业板指数的100家企业中，再挑选出流动性最好的50家，相当于创业板的“上证50”。创业板50指数的代码是399673。这三个指数中，被开发成指数基金产品的，主要是创业板指数和创业板50指数。因为创业板的上市公司，本身大多规模就较小，特别是规模排在后面的创业板公司，因为规模小、成交量低，指数基金投资这类企业很可能买不到需要的股份数量，在流动性上可能会存在问题。所以目前国内的创业板指数基金，大多是以创业板指数和创业板50指数为基准设立的，剩下的并不纳入。</p><p>创业板指数相比之前介绍的指数，更容易暴涨暴跌，投资时要有心理准备。</p><h4 id="5-红利指数"><a href="#5-红利指数" class="headerlink" title="5). 红利指数"></a>5). 红利指数</h4><p>上证50、沪深300、中证500、创业板，它们虽然各自有特点，挑选股票的范围也不同，但是有一个共同点，就是它们都是按照市值来加权的，即股票规模越大，权重越高。这也是指数基金的主流加权方式。但实际上，除了市值加权，市场上还有另一类指数基金，它们是按照一定的策略来加权的，也被称为策略加权指数。</p><p>什么是市值加权、策略加权？</p><p>市值加权比较好理解，就是股票规模越大，权重越高。例如一只指数包含50只股票，总市值2万亿，其中有一只市值1 000亿，另一只800亿。那1 000亿市值的股票，在这个指数中占比就是5%；而800亿的股票，在这个指数中占比就是4%。这个4%、5%就是权重，这就是市值加权。</p><p>而策略加权，则是按照别的方式来决定个股权重。例如红利指数，就是按照股息率来决定权重，哪个股票的股息率越高，这个股票的权重就越大。所以有的股票市值规模虽然小，但股息率高，可能在红利指数中占比反而更高一些。</p><p>红利指数基金就是最近十几年兴起的一类比较特殊的策略加权基金。我们都知道股票是会发放股息的，也就是现金分红：业绩比较好的公司，会每年从净利润中拿出一部分，以现金分红的形式回馈股东。像北京银行，它的大股东是北京市人民政府国有资产监督管理委员会（简称北京市国资委），北京银行是国资委非常重要的公司，国资委轻易不会卖掉北京银行的股票。但国资委也需要资金，所以每年北京银行会拿出净利润的一部分，以现金的形式分红给股东。</p><p>这就是股票的现金分红，也叫股息。有研究表明，能实现高现金分红的股票，长期持有的平均收益率高于现金分红低的股票。这也很好理解，因为能够长期发放高现金分红，至少就能够说明企业的盈利和财务状况良好。<br> 所以我们可以通过持有几十只现金分红最高的股票，来获取更高的收益。这就是红利指数的来源。</p><p>有人会说股票分红，股价也会除权下跌，实际上分红没有意义。这种看法是错误的。股票的分红是公司盈利的一部分。公司一年里赚到的盈利，并不是在某一天突然产生的，而是在一年的时间里逐渐积累起来的。分红作为公司盈利的一部分，也是在这一年里慢慢积累起来的。分红的那一天股价下跌，只是将这部分盈利分到股东手里的一个具体体现。实际上每年都会产生新的盈利、新的分红，源源不断。</p><h5 id="红利机会指数"><a href="#红利机会指数" class="headerlink" title="红利机会指数"></a>红利机会指数</h5><p>红利相关指数很多，这里着重介绍红利机会指数。红利机会指数是标普公司围绕A股开发的红利指数。红利机会指数在传统红利指数的基础上增加了一些筛选条件。</p><p>传统的红利指数，一般只是挑选高股息率的股票，没有其他的要求。但是红利机会指数有3个要求：过去3年盈利增长必须为正；过去12个月的净利润必须为正；每只股票权重不超过3%，单个行业不超过33%。符合这3个要求的成份股才能入选，所有入选的股票再按照股息率排名选出股息率最高的100只股票，构成红利机会指数。</p><p>这样做的好处有两方面。一方面长期分红的根本来源是盈利，挑选盈利增长、净利润为正的股票，可以去掉很多盈利走下坡路的高分红股。这样筛选出来的股票，长期分红能力会更强。另外盈利增速高也会带来更好的收益。</p><p>另一方面则限制了指数行业的占比，这样可以避免某些特殊时间段某些行业占比过高的情况，长期更加稳健。像2007年的时候，当时钢铁行业整体高分红，就占据了红利指数很大比例。限制行业占比，可以避免某些行业仓位过重，降低风险。</p><p>红利机会指数是由国际知名的指数开发商标普公司开发的，代码也跟国内的指数代码不同，是由英文字符组成的，代码为CSPSADRP。</p><p>红利指数有很多种，但它们整体有一些共同的特点。</p><p>特点之一：高股息率，在熊市更有优势。红利指数最明显的一个特点就是高股息率。这也是它名字中“红利”的来源。无论是哪一种红利指数，都是挑选高股息率的股票的。要明白一点，上市公司的现金分红与公司的盈利相关，公司会从每年盈利中拿出一部分，以现金分红的形式分给股东。现金分红并不受股价涨跌的影响。同样是分红100万，熊市分红后100万能买到的股票份额，远比牛市分红后100万能买到的股票份额多得多。也就是说，熊市分红后再投入的效果非常出众。指数的股息率越高，这一点在熊市越是明显。所以红利指数高股息率的特性，在熊市里是非常不错的优势。</p><p>特点之二：能持续发放现金股息的公司，盈利能力和财务健康状况好的概率越高。能长期发放现金股息的公司，盈利能力和财务健康状况一般都不错，毕竟现金股息是切切实实地发放了出去，如果公司财务不好，是没有能力持续发放股息的。财务状况越稳定，企业出意外的情况也就会小，股价的波动也会比较小。红利指数投资一篮子这样的股票，自然也比较稳定，自身的波动也是各个指数中比较低的。</p><p>特点之三：提供分红现金流。指数基金也是有基金分红的，指数基金分红的根本来源是背后公司的现金分红。红利指数基金投资的是高现金分红的企业，自然也能收获很多现金分红，有的红利指数基金就会以基金分红的形式发放给基金持有者。不过指数基金发放基金分红并不是强制的，有的指数基金会把基金分红直接归入到基金净值中，相当于直接替投资者再投入了。</p><h4 id="6-基本面指数"><a href="#6-基本面指数" class="headerlink" title="6). 基本面指数"></a>6). 基本面指数</h4><p>策略加权的指数有很多。除了挑选高股息率股票的红利指数，还有一类影响力也非常大的策略加权指数：基本面指数。</p><p>什么是基本面指数呢？我们经常能听到基本面这个词。基本面覆盖了一个公司的运营的各个方面，比如说营业收入、现金流、净资产、分红等。通过基本面来选股，也就是说，谁的基本面更好，谁占的权重更高。</p><p>目前一般从4个维度去衡量企业基本面的好坏：营业收入，现金流，净资产和分红。而基本面指数也正是从这4个维度去挑选股票的。这种按照占总规模百分比来排名得分的方式，很明显公司规模越大，越占优势。所以基本面50指数挑选出来的，往往也是大盘股。从定位上来说，基本面50指数跟上证50指数很相似。不过因为它综合考虑了收入、盈利、净资产等基本面因素，所以挑选股票时会考虑得更全面一些。</p><h4 id="7-央视财经50指数"><a href="#7-央视财经50指数" class="headerlink" title="7). 央视财经50指数"></a>7). 央视财经50指数</h4><p>前面介绍过按股息率加权的红利指数，按基本面加权的基本面指数，再来介绍一个比较有特色的指数：央视财经50指数（简称央视50）。它是一种专家加权的指数。从名字也可以看出来，这个指数跟央视有很大的关系：它是深证指数和央视的财经频道联合推出的。我们来看看这个指数是如何选股的：</p><p>央视财经50指数是由中央电视台财经频道联合五大高校，包括北京大学、复旦大学、中国人民大学、南开大学，以及中央财经大学，以“成长、创新、回报、公司治理、社会责任”5个维度为考察基础，结合专家评审委员会与50家市场投研机构的投票，并由中国注册会计师协会、大公国际资信评估有限公司从财务与资信评级两个角度进行评定，在A股市场上遴选出50家优质上市公司组成其样本股，再经深圳证券信息有限公司对五个维度进行权重优化，编制成央视财经50指数，共50只样本股，每个维度各10只。</p><p>这种由专家评审委员会选股的指数在美国也有一个非常出名的例子：标普500指数。简单说，央视50指数就是专家们投票选出来的50只股票。其实创立这个指数的原理就是认为专家能够选出更好的股票。它和前面介绍过的指数都不太一样：一般的指数，它们的选股规则是透明的，已经写在纸面上的，但是央视50指数是依靠专家们的选股能力来选股的，其规则并不透明，是一种很特殊的指数。</p><h4 id="8-恒生指数"><a href="#8-恒生指数" class="headerlink" title="8). 恒生指数"></a>8). 恒生指数</h4><p>恒生指数投资的是所有在中国香港上市的公司中规模最大的50家企业，这一点与上证50指数很相似。像我们熟悉的中国移动、腾讯等，都在中国香港上市，它们自身的规模很大，所以也会被入选到恒生指数里。恒生指数代码是英文字符，HSI。</p><p>特点之一：历史悠久，成熟开放。中国香港是一个成熟开放的国际金融中心，在港交所上市要简单一些，内地有些公司就会转战到香港去上市。另外港交所也比内地的证券交易所更加成熟，这个主要体现在有非常丰富的衍生品上。像内地的股指期货期权市场还不完善，甚至还会限制交易。但是香港的衍生品交易市场品种很丰富，可以发展出非常多的投资策略。<br> 特点之二：跟内地紧密相关，但投资者以境外投资者为主。香港股票市场的第二个特点，是上市公司跟内地紧密相关，但是投资者主要以境外投资者为主。内地有很多知名的大公司在香港上市，特别是在香港回归之后，主营业务在内地的公司在港股中的占比越来越高。像大家熟悉的腾讯、招商银行、中国平安等公司都有在香港上市。很明显，因为主营业务在内地，所以这些港股的投资价值跟内地经济紧密相关。但是港股又有一个很奇特的地方，就是它的投资者主要是以境外投资者为主。这是一个历史遗留问题。香港回归之前，港股股票市场，内地投资者占比非常低。像1996年的时候，港股中的内地投资者比例不到1%，甚至连日本和韩国都比不上。港股股票市场特别容易受到境外市场的影响。</p><p>特点之三：“老千股”导致个股投资风险巨大，普通投资者投资港股的最好方式——港股指数基金。</p><p>港股还有一个比较奇葩的现象，就是“老千股”。老千是作弊的意思，老千股就是指钻了很多政策的空子，利用股票市场来为自己谋求利益。</p><h5 id="QDII基金"><a href="#QDII基金" class="headerlink" title="QDII基金"></a>QDII基金</h5><p>投资于中国香港、美国等市场的基金品种，我们把它们称为QDII基金。QDII的意思是合格境内机构投资者。我们可以把这种基金理解成一种“代购”。</p><p>这种基金可以拿人民币，合法地投资中国香港及其他境外市场，像港股、美股、德股等。这些境外市场用的都是非人民币交易，所以可以在一定程度上抵御人民币汇率风险。以美元资产为例，美元现金、美元债券、美元股票、美国房地产等，这些都是属于美元计价资产。如果人民币相对美元贬值，将人民币换为美元资产可以分散这种风险。但反过来，如果人民币相对美元升值，持有美元资产也会受到损失。这是一把双刃剑。<br> 香港用的港币，在汇率上也是追踪美元的，所以港币资产也能在一定程度上抵御汇率风险。</p><p>需要注意一点，内地金融整体来说还不成熟，政策也经常变化。如2016年2月份，就有部分QDII基金暂停申购，但可以赎回。原因是我国限制人民币外流，所以部分基金没有换外汇的额度了，基金无法将人民币换为外币，但是可以换回来。这是投资QDII基金需要额外承担的一种风险。不过从总体上来看，虽然QDII基金有额外的风险，但是对我们普通投资者来说还是很有用的。</p><p>通过这种基金可以很方便地配置非人民币资产，一般也没有太大的额度限制（如果是个人用人民币兑换外币，每年有额度限制，但是申购这些QDII基金，并不占用个人的外汇额度）。QDII基金在内地兴起也就是近几年的事，所以目前QDII指数基金的品种还不多，主要是集中在投资中国香港、美国等股票市场上，但也足够我们普通投资者使用了。</p><h4 id="9-H股指数指数简介"><a href="#9-H股指数指数简介" class="headerlink" title="9). H股指数指数简介"></a>9). H股指数指数简介</h4><p>如果一家公司在内地注册，但是在香港地区上市，这样的公司就是H股了。内地公司到香港上市的有很多，从1993年青岛啤酒到香港上市至今，已经有160多家企业到香港上市。为了衡量这些公司股票的表现，恒生指数公司编制了恒生中国企业指数，也就是通常说的国企指数，简称为H股指数。最初在香港上市的H股不多，所以早期的H股指数只有10只成份股。不过从2000年开始，H股指数进行了一次改版，改为挑选40只成份股，一直沿用至今。不过40只成份股好像也不太够用了，所以2017年上半年的时候，恒生指数公司发起了调研，调查H股指数是否有进一步扩容的需要。截至本书完稿，还没有进一步的消息。</p><p>投资者对H股指数经常有两个误会。</p><p>误会一：国企指数就是投资国企的。此国企非彼国企。虽然H股指数中确实有不少国企H股，但它本身并不限制非得投资国企。这里所说的国企指数，仅仅是中国企业指数的简称。</p><p>误会二：H股指数就是恒生指数。H股指数的全称是恒生中国企业指数，虽然看起来跟恒生指数很类似，但两者是不同的：恒生指数挑选的是香港股市规模最大的50家公司，而H股指数挑选的是规模最大的40家H股。</p><p>H股指数特点。</p><p>特点之一：内地公司在境外的“代言人”。境外投资者难以直接投资A股，但是中国香港金融市场是开放的，对境外投资者来说，H股是可以随意投资的。所以在很长的一段时间里，H股一直是中国内地公司在世界上的代言人。就连巴菲特也投资过H股。</p><p>特点之二：与内地经济紧密相关，但仍然是以境外投资者为主。H股的公司注册地、主营业务都在内地，所以H股与内地经济紧密相关。实际上H股很多公司也同时在A股上市，像中国平安、招商银行等，所以H股跟内地经济的相关程度更高。但是H股目前仍然是以境外投资者为主。这也是中国香港市场整体的一个特点。境外投资者特别是欧美投资者，对内地公司的熟悉程度不够，当欧美市场出现大幅波动的时候，也会对H股产生影响。</p><p>特点之三：H股与A股指数的亲密关系。H股指数是挑选在中国香港上市的规模最大的40家H股。而这些H股背后的公司，很多也在A股上市。所以H股与A股很多指数的关系都非常密切。</p><h4 id="10-上证50AH优选指数"><a href="#10-上证50AH优选指数" class="headerlink" title="10). 上证50AH优选指数"></a>10). 上证50AH优选指数</h4><p>介绍H股的时候提到过，H股指数和A股指数的关系很紧密。原因很简单，因为很多公司，同时在A股和港股上市，在港股上市的这部分就是H股。例如中国平安，同时有A股和H股，它们背后实际上是一家公司，关系自然很紧密。</p><p>但是H股是在港交所上市，投资者也主要以境外投资者为主，这就导致了H股和A股的涨跌并不同步。有的时候是H股涨得多一些，有的时候是A股涨得多一些。但是长期看，因为背后是同一家公司，所以同一家公司的A股和H股，长期收益是趋于一致的。如果某个时间段，H股相对于A股涨得过高，那未来必然会有一个时间段，A股相对于H股涨得高一些，这样才能保证长期趋于一致。这也就意味着，如果A股和H股差价过大，那么相对便宜的那个未来的收益会更好。这就是AH股轮动策略：买入AH股中相对便宜的那个，卖出相对贵的那个。</p><p>上证50AH优选指数（简称50AH优选指数），就是利用这一原理来获得超额收益。</p><p>特点之一：成份股与上证50相同。50AH优选指数的成份股，跟上证50指数一样，也是挑选上交所规模最大的50家公司，但是它有自己特殊的地方。</p><p>特点之二：成份股入选50AH优选指数时，如果成份股同时具备A股和H股，选相对便宜的那个。如果A股价格&#x2F;H股价格&gt;1.05，说明A股贵，则选相对便宜的H股；反之，如果A股价格&#x2F;H股价格&lt;1.05，则说明A股便宜，选A股。换句话说，50AH优选指数认为，正常情况下，A股应该比H股贵5%。</p><p>特点之三：每个月第二个周五，进行一次轮动。轮动的规则如下：<br> （1）A股价格&#x2F;H股价格&gt;1.05，说明A股贵，如果持有A股，则换成H股。<br> （2）A股价格&#x2F;H股价格&lt;1，说明A股便宜，如果持有H股，则换成A股。<br> （3）如果A股价格&#x2F;H股价格介于1～1.05，则不轮动。<br> 注意一下，轮动时用的标准跟成份股入选指数时用的标准不一样。入选时，是A股价格&#x2F;H股价格，大于1.05选H股，小于1.05选A股。轮动时，是A股价格&#x2F;H股价格，大于1.05选H股，小于1选A股。这样做主要是为了防止当A股价格&#x2F;H股价格的数值正好在1.05左右波动时，造成频繁轮动调仓。每隔一段时间，A股和H股之间的相对折溢价也会呈周期性变化。</p><p>理论上随着未来A股和港股的联系更加紧密，A股与H股之间的涨跌会逐渐同步，这种A股和H股之间的差价也会减少。</p><h4 id="11-纳斯达克100指数"><a href="#11-纳斯达克100指数" class="headerlink" title="11). 纳斯达克100指数"></a>11). 纳斯达克100指数</h4><p>无论是在规模上还是在影响力上，美国股市是当之无愧的世界第一，这得益于美国经济的超强稳定性。美元资产在过去几十年间的表现十分稳定，美股作为美元资产的一类，可以很有效地分散人民币汇率风险。美国股市有两个最主要的指数：纳斯达克100指数、标普500指数。<br> 纳斯达克100指数：纳斯达克是我们比较熟悉的一个股票市场，包括很多新兴经济体，像大家熟知的苹果（Apple）、微软（Microsoft）等公司都在纳斯达克100指数里。纳斯达克100指数投资的是纳斯达克规模最大的100家大型企业。纳斯达克100指数的代码是NDX，简称纳斯达在100。纳斯达克100从1985年100点开始，到2017年5月31日是5 788点。32年上涨了57.8倍，年复合收益率约为13.5%。以技术类公司为主，这就是纳斯达克100指数最大的一个特点，它包括了全世界规模最大的一批信息技术类公司。纳斯达克100在美国本土有很多的指数基金产品。不过我们国内的投资者投资境外市场上市的指数基金比较困难，所以也主要是通过QDII指数基金来投资纳斯达克100的。</p><h4 id="12-标普500指数"><a href="#12-标普500指数" class="headerlink" title="12). 标普500指数"></a>12). 标普500指数</h4><p>标普500指数是美国影响力最大的一个股票指数，是美国传统经济的代表，定位上类似于国内的沪深300指数。我们前面提到过，巴菲特多次推荐指数基金，所提到的其实就是标普500指数基金。</p><p>标普500指数也是以大盘股为主，有500只成份股。不过不同于沪深300指数，标普500指数不单纯按照上市公司的规模来选股票。标普500并不限制入选公司的市值规模，换句话说，标普500不仅有大公司（大约占90%），还有很多中型公司（大约占10%）。</p><p>追踪标普500指数的指数基金是目前世界上规模最大的指数基金。其中，SPY是美国本土最大的一只标普500指数基金，单只规模达到2 000多亿美元，是一个庞然大物。对比一下，国内规模最大的指数基金也只有290亿元人民币。从这里也可以看出，国内的指数基金市场起步还比较晚，属于比较新的事物，未来还有很大的发展空间。</p><h4 id="13-上证综指"><a href="#13-上证综指" class="headerlink" title="13). 上证综指"></a>13). 上证综指</h4><p>上证综指是国内历史最悠久的一个指数，指数代码为000001。从这个代码也可以看出它的重要性。我们平时在新闻里听到的上证3000点、6000点，其实说的就是这个上证综指。综指指的是综合指数，上证综指包括了上交所全部的上市公司，目的是反映上交所所有股票的走势。</p><p>上证综指是从1990年12月19日100点开始的，到2017年5月，上证综指上涨到了3 100点，28年的时间里上涨了31倍，其实收益也是不错的。</p><h4 id="14-等权重指数"><a href="#14-等权重指数" class="headerlink" title="14). 等权重指数"></a>14). 等权重指数</h4><p>什么是等权重指数呢？像上证50指数、沪深300指数等是市值加权的指数，也就是按照市值规模来挑选股票，谁市值越大谁占的权重就越高。而红利指数是根据股息率加权的指数，股息率越高所占的权重就越大。而等权重指数则是分配给每个成份股完全相同的权重。</p><p>例如一个等权重指数基金有100只成份股，1亿的规模，那它就会每个成份股买100万。<br> 开始的时候每个成份股都是相同的权重，但是由于各个成份股的涨跌幅度和速度都不同，就导致一段时间后它们的权重也不同了。所以等权重指数一般每隔一段时间会强制再平衡一次，一般是一年一次。</p><p>这种指数的好处是避免了部分股票在指数中的占比过高。有的指数中，部分成份股占比比较高，几个成份股就占据了指数40%～50%的权重，这样相当于指数的成份股被某几只股票“绑架了”，而等权重指数是最分散的一种指数，每个成份股都是均匀买入的。不过，等权重指数也有缺点，就是流动性比较差，它的流动性取决于流动性最差的那个成份股。</p><p>流动性是投资股票的时候一个很重要的参考因素。简单理解流动性的话，就是看买卖某只股票是否比较顺畅，想买的时候能否买得到，想卖的时候能否卖得出去。有的股票成交量很低，每天只有几万元的成交额，那么这只股票的流动性就比较差。如果一个等权重指数基金有10亿规模，投资100只成份股，那么每一只成份股就要买1 000万，而这1 000万是很难在一个流动性差的股票上买进卖出的，从而会影响等权重指数基金的追踪效果。所以等权重指数基金的规模天生受限，主要是一些小型指数基金采用。</p><h4 id="15-价值指数"><a href="#15-价值指数" class="headerlink" title="15). 价值指数"></a>15). 价值指数</h4><p>价值指数是一种比较有特色的策略加权指数。前面提到过，基本面指数会按照基本面来加权，其实价值指数跟它很相似，只不过用的是4个估值指标来进行筛选：市盈率、市净率、市现率和股息率。国内规模较小，了解即可。</p><h4 id="16-相关指数关系"><a href="#16-相关指数关系" class="headerlink" title="16). 相关指数关系"></a>16). 相关指数关系</h4><p>中证指数公司开发了很多重要的指数，前面介绍过的沪深300、中证500都是它开发的。有的投资者想同时投资大中盘股，于是中证公司就开发了中证800指数。中证800指数＝沪深300指数+中证500指数，基本上把A股的大中型公司都囊括在内，其指数代码为000906。</p><ul><li>上证50指数主要投资沪市规模最大的50只股票，是沪市大盘股的代表指数。（大盘风格）</li><li>沪深300指数主要投资沪深两市规模最大的300只股票，是大盘股的代表指数。（大盘风格）</li><li>中证100指数是从沪深300指数中，再挑选出规模最大的100只股票组成的。比起上证50指数，它覆盖了深交所的大公司，所以更加全面一些。（大盘风格）</li><li>中证200指数是从沪深300指数中提出中证100指数部分后组成的，反映中大盘市值公司的股票表现。（中大盘风格）</li><li>中证500指数投资排除了沪深300包含的300只股票之后的规模最大的500只股票，是中盘股的代表指数。（中小盘风格）</li><li>中证800指数是由沪深300指数和中证500指数的组成，综合反映A股市场大中小市值公司的股票价格表现。（无显著风格）</li><li>中证1000指数是提出中证800指数成分股后，规模偏小且流动性好的1000只股票组成，综合反映A股市场小市值公司的股票价格表现。（小盘风格）</li><li>中证全指目的是覆盖A股全部市场上的股票，除了亏损比较严重的公司和上市不足3个月的新公司。不过中证全指没有对应的基金产品，它主要是为了方便统计A股的整体走势时使用的，其指数代码为399985。</li></ul><p>（1）沪深300 &#x3D; 中证100 + 中证200</p><p>（2）中证700 &#x3D; 中证200 + 中证500</p><p>（3）中证800 &#x3D; 沪深300 + 中证500</p><h3 id="3-行业指数基金"><a href="#3-行业指数基金" class="headerlink" title="3. 行业指数基金"></a>3. 行业指数基金</h3><h4 id="1-什么是行业指数基金"><a href="#1-什么是行业指数基金" class="headerlink" title="1.) 什么是行业指数基金"></a>1.) 什么是行业指数基金</h4><p>前面提到过的上证50指数、沪深300指数、红利指数等，都有一个特点：它们在挑选股票的时候，包括了各行各业，并不限制行业，这样的指数叫作宽基指数。实际上市场上还有一类比较小众的指数基金，这些指数基金专门投资某个行业的股票，也就是行业指数基金。</p><p>为何把行业指数基金单独放在后面介绍，而不是和前面的宽基指数一起介绍呢？这是因为行业指数的投资风险更高一些，不仅要考虑投资价值，还要考虑不同行业自身的特点和当前所处的发展阶段。有的时候，国家政体经济发展不错，但有的行业反而一路衰败。</p><p>例如过去20年，我们国家经济发展得不错，如果长期投资宽基指数基金，我们可以取得不错的收益。但是如果我们投资了收音机、缝纫机行业，那么随着这个行业的萎缩，我们则会遭受到损失。</p><p>行业有自己的投资特点，不能一概而论，需要针对行业的特点具体分析。所以就投资难度来说，行业指数比宽基指数要高出不少。那为何还要投资行业指数基金呢？因为行业指数基金能极大地丰富我们的投资品种。有的时候宽基指数基金没有太好的投资机会，但某些行业指数基金反而会出现投资机会，这就能对我们的投资起到很好的补充作用。<br> 不过行业指数基金的投资难度确实大一些，所以在刚开始接触指数基金投资的时候，建议从宽基指数基金开始入门，积累了足够多经验后再投资行业指数基金。</p><h4 id="2-有哪些行业"><a href="#2-有哪些行业" class="headerlink" title="2). 有哪些行业"></a>2). 有哪些行业</h4><p>既然要投资行业指数基金，我们就得先了解有哪些行业。行业有很多分类方法，不过从指数基金上划分行业最常用的方法，是把行业分为10个一级行业。<br> 摩根士丹利和标普在2000年时联合推出了全球行业分类标准（GICS），将行业分为10个一级行业，24个二级行业，和67个子行业，并建立了行业指数。我国的行业指数很多也是按照这个标准分类的。<br> 其中最主要的10个一级行业分别是：</p><ul><li>材料：金属、采矿、化学制品等。</li><li>可选消费：汽车、零售、媒体、房地产等。</li><li>必需消费：食品、烟草、家居等。</li><li>能源：能源设备与服务、石油天然气等。</li><li>金融：银行、保险、券商等。</li><li>医药：医疗保健、制药、生物科技等。</li><li>工业：航空航天、运输、建筑产品等。</li><li>信息：硬件、软件、信息技术等。</li><li>电信：固定线路、无线通信、电信业务等。</li><li>公共事业：电力、天然气、水等。</li></ul><p>这10个一级行业，每一个都是现代社会不可或缺的重要组成部分。它们可能在投资收益上各有高低，但都非常重要。除了按照10个标准行业来划分，还有另一种划分行业的方式，就是按照某个特定的主题来划分行业。像养老行业、环保行业、军工行业、健康行业、互联网行业等。这些主题行业，是围绕某个主题来找出对应的公司，可能包括相关主题的上下游公司。这是另一种行业的分类方式。</p><p>标准的10个一级行业分类，或者按照某个主题划分的主题行业，这就是行业指数基金的主要两种组成方式。</p><p>定投指数推荐：沪深300指数，红利机会指数，上证50AH优选指数</p><h3 id="4-拓展"><a href="#4-拓展" class="headerlink" title="4. 拓展"></a>4. 拓展</h3><h4 id="1-场内和场外"><a href="#1-场内和场外" class="headerlink" title="1). 场内和场外"></a>1). 场内和场外</h4><p>指数基金从交易渠道上可以分为场内指数基金和场外指数基金。这个场指的是证券交易所。我们如果想获得指数基金，可以跟基金公司申购。我们把钱给基金公司，基金公司给我们对应的基金份额，这就是基金的申购。如果我们不想要这个基金，我们可以把基金份额还给基金公司，基金公司按照基金净值给我们对应的现金，这就是基金的赎回。</p><p>不过，对于场内基金而言，除了可以走申购赎回的方式来跟基金公司交易，也可以把基金份额放在证券交易所中进行交易。例如，我持有10 000股场内基金，可以选择赎回，卖给基金公司，也可以把这些基金卖给其他的个人投资者，后者就是场内基金的买卖。</p><p>简单地说，场内基金在证券交易所上市，可以有“申购赎回”和“买入卖出”两套交易体系，其中买入卖出方式需要在证券交易所中进行，是通过股票交易软件来操作的。如果基金没有在证券交易所上市，那就是场外基金，它只有“申购赎回”一种交易方式。</p><h4 id="2-避开小规模基金"><a href="#2-避开小规模基金" class="headerlink" title="2). 避开小规模基金"></a>2). 避开小规模基金</h4><p>提示：为何要避开规模较小的指数基金？</p><p>如果一个指数基金规模较小，它清盘的概率就比较大。基金清盘并不是说我们的投资血本无归了，而是按照某一个基金净值强制赎回，导致我们的投资中断。如果基金规模太小，那么基金公司运作这个基金可能就是亏本的，基金公司就有可能停止这个基金的运作。所以一般挑选指数基金的时候，会避开规模较小的指数基金，最好规模在1亿以上再考虑。</p><h4 id="3-挑选指数基金"><a href="#3-挑选指数基金" class="headerlink" title="3). 挑选指数基金"></a>3). 挑选指数基金</h4><p>挑选指数基金，一般有两种思路。</p><p>第一种思路是寻找费用最低、误差最小的品种，这是“指数基金之父”约翰·博格所提倡的。因为基金费用越低、误差越小，指数基金的表现就越贴近于指数。这也是挑选指数基金最常用的方式。</p><p>第二种挑选指数基金的思路，是寻找有特色的增强型指数基金。</p><p>什么是增强型指数基金？我们知道，指数基金的目的是复制指数。不过有的时候，股市会出现一些比较明显的能获得超额收益的机会。于是，有的指数基金就会在追踪指数的基础上，去做一些操作来赚取超额收益，例如打新、量化模型等，希望相对于指数获得一些增强收益。这就是增强型指数基金。要注意的是，增强型指数基金的增强操作，一般都不公开，是否能长期持续也不能保证。目前是通过观察历史比较长的增强型指数基金的效果来分析是否有增强收益的。</p><p>另外，还有特殊的基金如联接基金。什么是联接基金？联接基金是基金公司开发的特殊品种。场内基金投资需要开股票账户，具体操作在步骤上也比较麻烦，也没有自动定投的功能。所以基金公司就开发了一个联接基金，方便从场外来投资。</p><p>联接基金是一种场外基金，通过申购赎回来交易。但它并不直接投资股票，而是通过投资对应的场内指数基金来实现复制指数的目的，也是指数基金的一种。<br> 很多基金公司成立ETF基金（交易型开放式指数基金）的时候，大多数也会成立对应的ETF联接基金。ETF联接基金是投资到对应的ETF基金上的，一般不会再单独收取基金管理费，因为ETF已经收取了基金管理费，若再对ETF联接基金收取费用则会导致双重收费。所以联接基金不再单独收费，整体费率跟对应的ETF基金一样，如工银科创版50ETF联接C（011615）。</p>]]></content>
      
      
      <categories>
          
          <category> 《指数基金投资指南》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《指数基金投资指南》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理财：《指数基金投资指南》- 第二章笔记</title>
      <link href="/2023/10/11/%E7%90%86%E8%B4%A2%EF%BC%9A%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/11/%E7%90%86%E8%B4%A2%EF%BC%9A%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是指数"><a href="#1-什么是指数" class="headerlink" title="1. 什么是指数"></a>1. 什么是指数</h3><p>说到指数基金，那自然离不开指数。什么是指数呢？指数是一个选股规则，它的目的是按照某个规则挑选出一篮子股票，并反映这一篮子股票的平均价格走势。</p><p>说起来有些枯燥，但实际上我们在日常生活中也经常会接触到指数。例如一个班级的平均成绩。我们把这个班级学生的语文考试成绩加起来求平均数，这就是一个“语文成绩指数”。这个“语文成绩指数”的走势可以反映这个班级平均语文成绩的走势。这就是指数的作用。</p><p>股市上有上千只股票，我们如何知道它们今天整体是涨是跌呢？股票指数就诞生了。<br>例如我们熟悉的<strong>沪深 300 指数</strong>。沪深 300 指数是由上海和深圳证券市场中选取 300 只 A 股作为样本编制而成的成份股指数。</p><h3 id="2-指数基金是怎么来的"><a href="#2-指数基金是怎么来的" class="headerlink" title="2. 指数基金是怎么来的"></a>2. 指数基金是怎么来的</h3><p>前面提到过，指数是一种选股规则，按照某个规则挑选出一篮子股票。如果有基金公司开发一个基金产品，也完全按照指数的选股规则去买入完全一样的一篮子股票，这就是指数基金了。</p><p>因为指数基金持有股票的种类、数量、比例都跟指数非常接近，所以指数基金的表现也跟指数非常接近。或者说，指数基金把指数这个抽象的概念，变成了可以实际交易的产品。</p><p>因为指数的规则是公开的，所以各家基金公司拿到指数的规则之后，都可以自己开发出对应的指数基金产品。像国内比较出名的沪深 300，追踪这个指数的指数基金就有几十只之多。因为追踪的是同样的指数，它们持有股票的种类、数量、比例都非常接近，所以它们的表现也都非常接近，并且都跟沪深 300 表现也比较近似。因为指数的选股规则是固定并且公开透明的，所以指数基金的基金经理在挑选股票的时候，受到指数的限制，指数基金的基金经理不得随意按照自己的喜好去挑选股票，必须按照指数来挑选。</p><p>简单来说，指数基金是一种特殊的股票基金。一般的股票基金依赖于基金经理的个人决策能力，而指数基金不一样：它是以某指数作为模仿对象，按照该指数构成的标准，购买该指数包含的证券市场中全部或部分的证券，目的在于获得与该指数相同的收益水平。一般的股票基金，依赖于基金经理的投资水平，基金的业绩好不好跟很大程度上取决于基金经理的能力；而指数基金的业绩跟基金经理的关系不大，主要取决于对应指数的表现。这是指数基金跟普通的股票基金最大的一个不同点。</p><h3 id="阅读小结"><a href="#阅读小结" class="headerlink" title="阅读小结"></a>阅读小结</h3><ul><li>指数是一个选股规则，它的目的是按照某个规则挑选出一篮子股票，并反映这一篮子股票的平均价格走势。</li><li>指数基金追踪指数，完全按照指数的选股规则去买入完全一样的一篮子股票。</li><li>指数基金有三个独特的好处：长生不老、长期上涨、成本低。</li><li>指数基金是最适合普通投资者的投资品种，如美国的 401（k）养老计划中有很大一部分比例投资于指数基金，一个普普通通的工薪族靠着普普通通的收入也能通过投资指数基金实现财务自由。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《指数基金投资指南》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《指数基金投资指南》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理财：《指数基金投资指南》- 第一章笔记</title>
      <link href="/2023/10/08/%E7%90%86%E8%B4%A2%EF%BC%9A%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/10/08/%E7%90%86%E8%B4%A2%EF%BC%9A%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-找到长期收益率最高的资产"><a href="#1-找到长期收益率最高的资产" class="headerlink" title="1. 找到长期收益率最高的资产"></a>1. 找到长期收益率最高的资产</h3><p>有的资产可以产生现金流，例如债券、股票、房地产（可以收租金）、银行理财、P2P理财等。有的资产则无法产生现金流，例如黄金、玉佩等。</p><p>为什么要分为能产生现金流的资产和不能产生现金流的资产呢？这是因为，本质上，这两种资产的价格驱动因素不同。</p><p>能够产生现金流的资产，它的价格主要取决于现金流的大小和稳定性。不能产生现金流的资产，价格都是由供求关系决定的。</p><p><strong>结论：</strong>能产生现金流的资产通常比不能产生现金流的资产长期收益率更高；能产生现金流的资产中，现金流越高，长期收益率更高。</p><h3 id="2-风险和收益"><a href="#2-风险和收益" class="headerlink" title="2. 风险和收益"></a>2. 风险和收益</h3><p>不要贪婪，避免不合理的高收益，一切<strong>金融骗局</strong>都是纸老虎。</p><h3 id="3-基金类型"><a href="#3-基金类型" class="headerlink" title="3. 基金类型"></a>3. 基金类型</h3><p>简单理解，基金就是一个篮子，里面可以按照预先设定好的规则，装入各种各样资产。这样做的好处是，把一篮子资产分割成若干小份，一小份才几元，用较少的资金就可以投资了。这样一来，原来普通人买不起的资产，现在可以通过购买基金的方式投资了。<br>例如：</p><ul><li>装入各种短期债券、短期理财、现金，就是货币基金。</li><li>装入各种企业债、国债，就是债券基金。</li><li>装入各个公司的股票，就是股票基金。</li><li>装入股票和债券，就是混合基金。</li></ul><h3 id="阅读小结"><a href="#阅读小结" class="headerlink" title="阅读小结"></a>阅读小结</h3><p>能够为我们“生钱”的就是资产，现金不是资产。<br>有的人看起来“富有”，但一旦停止工作，高收入也就戛然而止。<br>通过定期投资指数基金，业余投资者往往能够战胜大部分专业投资者</p>]]></content>
      
      
      <categories>
          
          <category> 《指数基金投资指南》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《指数基金投资指南》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript：一些需要注意的JavaScript设计失误</title>
      <link href="/2023/08/13/JavaScript%EF%BC%9A%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84JavaScript%E8%AE%BE%E8%AE%A1%E5%A4%B1%E8%AF%AF/"/>
      <url>/2023/08/13/JavaScript%EF%BC%9A%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84JavaScript%E8%AE%BE%E8%AE%A1%E5%A4%B1%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>拜读 <a href="https://haoqun.blog/zh/2016/javascript-design-regrets-cf9619ba">JavaScript 的设计失误 - Offline (haoqun.blog)</a> 博客时发现一些自己未听过，但是在实践具有隐患的语言设计失误，在此做笔记记录。</p><h3 id="1-Stateful-RegExps"><a href="#1-Stateful-RegExps" class="headerlink" title="1. Stateful RegExps"></a>1. Stateful RegExps</h3><p>很难想象正则对象上的函数是有状态的，如 <code>test</code> 是一个有状态的函数，在编写代码时遇到需要多次判断或很长的正则，一般是定义独立的正则变量以便使用。</p><p>在编写代码时，请注意以下写法。虽然很少，但不是没有。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/foo/g</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;foo foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;foo foo&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/foo/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  reg.<span class="title function_">test</span>(<span class="string">&quot;foo foo&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> flag1 = reg.<span class="title function_">test</span>(<span class="string">&quot;foo foo&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> flag2 = reg.<span class="title function_">test</span>(<span class="string">&quot;foo foo&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(flag1, flag2);</span><br><span class="line">  <span class="keyword">if</span> (flag2) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;secondary&quot;</span>); <span class="comment">// unprinted 未打印</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://haoqun.blog/zh/2016/javascript-design-regrets-cf9619ba">JavaScript 的设计失误 - Offline (haoqun.blog)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四. 浏览器内部工作原理-内存方向</title>
      <link href="/2023/08/10/%E5%9B%9B.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%96%B9%E5%90%91/"/>
      <url>/2023/08/10/%E5%9B%9B.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="四-浏览器内部工作原理-内存方向"><a href="#四-浏览器内部工作原理-内存方向" class="headerlink" title="四. 浏览器内部工作原理-内存方向"></a>四. 浏览器内部工作原理-内存方向</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为方便读者阅读，贴出以下参考链接，在此感谢前辈笔记。</p><p>浏览器解析过程分析：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>浏览器工作过程分析：<a href="https://zhuanlan.zhihu.com/p/96986818">万字详文：深入理解浏览器原理 - 知乎 (zhihu.com)</a></p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 浏览器内部工作原理-内存方向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三. 浏览器内部工作原理-解析方向（总）</title>
      <link href="/2023/08/06/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E6%80%BB%EF%BC%89/"/>
      <url>/2023/08/06/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E6%80%BB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为方便读者阅读，贴出以下参考链接，在此感谢前辈笔记。</p><p>浏览器解析过程分析：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>浏览器工作过程分析：<a href="https://zhuanlan.zhihu.com/p/96986818">万字详文：深入理解浏览器原理 - 知乎 (zhihu.com)</a></p><h2 id="1-树的构建流程"><a href="#1-树的构建流程" class="headerlink" title="1. 树的构建流程"></a>1. 树的构建流程</h2><p><img src="/assets/image-20220902091918-3jgz0jo.png" alt="image.png"></p><p>HTML 和 CSS 的页面解析是从上之下的，<strong>线程的</strong>。文档流从上往下，若先碰到了 CSS，那么开始解析，接着<strong>不被阻塞的</strong>继续向下解析 HTML，这样既符合并行解析，又符合文档流自上往下解析规则。浏览器先下载 HTML 文件开始解析，遇到 CSS 标签就开始下载 CSS 并解析，这个过程不会阻塞 DOM 的构建。最后 DOM 树和 CSS 规则树生成渲染树，HTML 解析完成。</p><p>注意几点：</p><ol><li>CSS 加载不会阻塞 DOM 树的<strong>解析</strong></li><li>CSS 加载会阻塞 DOM 树的<strong>渲染</strong>（不阻塞解析），即合并成渲染树的过程，因为样式可能会导致重排重绘</li><li>CSS 加载会阻塞后面 JS 语句的执行</li></ol><p>解析、渲染这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时还可能通过网络下载其余内容。</p><h3 id="1-1-HTML-Parser"><a href="#1-1-HTML-Parser" class="headerlink" title="1.1 HTML Parser"></a>1.1 HTML Parser</h3><h4 id="1-1-1-解析"><a href="#1-1-1-解析" class="headerlink" title="1.1.1 解析"></a>1.1.1 解析</h4><p>解析的目的是：将文档转换为具有一定意义的结构，编码时可以理解和使用的东西。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。</p><blockquote><p>解析的目的在于让目标更接近于需要使用的形式，或更具体的描述一些信息。如高级语言先转换为汇编等低级语言，最后再转换成机器码，又或者是家具的运输与组装，零件形式更接近于运输模式，成品形式更接近于使用模式，由成品拆分成零件就是使其更接近于运输模式，同样的道理将文档解析成另外一个格式会更适合某一个场景的使用。</p></blockquote><p>如解析“2＋3－1”这个表达式，可能返回这样一棵树。</p><p><img src="/assets/image-20220902121038-5xudoir.png" alt="image.png"></p><p>解析过程与翻译过程类似，需要具备两个条件，字典和语法规则。</p><p><strong>文法（Grammars）</strong>：解析基于文档依据的语法规则——文档的语言或格式。每种可被解析的格式必须具有由词汇及语法规则组成的特定的文法，称为上下文无关文法。简单来说就是由词汇表、语法规则组成的对某一个格式的限制，与当前文件内容无关。</p><blockquote><p>文法不等于语法规则，文法是词汇表和语法规则的结合，如语法规则定义为“<strong>的</strong>字后面跟着表示事物的名词，<strong>地</strong>字跟在动词后面，<strong>得</strong>字后面跟着形容词”，词汇表则有“谁，得，的，地，花，走，快”，文法规则就是词汇表和语法规则的结合，包含任何一个可能选择，如“谁的花，走得快，的，得，地”等。</p></blockquote><p>解析可以分成两个子过程：</p><ul><li>词法分析</li><li>语法分析</li></ul><p><strong>词法分析</strong>是将文档中的字词按照一定地规则（词汇表）分成符号，符号对应的便是词汇表（基本有效单元的集合）中的某一项。对于人类语言来说，它相当于我们字典中出现的所有单词。</p><p><strong>语法分析</strong>是根据语法规则匹配词法分析后的符号，生成特定状态的过程。</p><p>词法分析器（有时也叫分词器）负责将输入分解为合法的符号，语法分析器则根据语言的语法规则分析文档结构，从而构建解析树，词法分析器知道怎么跳过空白和换行之类的无关字符。</p><p><img src="/assets/image-20220902133652-u2je5s2.png" alt="image.png"></p><p>解析过程是<strong>迭代的</strong>，语法分析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后语法分析器分析下一个符号。如果没有匹配到规则，语法分析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</p><blockquote><p>词法分析器和语法分析器的工作是同步的，正如组装家具时，找到一个一个零件，根据说明书进行组装，如果没有找齐零件，是无法组装某一个个体的。</p></blockquote><h4 id="1-1-2-转换"><a href="#1-1-2-转换" class="headerlink" title="1.1.2 转换"></a>1.1.2 转换</h4><p>转换对工作人员来说是一个隐式的过程，正如在浏览器开发者控制台运行一些代码、打印日志信息一样，开发者可能感受不到转换到机器码的过程。但是编写的源代码并不是最终的目标，底层机器码才是机器识别、运行的格式。</p><p>很多时候，解析树并不是最终结果。解析一般在转换中使用——将输入文档转换为另一种格式。编译就是个例子，编译器在将一段源码编译为机器码的时候，先将源码解析为解析树，然后将该树转换为一个机器码文档。</p><p>简单来说<strong>转换</strong>过程在编译运行时就存在，将源代码转换为机器码，转换时是无感的。</p><p><img src="/assets/image-20220902140802-boi3thw.png" alt="image.png"></p><p>详细的例子可以看看：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>，如不熟悉抽象语法树的概念，可以看看：<a href="https://juejin.cn/post/6844904035271573511">手把手带你入门 AST 抽象语法树 - 掘金 (juejin.cn)</a>。</p><h4 id="1-1-3-深入"><a href="#1-1-3-深入" class="headerlink" title="1.1.3 深入"></a>1.1.3 深入</h4><p><strong>HTML解析器（HTML Parser）：</strong>HTML解析器的工作是将html标识解析为解析树。</p><p><strong>HTML文法定义（The HTML grammar definition）：</strong>W3C组织制定规范定义了HTML的词汇表和语法。</p><p><strong>非上下文无关文法（Not a context free grammar）：</strong>正如在解析简介中提到的，上下文无关文法的语法可以用类似BNF的格式来定义。</p><blockquote><p>HTML 有一个正式的格式定义—— DTD（Document Type Definition文档类型定义），但它并不是上下文无关文法，HTML 更接近于 XML，现在有很多可用的xml 解析器，html 有个 xml 的变体——xhtml，不同在于 html 更宽容，它允许忽略一些特定标签，有时可以省略开始或结束标签。总的来说，它是一种 soft 语法，不像 xml 呆板、固执。</p><p>显然，这个看起来很小的差异却带来了很大的不同。一方面，这是 html 流行的原因——它的宽容使 web 开发人员的工作更加轻松，但另一方面，这也使很难去写一个格式化的文法。所以，html 的解析并不简单，它既不能用传统的解析器解析，也不能用 xml 解析器解析。</p></blockquote><p><strong>HTML DTD</strong></p><p>html 适用 DTD 格式进行定义，这一格式是用于定义 SGML 家族的语言，包括了对所有允许元素及它们的属性和层次关系的定义。正如前面提到的，html DTD 并没有生成一种上下文无关文法。DTD 有一些变种，标准模式只遵守规范，而其他模式则包含了对浏览器过去所使用标签的支持，这么做是为了兼容以前内容。最新的标准 DTD 在<a href="http://www.w3.org/TR/html4/strict.dtd">http://www.w3.org/TR/html4/strict.dtd</a>。</p><p><strong>DOM</strong></p><p>解析输出的树也就是解析树，是由 DOM 元素及属性节点组成的。DOM 是文档对象模型的缩写，它是 html 文档的对象表示，作为 html 元素的外部接口供 JS 等调用。DOM 和标签基本是一一对应的关系。</p><p><strong>解析器类型（Types of parsers）</strong></p><p>有两种基本的解析器——自顶向下解析及自底向上解析。比较直观的解释是，自顶向下解析，查看语法的最高层结构并试着匹配其中一个；自底向上解析则从输入开始，逐步将其转换为语法规则，从底层规则开始直到匹配高层规则。</p><p>来看一下这两种解析器如何解析 “2+3-1” 的例子：<strong>自顶向下</strong>解析器从最高层规则开始——它先识别出“2+3”，将其视为一个表达式，然后识别出 “2+3-1” 为一个表达式（识别表达式的过程中匹配了其他规则，但出发点是最高层规则）。<strong>自底向上</strong>解析会扫描输入直到匹配了一条规则，然后用该规则取代匹配的输入，直到解析完所有输入。部分匹配的表达式被放置在解析堆栈中。</p><p>自顶向下与递归过程类似，从整体开始逐步检查子问题，而自底向上与递推过程类似，从子问题开始推向整体。</p><p><strong>自动化解析（Generating parsers automatically）</strong></p><p>解析器生成器这个工具可以自动生成解析器，只需要指定语言的文法——词汇表及语法规则，它就可以生成一个解析器。创建一个解析器需要对解析有深入的理解，而且手动的创建一个由较好性能的解析器并不容易，所以解析生成器很有用。Webkit使用两个知名的解析生成器——<strong>用于创建语法分析器的Flex</strong>及<strong>创建解析器的Bison</strong>（你可能接触过Lex和Yacc）。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p><p>稍微总结：HTML 解析器按照 HTML DTD 文法定义进行 HTML 解析，可以认为解析生成的 DOM 树与解析树一一映射，DOM 树就是解析树。</p><h4 id="1-1-4-解析算法"><a href="#1-1-4-解析算法" class="headerlink" title="1.1.4 解析算法"></a>1.1.4 解析算法</h4><p>HTML 不能被一般的自顶向下或自底向上的解析器所解析，不能使用正则解析技术，浏览器为 HTML 定制了专属的解析器，原因是：</p><ol><li>这门语言本身的宽容特性</li><li>浏览器对一些常见的非法html有容错机制</li><li>解析过程是往复的，通常源码不会在解析过程中发生改变，但在 HTML 中，脚本标签包含的 “document.write” 可能添加标签，这说明在解析过程中实际上修改了输入，所以不能使用正则解析技术</li></ol><p>HTML5 规范中描述了这个解析算法，算法包括两个阶段——符号化及构建树。</p><p>符号化是<strong>词法分析</strong>的过程，将输入解析为符号，HTML 的符号包括开始标签、结束标签、属性名及属性值。符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，以识别下一个符号，直到处理完所有输入。</p><p><strong>符号识别算法（The tokenization algorithm）</strong></p><p>算法输出 HTML 符号，该算法用状态机表示。每次读取输入流中的一个或多个字符，并根据这些字符转移到下一个状态，当前的符号状态及构建树状态共同影响结果，这意味着，读取同样的字符，可能因为当前状态的不同，得到不同的结果以进入下一个正确的状态。</p><p>这个算法很复杂，这里用一个简单的例子来解释这个原理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello world</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>初始状态为“Data State”，当遇到“&lt;”字符，状态变为“Tag open state”，读取一个a－z的字符将产生一个开始标签符号，状态相应变为“Tag name state”，一直保持这个状态直到读取到“&gt;”，每个字符都附加到这个符号名上，例子中创建的是一个html符号。</p><p>当读取到“&gt;”，当前的符号就完成了，此时状态回到“Data state”，“\body&gt;”重复这一处理过程。到这里，html和body标签都识别出来了。现在，回到“Data state”，读取“Hello world”中的字符“H”将创建并识别出一个字符符号，这里会<strong>为“Hello world”中的每个字符生成一个字符符号</strong>。</p><p>这样直到遇到“&lt;&#x2F;body&gt;”中的“&lt;”。现在，又回到了“Tag open state”，读取下一个字符“/”将创建一个闭合标签符号，并且状态转移到“Tag name state”，还是保持这一状态，直到遇到“&gt;”。然后，产生一个新的标签符号并回到“Data state”。后面的“&lt;&#x2F;html&gt;”将和“&lt;&#x2F;body&gt;”一样处理。</p><p><img src="/assets/image-20220903152441-lnzo21q.png" alt="image.png"></p><p><strong>简单总结：</strong>因为 HTML 符号包括开始标签、结束标签、属性名及属性值，所以解析每一个符号都需要三个状态来决定。状态机+符号化+树构建器。<strong>符号并不仅仅只是一个字符</strong>，可以是标签符号包括标签名、属性等，除标签符号外，为每一个内容字符创建一个字符符号（Data State）。</p><p><strong>树的构建算法（Tree construction algorithm）</strong></p><p>在树的构建阶段，将<strong>修改</strong>以Document为根的DOM树，将元素附加到树上。每个由符号识别器识别生成的节点将会被树构造器进行处理，规范中定义了每个符号相对应的Dom元素，<strong>对应的Dom元素将会被创建</strong>。这些元素除了会被添加到Dom树上，还将被添加到开放元素堆栈中。这个堆栈用来纠正嵌套的未匹配和未闭合标签，这个算法也是用状态机来描述，所有的状态采用插入模式。</p><p>首先是“initial mode”，接收到html符号后将转换为“before html”模式，在这个模式中对这个符号进行再处理。此时，创建了一个HTMLHtmlElement元素，并将其附加到根Document对象上。</p><p>状态此时变为“before head”，接收到body符号时，即使这里没有head符号，也将自动创建一个HTMLHeadElement元素并附加到树上。</p><p>现在，转到“in head”模式，然后是“after head”。到这里，body符号会被再次处理，将创建一个HTMLBodyElement并插入到树中，同时，转移到“in body”模式。</p><p>然后，接收到字符串“Hello world”的字符符号，第一个字符将导致创建并插入一个text节点，其他字符将附加到该节点。</p><p>接收到body结束符号时，转移到“after body”模式，接着接收到html结束符号，这个符号意味着转移到了“after after body”模式，当接收到文件结束符时，整个解析过程结束。</p><p><img src="/assets/image-20220903152422-pm7uawo.png" alt="image.png"></p><p><strong>简单总结：</strong>树构建器根据符号创建对应的DOM元素，附加到以Document为根的DOM树上，并对一些常见的 HTML 错误进行处理。</p><h4 id="1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）"><a href="#1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）" class="headerlink" title="1.1.5 解析结束时的处理（Action when the parsing is finished）"></a>1.1.5 解析结束时的处理（Action when the parsing is finished）</h4><p>在这个阶段，浏览器将文档标记为可交互的，并开始解析处于延时模式中的脚本——这些脚本在文档解析后执行。文档状态将被设置为完成，同时触发一个 <strong>load</strong> 事件。</p><p>HTML5 规范中有符号化及构建树的完整算法：<a href="http://www.w3.org/TR/html5/syntax.html#html-parser">链接</a>。</p><h4 id="1-1-6-浏览器容错（Browsers-error-tolerance）"><a href="#1-1-6-浏览器容错（Browsers-error-tolerance）" class="headerlink" title="1.1.6 浏览器容错（Browsers error tolerance）"></a>1.1.6 浏览器容错（Browsers error tolerance）</h4><p>详细可查看原文：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><h3 id="1-2-CSS-Parser"><a href="#1-2-CSS-Parser" class="headerlink" title="1.2 CSS Parser"></a>1.2 CSS Parser</h3><p>CSS 的加载并不会阻塞 DOM 的解析，但是会阻塞 DOM 的渲染。因为加载 CSS 时，可能会修改当前解析位置以后的 DOM 节点的样式，如果 CSS 加载不阻塞 DOM 树渲染，那么当 CSS 加载完之后，DOM 树可能又得重新重排 layout（回流reflow）或者重绘了，这就造成了一些没有必要的损耗。</p><p>不同于HTML，CSS属于上下文无关文法，可以用前面所描述的解析器来解析。CSS规范定义了CSS的词法及语法文法。可以参考词汇表和语法规则：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>。</p><p>每个符号都由正则表达式定义了词法文法（词汇表）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comment<span class="comment">///*[^*]*/*+([^/*][^*]*/*+)*//</span></span><br><span class="line">num[<span class="number">0</span>-<span class="number">9</span>]+|[<span class="number">0</span>-<span class="number">9</span>]*<span class="string">&quot;.&quot;</span>[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">nonascii[<span class="regexp">/200-/</span><span class="number">377</span>]</span><br><span class="line">nmstart[_a-z]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">nmchar[_a-z0-<span class="number">9</span>-]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">name&#123;nmchar&#125;+</span><br><span class="line">ident&#123;nmstart&#125;&#123;nmchar&#125;*</span><br></pre></td></tr></table></figure><p>“ident”是识别器的缩写，相当于一个class名，“name”是一个元素id（用“＃”引用）。</p><p>语法用BNF进行描述：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">: selector [ <span class="string">&#x27;,&#x27;</span> S* selector ]*</span><br><span class="line"><span class="string">&#x27;&#123;&#x27;</span> S* declaration [ <span class="string">&#x27;;&#x27;</span> S* declaration ]* <span class="string">&#x27;&#125;&#x27;</span> S*</span><br><span class="line">;</span><br><span class="line">selector</span><br><span class="line">: simple_selector [ combinator selector | S+ [ combinator selector ] ]</span><br><span class="line">;</span><br><span class="line"><span class="keyword">class</span></span><br><span class="line">: <span class="string">&#x27;.&#x27;</span> <span class="variable constant_">IDENT</span></span><br><span class="line">;</span><br><span class="line">element_name</span><br><span class="line">: <span class="variable constant_">IDENT</span> | <span class="string">&#x27;*&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>一个规则集合具有一个或是可选个数的多个选择器，这些选择器以逗号和空格（S表示空格）进行分隔。每个规则集合包含大括号及大括号中的一条或多条以分号隔开的声明。声明和选择器在后面进行定义。</p><h4 id="1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）"><a href="#1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）" class="headerlink" title="1.2.1 Webkit CSS解析器（Webkit CSS parser）"></a>1.2.1 Webkit CSS解析器（Webkit CSS parser）</h4><p>Webkit使用Flex和Bison解析生成器从CSS语法文件中自动生成解析器。回忆一下解析器的介绍，Bison创建一个自底向上的解析器，Firefox使用自顶向下解析器。它们都是将每个css文件解析为样式表对象，每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。</p><blockquote><p>用于创建语法分析器的Flex及创建解析器的Bison。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p></blockquote><p><img src="/assets/image-20220903160338-wjh6j4x.png" alt="image.png"></p><p>注意：WebKit使用的是自底向上的解析器</p><blockquote><p>处理脚本及样式表的顺序（The order of processing scripts and style sheets）</p><p>脚本：web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。HTML5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。</p><p>async是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行；而Defer是在JS加载完成后，整个文档解析完成后执行。 Defer更像是将&lt;script&gt;标签放在&lt;&#x2F;body&gt;之后的效果，但是它由于是异步加载JS文件，所以可以节省时间。简单来说就是async和defer都是开启新线程（http线程）请求JS文件，和解析DOM并行不冲突，async在请求完成后就开始执行JS文件，而defer则是在整个DOM解析完成后再执行JS文件。</p><p>预解析（Speculative parsing）</p><p>Webkit和Firefox都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变Dom树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p></blockquote><p>StyleSheets样式表采用另一种模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。</p><p><strong>简单总结：</strong>WebKit用Flex生成CSS语法规则，Bison生成CSS解析器。样式表不阻塞DOM解析，但是阻塞DOM渲染，FireFox在样式文件未加载完成前阻塞JS脚本，目的是防止样式文件未加载完成而JS脚本需要获取样式文件信息的错误，Chrome只阻塞那些访问未加载完成的样式文件的JS脚本，样式加载完成即不堵塞。</p><h3 id="1-3-Render-Tree"><a href="#1-3-Render-Tree" class="headerlink" title="1.3 Render Tree"></a>1.3 Render Tree</h3><h4 id="1-3-1-渲染树的定义"><a href="#1-3-1-渲染树的定义" class="headerlink" title="1.3.1 渲染树的定义"></a>1.3.1 渲染树的定义</h4><p>当Dom树构建完成时，浏览器开始构建另一棵树——渲染树。渲染树由元素显示序列中的可见元素组成，它是文档的可视化表示，构建这棵树是为了以正确的顺序绘制文档内容。</p><p>Firefox将渲染树中的元素称为frames，WebKit则用renderer或渲染对象来描述这些元素.一个渲染对象知道怎么布局及绘制自己及它的 children？</p><p>RenderObject是Webkit的渲染对象基类，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RenderObject</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">layout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(PaintInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> rect <span class="title">repaintRect</span><span class="params">()</span></span>;</span><br><span class="line">    Node* node;<span class="comment">//the DOM node</span></span><br><span class="line">    RenderStyle* style;<span class="comment">// the computed style</span></span><br><span class="line">    RenderLayer* containgLayer; <span class="comment">//the containing z-index layer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个渲染节点对象用一个和该节点 CSS 盒模型相对应的矩形区域来表示，正如 CSS2 所描述的那样，它包含诸如宽、高和位置之类的几何信息。盒模型的类型受该节点相关的 display 样式属性的影响（参考样式计算章节）。下面的 WebKit 代码说明了如何根据 display 属性决定某个节点创建何种类型的渲染对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RenderObject* <span class="title">RenderObject::createObject</span><span class="params">(Node* node, RenderStyle* style)</span> </span>&#123;</span><br><span class="line">    Document* doc = node-&gt;<span class="built_in">document</span>();</span><br><span class="line">    RenderArena* arena = doc-&gt;<span class="built_in">renderArena</span>();</span><br><span class="line">    ...</span><br><span class="line">    RenderObject* o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (style-&gt;<span class="built_in">display</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> NONE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderInline</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE_BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LIST_ITEM:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderListItem</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的类型也需要考虑，例如，表单控件和表格带有特殊的框架。</p><p>在Webkit中，如果一个元素想创建一个特殊的渲染对象，它需要重写“createRenderer”方法，使渲染对象指向不包含几何信息的样式对象。</p><p><strong>简单总结：</strong>渲染树是可视节点的集合，即在页面真实渲染的元素集合，底层使用c++进行渲染，通过c++定义不同的对象实现不同类型节点的渲染</p><h4 id="1-3-2-渲染树和DOM树的关系"><a href="#1-3-2-渲染树和DOM树的关系" class="headerlink" title="1.3.2 渲染树和DOM树的关系"></a>1.3.2 渲染树和DOM树的关系</h4><p>渲染对象和Dom元素相对应，但这种对应关系不是一对一的，不可见的Dom元素不会被插入渲染树，如head元素，display属性为none的元素（渲染树中存在 visibility 属性为 hidden 或着 opacity 属性为0的元素）。</p><p>还有一些Dom元素对应几个可见对象，它们一般是具有<strong>复杂结构</strong>的元素，无法用一个矩形来描述。例如，select元素有三个渲染对象——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而<strong>换行</strong>时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的 HTML结构，根据 CSS 规范，<strong>一个行内元素只能仅包含行内元素或仅包含块状元素，存在混合内容时，将会创建匿名的块状渲染对象包裹行内元素</strong>。</p><p><img src="/assets/image-20220905163521-nfbbt1n.png" alt="image.png"></p><h4 id="1-3-3-创建树的流程（The-flow-of-constructing-the-tree）"><a href="#1-3-3-创建树的流程（The-flow-of-constructing-the-tree）" class="headerlink" title="1.3.3 创建树的流程（The flow of constructing the tree）"></a>1.3.3 创建树的流程（The flow of constructing the tree）</h4><p>Firefox中，表述为一个监听Dom更新的监听器，将frame的创建委派给Frame Constructor，这个构建器计算样式（参看样式计算）并创建一个frame。</p><p>Webkit中，计算样式并生成渲染对象的过程称为 attachment，每个Dom节点有一个attach方法，attachment的过程是<strong>同步</strong>的，调用新节点的 attach 方法将节点插入到Dom树中。处理 html 和 body 标签将构建渲染树的根，这个<strong>根渲染对象</strong>对应被 css 规范称为 containing block 的元素——<strong>包含</strong>了其他所有块元素的顶级块元素。它的大小就是 <strong>viewport</strong>——浏览器窗口的显示区域，Firefox称它为 viewPortFrame，webkit称为 RenderView，这个就是文档 document 所指向的渲染对象，树中其他的部分都将作为一个插入的Dom节点被创建。</p><p><strong>简单总结：</strong>不同的内核对于合并的过程有不同的称呼，WebKit中使用attachment，构建渲染树会扫描DOM树和CSSOM树，扫描DOM树发现HTML、BODY元素时，就会创建一个根渲染对象，称为<strong>containing block</strong>，大小就是viewport。</p><h4 id="1-3-4-样式计算（Style-Computation）"><a href="#1-3-4-样式计算（Style-Computation）" class="headerlink" title="1.3.4 样式计算（Style Computation）"></a>1.3.4 样式计算（Style Computation）</h4><p>创建渲染树需要计算出每个渲染对象的可视属性，这可以通过计算每个元素的样式属性得到。</p><p>样式包括各种来源的<strong>样式表</strong>，<strong>行内样式元素</strong>及html中的<strong>可视化属性</strong>（例如bgcolor），可视化属性转化为css样式属性。</p><p>样式表的来源包括浏览器默认样式表、页面作者以及用户提供的样式表（有些样式是浏览器用户提供的（浏览器允许用户定义喜欢的样式，例如，在Firefox中可以通过在Firefox Profile目录下放置样式表实现））。</p><p>计算样式的一些困难：</p><ol><li>样式数据是非常大的结构，保存大量的样式属性会带来内存问题。</li><li>如果不进行优化，找到每个元素匹配的规则会导致性能问题，为每个元素查找匹配的规则都需要遍历整个规则表，这个过程有很大的工作量。选择符可能有复杂的结构，匹配过程如果沿着一条开始看似正确，后来却被证明是无用的路径，则必须去尝试另一条路径。例如，复杂选择符 <code>div div div div｛…｝</code> 这意味着规则应用到三个div的后代div元素，选择树某一条特定的路径去检查，这可能需要遍历节点树，最后却发现它只是两个div的后代，并不使用该规则，然后则需要沿着另一条路径去尝试</li><li>应用规则涉及非常复杂的级联，它们定义了规则的层次</li></ol><p><strong>浏览器如何处理这些问题？</strong></p><p>共享样式数据（Sharing style data）</p><p>WebKit节点引用样式对象（渲染样式），某些情况下，这些对象可以被节点间共享，这些节点需要是兄弟或是表兄弟节点，并且：</p><ol><li>这些元素必须处于相同的鼠标状态（比如不能一个处于hover，而另一个不是）</li><li>不能有元素具有id</li><li>标签名必须匹配</li><li>class属性必须匹配</li><li>对应的属性必须相同</li><li>链接状态必须匹配</li><li>焦点状态必须匹配</li><li>不能有元素被属性选择器影响</li><li>元素不能有行内样式属性</li><li>不能有生效的兄弟选择器，webcore在任何兄弟选择器相遇时只是简单的抛出一个全局转换，并且在它们显示时使整个文档的样式共享失效，这些包括＋选择器和类似:first-child和:last-child这样的选择器。</li></ol><p>Firefox规则树（Firefox rule tree）</p><p>Firefox用两个树用来简化样式计算－规则树和样式上下文树，WebKit也有样式对象，但它们并没有存储在类似样式上下文树这样的树中，只是由Dom节点指向其相关的样式。</p><p><img src="/assets/image-20220905204116-occzqvw.png" alt="image.png" title="Firefox样式上下文树"></p><p>具体细节可以阅读原文：<a href="https://kb.cnblogs.com/page/129756/#chapter4">浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>Webkit中，并没有规则树，匹配的声明会被遍历四次，先是应用非important的高优先级属性（之所以先应用这些属性，是因为其他的依赖于它们－比如display），其次是高优先级important的，接着是一般优先级非important的，最后是一般优先级important的规则。这样，出现多次的属性将被按照正确的级联顺序进行处理，最后一个生效。</p><h3 id="1-4-Layout"><a href="#1-4-Layout" class="headerlink" title="1.4 Layout"></a>1.4 Layout</h3><p>当渲染对象被创建并添加到树中，它们仅具有对应的布局规则，并没有实际的位置和大小，计算这些值的过程称为 layout 或 reflow。</p><p>Html使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中<strong>从右向左</strong>、<strong>自上而下</strong>的进行。也存在一些例外，比如 html tables。</p><p>坐标系统相对于根frame，使用 top 和 left 坐标。布局是一个<strong>递归</strong>的过程，由根渲染对象开始，它对应 html 文档document元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。根渲染对象的位置是 0,0，它的大小是viewport－浏览器窗口的可见部分。所有的渲染对象都有一个 layout 或 reflow 方法，每个渲染对象调用<strong>需要布局</strong>的 children 的 layout 方法。</p><p><strong>简单总结：</strong>通过父元素掉调用需要布局的 children 的 layout 方法，如何明确元素需要布局，则需要使用到 Dirty bit 系统</p><h4 id="1-4-1-Dirty-bit系统"><a href="#1-4-1-Dirty-bit系统" class="headerlink" title="1.4.1 Dirty bit系统"></a>1.4.1 Dirty bit系统</h4><p>为了不因为每个小变化都<strong>全部重新布局</strong>，浏览器使用一个 dirty bit 系统，一个渲染对象发生了<strong>变化</strong>或是被<strong>添加</strong>了，就标记<strong>它及它的children</strong>为dirty——需要layout。</p><p>dirty bit 设置元素存在两个标识——dirty及children are dirty，children are dirty标识说明即使这个渲染对象本身的属性没变化，它也至少有一个child需要layout。</p><h4 id="1-4-2-全局和增量layout"><a href="#1-4-2-全局和增量layout" class="headerlink" title="1.4.2 全局和增量layout"></a>1.4.2 全局和增量layout</h4><p>当layout在整棵渲染树触发时，称为全局layout，这可能在下面这些情况下发生：</p><ol><li>一个全局的样式改变影响所有的渲染对象，比如字号的改变。</li><li>窗口resize。</li></ol><p>layout也可以是增量的，这样只有标志为dirty的渲染对象会重新布局（也将导致一些额外的布局）。增量layout会在渲染对象dirty时<strong>异步触发</strong>，例如，当网络接收到新的内容并添加到DOM树后，新的渲染对象会添加到渲染树中，即在初次渲染时，是一个增量layout的过程。</p><p><img src="/assets/image-20220905210504-r5cgwfg.png" alt="image.png" title="增量layout过程"></p><p><strong>异步和同步layout</strong></p><p><strong>增量layout的过程是异步的</strong>，Firefox为增量 layout 生成了 reflow 队列，以及一个调度执行这些批处理命令。WebKit也有一个计时器用来执行增量layout－遍历树，为dirty状态的渲染对象重新布局。另外，当脚本请求样式信息时，例如“offsetHeight”，会同步的触发增量布局。</p><p>全局的layout一般都是同步触发。有些时候，layout会被作为一个初始layout之后的回调，比如滑动条的滑动。</p><p><strong>优化</strong></p><p>当一个layout因为resize或是渲染位置改变（并不是大小改变）而触发时，渲染对象的大小将会从缓存中读取，而不会重新计算。</p><p>一般情况下，如果只有子树发生改变，则layout并不从根开始。这种情况发生在，变化发生在元素自身并且不影响它周围元素，例如，将文本插入文本域（否则，每次击键都将触发从根开始的重排）。</p><h4 id="1-4-3-layout过程"><a href="#1-4-3-layout过程" class="headerlink" title="1.4.3 layout过程"></a>1.4.3 layout过程</h4><p>layout一般有下面这几个部分：</p><ol><li><p>parent渲染对象决定它的宽度</p></li><li><p>parent渲染对象读取chilidren，并：</p><ul><li>放置child渲染对象（设置它的x和y）</li><li>在需要时（它们当前为dirty或是处于全局layout或者其他原因）调用child渲染对象的layout，这将计算child的高度</li><li>parent渲染对象使用child渲染对象的累积高度，以及margin和padding的高度来设置自己的高度－这将被parent渲染对象的parent使用</li><li>将dirty标识设置为false</li></ul></li></ol><p>Firefox使用一个“state”对象（nsHTMLReflowState）做为参数去布局（firefox称为reflow），state包含parent的宽度及其他内容。</p><p>Firefox布局的输出是一个“metrics”对象（nsHTMLReflowMetrics）。它包括渲染对象计算出的高度。</p><p><strong>宽度计算</strong></p><p>渲染对象的宽度使用容器的宽度、渲染对象样式中的宽度及margin、border进行计算。例如，下面这个div的宽度：</p><p>　　<kbd><div /></kbd></p><p>webkit中宽度的计算过程是（RenderBox类的 <strong>calcWidth</strong> 方法）：</p><ul><li>容器的宽度是容器的<strong>可用宽度和0</strong>中的最大值，这里的可用宽度为：contentWidth&#x3D;clientWidth()-paddingLeft()-paddingRight()，clientWidth和clientHeight代表一个对象内部的不包括border和滑动条的大小</li><li>元素的宽度指样式属性width的值，它可以通过计算容器的百分比得到一个绝对值</li><li>加上水平方向上的border和padding</li></ul><p>到这里是最佳宽度的计算过程，现在计算宽度的最大值和最小值，如果最佳宽度大于最大宽度则使用最大宽度，如果小于最小宽度则使用最小宽度。最后缓存这个值，当需要layout但宽度未改变时使用。</p><p><strong>Line breaking</strong></p><p>当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的parent它需要折行，parent将创建额外的渲染对象并调用它们的layout。</p><h3 id="1-5-绘制（Painting）"><a href="#1-5-绘制（Painting）" class="headerlink" title="1.5 绘制（Painting）"></a>1.5 绘制（Painting）</h3><p>　　绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件，这在UI的章节有更多的介绍。</p><h4 id="1-5-1-全局和增量"><a href="#1-5-1-全局和增量" class="headerlink" title="1.5.1 全局和增量"></a>1.5.1 全局和增量</h4><p>和布局一样，绘制也可以是<strong>全局的</strong>——绘制完整的树，或<strong>增量的</strong>。在增量的绘制过程中，一些渲染对象以不影响整棵树的方式改变，改变的渲染对象使其在屏幕上的矩形区域失效，这将导致操作系统将其看作dirty区域，并产生一个paint事件，操作系统很巧妙的处理这个过程，并将<strong>多个区域合并为一个</strong>，提高性能。Chrome中，这个过程更复杂些，因为渲染对象在不同的进程中，而不是在主进程中。Chrome在一定程度上模拟操作系统的行为，表现为监听事件并派发消息给渲染根，在树中查找到相关的渲染对象，重绘这个对象（往往还包括它的children）。</p><h4 id="1-5-2-绘制顺序"><a href="#1-5-2-绘制顺序" class="headerlink" title="1.5.2 绘制顺序"></a>1.5.2 绘制顺序</h4><p>css2定义了绘制过程的顺序——<a href="http://www.w3.org/TR/CSS21/zindex.html">http://www.w3.org/TR/CSS21/zindex.html</a>。这个就是元素压入堆栈的顺序，这个顺序影响着绘制，<strong>堆栈从后向前进行绘制</strong>。</p><p>一个块渲染对象的堆栈顺序是：</p><ol><li>背景色</li><li>背景图</li><li>border</li><li>children</li><li>outline</li></ol><h4 id="1-5-3-Firefox显示列表"><a href="#1-5-3-Firefox显示列表" class="headerlink" title="1.5.3 Firefox显示列表"></a>1.5.3 Firefox显示列表</h4><p>Firefox读取渲染树并为绘制的矩形创建一个<strong>显示列表</strong>，该列表以<strong>正确的绘制顺序</strong>包含这个矩形<strong>相关的渲染对象</strong>（背景、图片、样式属性等以正确的顺序排序）。用这样的方法，可以使重绘时只需查找一次树，而不需要多次查找——绘制所有的背景、所有的图片、所有的border等等。</p><p>Firefox优化了这个过程，它不添加会被隐藏的元素，比如元素完全在其他不透明元素下面。</p><h4 id="1-5-4-WebKit矩形存储"><a href="#1-5-4-WebKit矩形存储" class="headerlink" title="1.5.4 WebKit矩形存储"></a>1.5.4 WebKit矩形存储</h4><p>重绘前，WebKit将旧的矩形保存为位图，然后<strong>只绘制新旧矩形的差集</strong>。</p><h4 id="1-5-5-动态变化"><a href="#1-5-5-动态变化" class="headerlink" title="1.5.5 动态变化"></a>1.5.5 动态变化</h4><p>浏览器总是试着以<strong>最小的动作响应一个变化</strong>，所以一个元素颜色的变化将只导致该元素的重绘，元素位置的变化将大致元素的布局和重绘，添加一个Dom节点，也会导致这个元素的布局和重绘。一些主要的变化，比如增加html元素的字号，将会导致<strong>缓存失效</strong>，从而引起整体的布局和重绘。</p><h3 id="1-6-渲染引擎的线程"><a href="#1-6-渲染引擎的线程" class="headerlink" title="1.6 渲染引擎的线程"></a>1.6 渲染引擎的线程</h3><p>渲染引擎是<strong>单线程</strong>的，除了网络操作以外，几乎所有的事情都在单一的线程中处理，在Firefox和Safari中，这是浏览器的<strong>主线程</strong>，Chrome中这是tab的主线程（Chrome一个Tab一个进程，一个进程中含有一个主线程，负责大部分的代码执行）。</p><p>网络操作由几个并行线程执行，并行连接的个数是受限的（通常是2－6个）。</p><h3 id="1-7-事件循环"><a href="#1-7-事件循环" class="headerlink" title="1.7 事件循环"></a>1.7 事件循环</h3><p>浏览器主线程是一个事件循环，它被设计为无限循环以保持执行过程的可用，等待事件（例如layout和paint事件）并执行它们，注意并不是无限制的轮询，而是一个带有阻塞的轮询。下面是Firefox的主要事件循环代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mExiting)</span><br><span class="line">    <span class="built_in">NS_ProcessNextEvent</span>(thread);</span><br></pre></td></tr></table></figure><h3 id="1-8-CSS2可视模型（CSS2-visual-module）"><a href="#1-8-CSS2可视模型（CSS2-visual-module）" class="headerlink" title="1.8 CSS2可视模型（CSS2 visual module）"></a>1.8 CSS2可视模型（CSS2 visual module）</h3><h4 id="1-8-1-画布The-Canvas"><a href="#1-8-1-画布The-Canvas" class="headerlink" title="1.8.1 画布The Canvas"></a>1.8.1 画布The Canvas</h4><p>根据CSS2规范，术语canvas用来描述<strong>格式化的结构所渲染的空间</strong>——浏览器绘制内容的地方。画布对每个维度空间都是无限大的，但浏览器基于viewport的大小选择了一个初始宽度。根据<a href="http://www.w3.org/TR/CSS2/zindex.html">http://www.w3.org/TR/CSS2/zindex.html</a>的定义，画布如果是包含在其他画布内则是透明的，否则浏览器会指定一个颜色。</p><h4 id="1-8-2-CSS盒模型"><a href="#1-8-2-CSS盒模型" class="headerlink" title="1.8.2 CSS盒模型"></a>1.8.2 CSS盒模型</h4><p>CSS盒模型描述了矩形盒，这些矩形盒是为文档树中的元素生成的，并根据可视的格式化模型进行布局。每个box包括内容区域（如图片、文本等）及可选的四周padding、border和margin区域。</p><p><img src="/assets/image-20220905213040-ukvs7qo.png" alt="image.png" title="CSS盒子模型"></p><p>每个节点生成0－n个这样的box。所有的元素都有一个display属性，用来决定它们生成box的类型，例如：</p><ul><li>block －生成块状box</li><li>inline －生成一个或多个行内box</li><li>none －不生成box</li></ul><p>默认的是inline，但浏览器样式表设置了其他默认值，例如，div元素默认为block。可以访问<a href="http://www.w3.org/TR/CSS2/sample.html">http://www.w3.org/TR/CSS2/sample.html</a>查看更多的默认样式表示例。</p><h4 id="1-8-3-定位策略Position-scheme"><a href="#1-8-3-定位策略Position-scheme" class="headerlink" title="1.8.3 定位策略Position scheme"></a>1.8.3 定位策略Position scheme</h4><p>这里有三种策略：</p><ol><li>normal －对象根据它在文档的中位置定位，这意味着它在渲染树和在Dom树中位置一致，并根据它的盒模型和大小进行布局。</li><li>float －对象先像普通流一样布局，然后尽可能的向左或是向右移动。</li><li>absolute －对象在渲染树中的位置和Dom树中<strong>位置无关</strong>。</li></ol><p><strong>static 和 relative 是normal， float属于float，absolute和fixed属于absolute。</strong></p><p>在static定位中，不定义位置而使用默认的位置。其他策略中，作者指定位置——top、bottom、left、right。</p><h4 id="1-8-4-Box布局"><a href="#1-8-4-Box布局" class="headerlink" title="1.8.4 Box布局"></a>1.8.4 Box布局</h4><p>Box布局的方式由这几项决定：box的类型、box的大小、定位策略及扩展信息（比如图片大小和屏幕尺寸）。</p><p><strong>Box类型</strong></p><ul><li>Block box：构成一个块，即在浏览器窗口上有自己的矩形</li><li>Inline box：并没有自己的块状区域，但包含在一个块状区域内</li></ul><p>区分</p><ul><li>block一个挨着一个垂直格式化，inline则在水平方向上格式化。</li></ul><p><img src="/assets/image-20220905214925-cfzraou.png" alt="image.png"></p><ul><li>Inline盒模型放置在行内或是line box中，每行至少和最高的box一样高，当box以baseline对齐时——即一个元素的底部和另一个box上除底部以外的某点对齐，行高可以比最高的box高。当容器宽度不够时，行内元素将被放到多行中，这在一个p元素中经常发生。</li></ul><p><img src="/assets/image-20220905215128-dc6mo20.png" alt="image.png"></p><h4 id="1-8-5-定位Position"><a href="#1-8-5-定位Position" class="headerlink" title="1.8.5 定位Position"></a>1.8.5 定位Position</h4><p><strong>Relative</strong></p><p>相对定位——先按照一般的定位，然后按所要求的差值移动。</p><p><img src="/assets/image-20220905215245-d8kp87q.png" alt="image.png"></p><p><strong>Floats</strong></p><p>一个浮动的box移动到一行的最左边或是最右边，其余的box围绕在它周围。下面这段html：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;img src=<span class="string">&quot;images/image.gif&quot;</span> width=<span class="string">&quot;100&quot;</span> height=<span class="string">&quot;100&quot;</span>&gt;Lorem ipsum dolor sit amet, consectetuer...</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215332-ibisnl2.png" alt="image.png"></p><p><strong>Absolute和Fixed</strong></p><p>这种情况下的布局完全<strong>不顾普通的文档流</strong>，<strong>元素不属于文档流的一部分</strong>，大小取决于容器。Fixed时，容器为viewport（可视区域）。</p><p><img src="/assets/image-20220905215416-ftp14sx.png" alt="image.png"></p><p><strong>Layered representation</strong></p><p>这个由CSS属性中的<strong>z-index</strong>指定，表示盒模型的第三个大小，即在<strong>z轴上的位置</strong>。Box分发到堆栈中（称为堆栈上下文），每个堆栈中<strong>靠后的元素将被较早绘制</strong>，栈顶靠前的元素离用户最近，当发生交叠时，将隐藏靠后的元素。<strong>堆栈根据z-index属性排序</strong>，拥有z-index属性的box形成了一个局部堆栈，viewport有外部堆栈</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">STYLE</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215620-7cst2bt.png" alt="image.png"></p><p>虽然绿色div排在红色div后面，可能在正常流中也已经被绘制在后面，但z-index有更高优先级，所以在根box的堆栈中更靠前。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三. 浏览器内部工作原理-解析方向（二）、</title>
      <link href="/2023/08/05/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/08/05/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="三-浏览器内部工作原理-解析方向（二）"><a href="#三-浏览器内部工作原理-解析方向（二）" class="headerlink" title="三. 浏览器内部工作原理-解析方向（二）"></a>三. 浏览器内部工作原理-解析方向（二）</h1><h2 id="树的构建流程"><a href="#树的构建流程" class="headerlink" title="树的构建流程"></a>树的构建流程</h2><h3 id="1-3-Render-Tree"><a href="#1-3-Render-Tree" class="headerlink" title="1.3 Render Tree"></a>1.3 Render Tree</h3><h4 id="1-3-1-渲染树的定义"><a href="#1-3-1-渲染树的定义" class="headerlink" title="1.3.1 渲染树的定义"></a>1.3.1 渲染树的定义</h4><p>当Dom树构建完成时，浏览器开始构建另一棵树——渲染树。渲染树由元素显示序列中的可见元素组成，它是文档的可视化表示，构建这棵树是为了以正确的顺序绘制文档内容。</p><p>Firefox将渲染树中的元素称为frames，WebKit则用renderer或渲染对象来描述这些元素.一个渲染对象知道怎么布局及绘制自己及它的 children？</p><p>RenderObject是Webkit的渲染对象基类，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RenderObject</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">layout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(PaintInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> rect <span class="title">repaintRect</span><span class="params">()</span></span>;</span><br><span class="line">    Node* node;<span class="comment">//the DOM node</span></span><br><span class="line">    RenderStyle* style;<span class="comment">// the computed style</span></span><br><span class="line">    RenderLayer* containgLayer; <span class="comment">//the containing z-index layer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个渲染节点对象用一个和该节点 CSS 盒模型相对应的矩形区域来表示，正如 CSS2 所描述的那样，它包含诸如宽、高和位置之类的几何信息。盒模型的类型受该节点相关的 display 样式属性的影响（参考样式计算章节）。下面的 WebKit 代码说明了如何根据 display 属性决定某个节点创建何种类型的渲染对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RenderObject* <span class="title">RenderObject::createObject</span><span class="params">(Node* node, RenderStyle* style)</span> </span>&#123;</span><br><span class="line">    Document* doc = node-&gt;<span class="built_in">document</span>();</span><br><span class="line">    RenderArena* arena = doc-&gt;<span class="built_in">renderArena</span>();</span><br><span class="line">    ...</span><br><span class="line">    RenderObject* o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (style-&gt;<span class="built_in">display</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> NONE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderInline</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE_BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LIST_ITEM:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderListItem</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的类型也需要考虑，例如，表单控件和表格带有特殊的框架。</p><p>在Webkit中，如果一个元素想创建一个特殊的渲染对象，它需要重写“createRenderer”方法，使渲染对象指向不包含几何信息的样式对象。</p><p><strong>简单总结：</strong>渲染树是可视节点的集合，即在页面真实渲染的元素集合，底层使用c++进行渲染，通过c++定义不同的对象实现不同类型节点的渲染</p><h4 id="1-3-2-渲染树和DOM树的关系"><a href="#1-3-2-渲染树和DOM树的关系" class="headerlink" title="1.3.2 渲染树和DOM树的关系"></a>1.3.2 渲染树和DOM树的关系</h4><p>渲染对象和Dom元素相对应，但这种对应关系不是一对一的，不可见的Dom元素不会被插入渲染树，如head元素，display属性为none的元素（渲染树中存在 visibility 属性为 hidden 或着 opacity 属性为0的元素）。</p><p>还有一些Dom元素对应几个可见对象，它们一般是具有<strong>复杂结构</strong>的元素，无法用一个矩形来描述。例如，select元素有三个渲染对象——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而<strong>换行</strong>时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的 HTML结构，根据 CSS 规范，<strong>一个行内元素只能仅包含行内元素或仅包含块状元素，存在混合内容时，将会创建匿名的块状渲染对象包裹行内元素</strong>。</p><p><img src="/assets/image-20220905163521-nfbbt1n.png" alt="image.png"></p><h4 id="1-3-3-创建树的流程（The-flow-of-constructing-the-tree）"><a href="#1-3-3-创建树的流程（The-flow-of-constructing-the-tree）" class="headerlink" title="1.3.3 创建树的流程（The flow of constructing the tree）"></a>1.3.3 创建树的流程（The flow of constructing the tree）</h4><p>Firefox中，表述为一个监听Dom更新的监听器，将frame的创建委派给Frame Constructor，这个构建器计算样式（参看样式计算）并创建一个frame。</p><p>Webkit中，计算样式并生成渲染对象的过程称为 attachment，每个Dom节点有一个attach方法，attachment的过程是<strong>同步</strong>的，调用新节点的 attach 方法将节点插入到Dom树中。处理 html 和 body 标签将构建渲染树的根，这个<strong>根渲染对象</strong>对应被 css 规范称为 containing block 的元素——<strong>包含</strong>了其他所有块元素的顶级块元素。它的大小就是 <strong>viewport</strong>——浏览器窗口的显示区域，Firefox称它为 viewPortFrame，webkit称为 RenderView，这个就是文档 document 所指向的渲染对象，树中其他的部分都将作为一个插入的Dom节点被创建。</p><p><strong>简单总结：</strong>不同的内核对于合并的过程有不同的称呼，WebKit中使用attachment，构建渲染树会扫描DOM树和CSSOM树，扫描DOM树发现HTML、BODY元素时，就会创建一个根渲染对象，称为<strong>containing block</strong>，大小就是viewport。</p><h4 id="1-3-4-样式计算（Style-Computation）"><a href="#1-3-4-样式计算（Style-Computation）" class="headerlink" title="1.3.4 样式计算（Style Computation）"></a>1.3.4 样式计算（Style Computation）</h4><p>创建渲染树需要计算出每个渲染对象的可视属性，这可以通过计算每个元素的样式属性得到。</p><p>样式包括各种来源的<strong>样式表</strong>，<strong>行内样式元素</strong>及html中的<strong>可视化属性</strong>（例如bgcolor），可视化属性转化为css样式属性。</p><p>样式表的来源包括浏览器默认样式表、页面作者以及用户提供的样式表（有些样式是浏览器用户提供的（浏览器允许用户定义喜欢的样式，例如，在Firefox中可以通过在Firefox Profile目录下放置样式表实现））。</p><p>计算样式的一些困难：</p><ol><li>样式数据是非常大的结构，保存大量的样式属性会带来内存问题。</li><li>如果不进行优化，找到每个元素匹配的规则会导致性能问题，为每个元素查找匹配的规则都需要遍历整个规则表，这个过程有很大的工作量。选择符可能有复杂的结构，匹配过程如果沿着一条开始看似正确，后来却被证明是无用的路径，则必须去尝试另一条路径。例如，复杂选择符 <code>div div div div｛…｝</code> 这意味着规则应用到三个div的后代div元素，选择树某一条特定的路径去检查，这可能需要遍历节点树，最后却发现它只是两个div的后代，并不使用该规则，然后则需要沿着另一条路径去尝试</li><li>应用规则涉及非常复杂的级联，它们定义了规则的层次</li></ol><p><strong>浏览器如何处理这些问题？</strong></p><p>共享样式数据（Sharing style data）</p><p>WebKit节点引用样式对象（渲染样式），某些情况下，这些对象可以被节点间共享，这些节点需要是兄弟或是表兄弟节点，并且：</p><ol><li>这些元素必须处于相同的鼠标状态（比如不能一个处于hover，而另一个不是）</li><li>不能有元素具有id</li><li>标签名必须匹配</li><li>class属性必须匹配</li><li>对应的属性必须相同</li><li>链接状态必须匹配</li><li>焦点状态必须匹配</li><li>不能有元素被属性选择器影响</li><li>元素不能有行内样式属性</li><li>不能有生效的兄弟选择器，webcore在任何兄弟选择器相遇时只是简单的抛出一个全局转换，并且在它们显示时使整个文档的样式共享失效，这些包括＋选择器和类似:first-child和:last-child这样的选择器。</li></ol><p>Firefox规则树（Firefox rule tree）</p><p>Firefox用两个树用来简化样式计算－规则树和样式上下文树，WebKit也有样式对象，但它们并没有存储在类似样式上下文树这样的树中，只是由Dom节点指向其相关的样式。</p><p><img src="/assets/image-20220905204116-occzqvw.png" alt="image.png" title="Firefox样式上下文树"></p><p>具体细节可以阅读原文：<a href="https://kb.cnblogs.com/page/129756/#chapter4">浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>Webkit中，并没有规则树，匹配的声明会被遍历四次，先是应用非important的高优先级属性（之所以先应用这些属性，是因为其他的依赖于它们－比如display），其次是高优先级important的，接着是一般优先级非important的，最后是一般优先级important的规则。这样，出现多次的属性将被按照正确的级联顺序进行处理，最后一个生效。</p><h3 id="1-4-Layout"><a href="#1-4-Layout" class="headerlink" title="1.4 Layout"></a>1.4 Layout</h3><p>当渲染对象被创建并添加到树中，它们仅具有对应的布局规则，并没有实际的位置和大小，计算这些值的过程称为 layout 或 reflow。</p><p>Html使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中<strong>从右向左</strong>、<strong>自上而下</strong>的进行。也存在一些例外，比如 html tables。</p><p>坐标系统相对于根frame，使用 top 和 left 坐标。布局是一个<strong>递归</strong>的过程，由根渲染对象开始，它对应 html 文档document元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。根渲染对象的位置是 0,0，它的大小是viewport－浏览器窗口的可见部分。所有的渲染对象都有一个 layout 或 reflow 方法，每个渲染对象调用<strong>需要布局</strong>的 children 的 layout 方法。</p><p><strong>简单总结：</strong>通过父元素掉调用需要布局的 children 的 layout 方法，如何明确元素需要布局，则需要使用到 Dirty bit 系统</p><h4 id="1-4-1-Dirty-bit系统"><a href="#1-4-1-Dirty-bit系统" class="headerlink" title="1.4.1 Dirty bit系统"></a>1.4.1 Dirty bit系统</h4><p>为了不因为每个小变化都<strong>全部重新布局</strong>，浏览器使用一个 dirty bit 系统，一个渲染对象发生了<strong>变化</strong>或是被<strong>添加</strong>了，就标记<strong>它及它的children</strong>为dirty——需要layout。</p><p>dirty bit 设置元素存在两个标识——dirty及children are dirty，children are dirty标识说明即使这个渲染对象本身的属性没变化，它也至少有一个child需要layout。</p><h4 id="1-4-2-全局和增量layout"><a href="#1-4-2-全局和增量layout" class="headerlink" title="1.4.2 全局和增量layout"></a>1.4.2 全局和增量layout</h4><p>当layout在整棵渲染树触发时，称为全局layout，这可能在下面这些情况下发生：</p><ol><li>一个全局的样式改变影响所有的渲染对象，比如字号的改变。</li><li>窗口resize。</li></ol><p>layout也可以是增量的，这样只有标志为dirty的渲染对象会重新布局（也将导致一些额外的布局）。增量layout会在渲染对象dirty时<strong>异步触发</strong>，例如，当网络接收到新的内容并添加到DOM树后，新的渲染对象会添加到渲染树中，即在初次渲染时，是一个增量layout的过程。</p><p><img src="/assets/image-20220905210504-r5cgwfg.png" alt="image.png" title="增量layout过程"></p><p><strong>异步和同步layout</strong></p><p><strong>增量layout的过程是异步的</strong>，Firefox为增量 layout 生成了 reflow 队列，以及一个调度执行这些批处理命令。WebKit也有一个计时器用来执行增量layout－遍历树，为dirty状态的渲染对象重新布局。另外，当脚本请求样式信息时，例如“offsetHeight”，会同步的触发增量布局。</p><p>全局的layout一般都是同步触发。有些时候，layout会被作为一个初始layout之后的回调，比如滑动条的滑动。</p><p><strong>优化</strong></p><p>当一个layout因为resize或是渲染位置改变（并不是大小改变）而触发时，渲染对象的大小将会从缓存中读取，而不会重新计算。</p><p>一般情况下，如果只有子树发生改变，则layout并不从根开始。这种情况发生在，变化发生在元素自身并且不影响它周围元素，例如，将文本插入文本域（否则，每次击键都将触发从根开始的重排）。</p><h4 id="1-4-3-layout过程"><a href="#1-4-3-layout过程" class="headerlink" title="1.4.3 layout过程"></a>1.4.3 layout过程</h4><p>layout一般有下面这几个部分：</p><ol><li><p>parent渲染对象决定它的宽度</p></li><li><p>parent渲染对象读取chilidren，并：</p><ul><li>放置child渲染对象（设置它的x和y）</li><li>在需要时（它们当前为dirty或是处于全局layout或者其他原因）调用child渲染对象的layout，这将计算child的高度</li><li>parent渲染对象使用child渲染对象的累积高度，以及margin和padding的高度来设置自己的高度－这将被parent渲染对象的parent使用</li><li>将dirty标识设置为false</li></ul></li></ol><p>Firefox使用一个“state”对象（nsHTMLReflowState）做为参数去布局（firefox称为reflow），state包含parent的宽度及其他内容。</p><p>Firefox布局的输出是一个“metrics”对象（nsHTMLReflowMetrics）。它包括渲染对象计算出的高度。</p><p><strong>宽度计算</strong></p><p>渲染对象的宽度使用容器的宽度、渲染对象样式中的宽度及margin、border进行计算。例如，下面这个div的宽度：</p><p>　　<kbd><div /></kbd></p><p>webkit中宽度的计算过程是（RenderBox类的 <strong>calcWidth</strong> 方法）：</p><ul><li>容器的宽度是容器的<strong>可用宽度和0</strong>中的最大值，这里的可用宽度为：contentWidth&#x3D;clientWidth()-paddingLeft()-paddingRight()，clientWidth和clientHeight代表一个对象内部的不包括border和滑动条的大小</li><li>元素的宽度指样式属性width的值，它可以通过计算容器的百分比得到一个绝对值</li><li>加上水平方向上的border和padding</li></ul><p>到这里是最佳宽度的计算过程，现在计算宽度的最大值和最小值，如果最佳宽度大于最大宽度则使用最大宽度，如果小于最小宽度则使用最小宽度。最后缓存这个值，当需要layout但宽度未改变时使用。</p><p><strong>Line breaking</strong></p><p>当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的parent它需要折行，parent将创建额外的渲染对象并调用它们的layout。</p><h3 id="1-5-绘制（Painting）"><a href="#1-5-绘制（Painting）" class="headerlink" title="1.5 绘制（Painting）"></a>1.5 绘制（Painting）</h3><p>　　绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件，这在UI的章节有更多的介绍。</p><h4 id="1-5-1-全局和增量"><a href="#1-5-1-全局和增量" class="headerlink" title="1.5.1 全局和增量"></a>1.5.1 全局和增量</h4><p>和布局一样，绘制也可以是<strong>全局的</strong>——绘制完整的树，或<strong>增量的</strong>。在增量的绘制过程中，一些渲染对象以不影响整棵树的方式改变，改变的渲染对象使其在屏幕上的矩形区域失效，这将导致操作系统将其看作dirty区域，并产生一个paint事件，操作系统很巧妙的处理这个过程，并将<strong>多个区域合并为一个</strong>，提高性能。Chrome中，这个过程更复杂些，因为渲染对象在不同的进程中，而不是在主进程中。Chrome在一定程度上模拟操作系统的行为，表现为监听事件并派发消息给渲染根，在树中查找到相关的渲染对象，重绘这个对象（往往还包括它的children）。</p><h4 id="1-5-2-绘制顺序"><a href="#1-5-2-绘制顺序" class="headerlink" title="1.5.2 绘制顺序"></a>1.5.2 绘制顺序</h4><p>css2定义了绘制过程的顺序——<a href="http://www.w3.org/TR/CSS21/zindex.html">http://www.w3.org/TR/CSS21/zindex.html</a>。这个就是元素压入堆栈的顺序，这个顺序影响着绘制，<strong>堆栈从后向前进行绘制</strong>。</p><p>一个块渲染对象的堆栈顺序是：</p><ol><li>背景色</li><li>背景图</li><li>border</li><li>children</li><li>outline</li></ol><h4 id="1-5-3-Firefox显示列表"><a href="#1-5-3-Firefox显示列表" class="headerlink" title="1.5.3 Firefox显示列表"></a>1.5.3 Firefox显示列表</h4><p>Firefox读取渲染树并为绘制的矩形创建一个<strong>显示列表</strong>，该列表以<strong>正确的绘制顺序</strong>包含这个矩形<strong>相关的渲染对象</strong>（背景、图片、样式属性等以正确的顺序排序）。用这样的方法，可以使重绘时只需查找一次树，而不需要多次查找——绘制所有的背景、所有的图片、所有的border等等。</p><p>Firefox优化了这个过程，它不添加会被隐藏的元素，比如元素完全在其他不透明元素下面。</p><h4 id="1-5-4-WebKit矩形存储"><a href="#1-5-4-WebKit矩形存储" class="headerlink" title="1.5.4 WebKit矩形存储"></a>1.5.4 WebKit矩形存储</h4><p>重绘前，WebKit将旧的矩形保存为位图，然后<strong>只绘制新旧矩形的差集</strong>。</p><h4 id="1-5-5-动态变化"><a href="#1-5-5-动态变化" class="headerlink" title="1.5.5 动态变化"></a>1.5.5 动态变化</h4><p>浏览器总是试着以<strong>最小的动作响应一个变化</strong>，所以一个元素颜色的变化将只导致该元素的重绘，元素位置的变化将大致元素的布局和重绘，添加一个Dom节点，也会导致这个元素的布局和重绘。一些主要的变化，比如增加html元素的字号，将会导致<strong>缓存失效</strong>，从而引起整体的布局和重绘。</p><h3 id="1-6-渲染引擎的线程"><a href="#1-6-渲染引擎的线程" class="headerlink" title="1.6 渲染引擎的线程"></a>1.6 渲染引擎的线程</h3><p>渲染引擎是<strong>单线程</strong>的，除了网络操作以外，几乎所有的事情都在单一的线程中处理，在Firefox和Safari中，这是浏览器的<strong>主线程</strong>，Chrome中这是tab的主线程（Chrome一个Tab一个进程，一个进程中含有一个主线程，负责大部分的代码执行）。</p><p>网络操作由几个并行线程执行，并行连接的个数是受限的（通常是2－6个）。</p><h3 id="1-7-事件循环"><a href="#1-7-事件循环" class="headerlink" title="1.7 事件循环"></a>1.7 事件循环</h3><p>浏览器主线程是一个事件循环，它被设计为无限循环以保持执行过程的可用，等待事件（例如layout和paint事件）并执行它们，注意并不是无限制的轮询，而是一个带有阻塞的轮询。下面是Firefox的主要事件循环代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mExiting)</span><br><span class="line">    <span class="built_in">NS_ProcessNextEvent</span>(thread);</span><br></pre></td></tr></table></figure><h3 id="1-8-CSS2可视模型（CSS2-visual-module）"><a href="#1-8-CSS2可视模型（CSS2-visual-module）" class="headerlink" title="1.8 CSS2可视模型（CSS2 visual module）"></a>1.8 CSS2可视模型（CSS2 visual module）</h3><h4 id="1-8-1-画布The-Canvas"><a href="#1-8-1-画布The-Canvas" class="headerlink" title="1.8.1 画布The Canvas"></a>1.8.1 画布The Canvas</h4><p>根据CSS2规范，术语canvas用来描述<strong>格式化的结构所渲染的空间</strong>——浏览器绘制内容的地方。画布对每个维度空间都是无限大的，但浏览器基于viewport的大小选择了一个初始宽度。根据<a href="http://www.w3.org/TR/CSS2/zindex.html">http://www.w3.org/TR/CSS2/zindex.html</a>的定义，画布如果是包含在其他画布内则是透明的，否则浏览器会指定一个颜色。</p><h4 id="1-8-2-CSS盒模型"><a href="#1-8-2-CSS盒模型" class="headerlink" title="1.8.2 CSS盒模型"></a>1.8.2 CSS盒模型</h4><p>CSS盒模型描述了矩形盒，这些矩形盒是为文档树中的元素生成的，并根据可视的格式化模型进行布局。每个box包括内容区域（如图片、文本等）及可选的四周padding、border和margin区域。</p><p><img src="/assets/image-20220905213040-ukvs7qo.png" alt="image.png" title="CSS盒子模型"></p><p>每个节点生成0－n个这样的box。所有的元素都有一个display属性，用来决定它们生成box的类型，例如：</p><ul><li>block －生成块状box</li><li>inline －生成一个或多个行内box</li><li>none －不生成box</li></ul><p>默认的是inline，但浏览器样式表设置了其他默认值，例如，div元素默认为block。可以访问<a href="http://www.w3.org/TR/CSS2/sample.html">http://www.w3.org/TR/CSS2/sample.html</a>查看更多的默认样式表示例。</p><h4 id="1-8-3-定位策略Position-scheme"><a href="#1-8-3-定位策略Position-scheme" class="headerlink" title="1.8.3 定位策略Position scheme"></a>1.8.3 定位策略Position scheme</h4><p>这里有三种策略：</p><ol><li>normal －对象根据它在文档的中位置定位，这意味着它在渲染树和在Dom树中位置一致，并根据它的盒模型和大小进行布局。</li><li>float －对象先像普通流一样布局，然后尽可能的向左或是向右移动。</li><li>absolute －对象在渲染树中的位置和Dom树中<strong>位置无关</strong>。</li></ol><p><strong>static 和 relative 是normal， float属于float，absolute和fixed属于absolute。</strong></p><p>在static定位中，不定义位置而使用默认的位置。其他策略中，作者指定位置——top、bottom、left、right。</p><h4 id="1-8-4-Box布局"><a href="#1-8-4-Box布局" class="headerlink" title="1.8.4 Box布局"></a>1.8.4 Box布局</h4><p>Box布局的方式由这几项决定：box的类型、box的大小、定位策略及扩展信息（比如图片大小和屏幕尺寸）。</p><p><strong>Box类型</strong></p><ul><li>Block box：构成一个块，即在浏览器窗口上有自己的矩形</li><li>Inline box：并没有自己的块状区域，但包含在一个块状区域内</li></ul><p>区分</p><ul><li>block一个挨着一个垂直格式化，inline则在水平方向上格式化。</li></ul><p><img src="/assets/image-20220905214925-cfzraou.png" alt="image.png"></p><ul><li>Inline盒模型放置在行内或是line box中，每行至少和最高的box一样高，当box以baseline对齐时——即一个元素的底部和另一个box上除底部以外的某点对齐，行高可以比最高的box高。当容器宽度不够时，行内元素将被放到多行中，这在一个p元素中经常发生。</li></ul><p><img src="/assets/image-20220905215128-dc6mo20.png" alt="image.png"></p><h4 id="1-8-5-定位Position"><a href="#1-8-5-定位Position" class="headerlink" title="1.8.5 定位Position"></a>1.8.5 定位Position</h4><p><strong>Relative</strong></p><p>相对定位——先按照一般的定位，然后按所要求的差值移动。</p><p><img src="/assets/image-20220905215245-d8kp87q.png" alt="image.png"></p><p><strong>Floats</strong></p><p>一个浮动的box移动到一行的最左边或是最右边，其余的box围绕在它周围。下面这段html：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;img src=<span class="string">&quot;images/image.gif&quot;</span> width=<span class="string">&quot;100&quot;</span> height=<span class="string">&quot;100&quot;</span>&gt;Lorem ipsum dolor sit amet, consectetuer...</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215332-ibisnl2.png" alt="image.png"></p><p><strong>Absolute和Fixed</strong></p><p>这种情况下的布局完全<strong>不顾普通的文档流</strong>，<strong>元素不属于文档流的一部分</strong>，大小取决于容器。Fixed时，容器为viewport（可视区域）。</p><p><img src="/assets/image-20220905215416-ftp14sx.png" alt="image.png"></p><p><strong>Layered representation</strong></p><p>这个由CSS属性中的<strong>z-index</strong>指定，表示盒模型的第三个大小，即在<strong>z轴上的位置</strong>。Box分发到堆栈中（称为堆栈上下文），每个堆栈中<strong>靠后的元素将被较早绘制</strong>，栈顶靠前的元素离用户最近，当发生交叠时，将隐藏靠后的元素。<strong>堆栈根据z-index属性排序</strong>，拥有z-index属性的box形成了一个局部堆栈，viewport有外部堆栈</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">STYLE</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215620-7cst2bt.png" alt="image.png"></p><p>虽然绿色div排在红色div后面，可能在正常流中也已经被绘制在后面，但z-index有更高优先级，所以在根box的堆栈中更靠前。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三. 浏览器内部工作原理-解析方向（一）</title>
      <link href="/2023/08/04/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/08/04/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="三-浏览器内部工作原理-解析方向（一）"><a href="#三-浏览器内部工作原理-解析方向（一）" class="headerlink" title="三. 浏览器内部工作原理-解析方向（一）"></a>三. 浏览器内部工作原理-解析方向（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为方便读者阅读，贴出以下参考链接，在此感谢前辈笔记。</p><p>浏览器解析过程分析：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>浏览器工作过程分析：<a href="https://zhuanlan.zhihu.com/p/96986818">万字详文：深入理解浏览器原理 - 知乎 (zhihu.com)</a></p><h2 id="树的构建流程"><a href="#树的构建流程" class="headerlink" title="树的构建流程"></a>树的构建流程</h2><p><img src="/assets/image-20220902091918-3jgz0jo.png" alt="image.png"></p><p>HTML 和 CSS 的页面解析是从上之下的，<strong>线程的</strong>。文档流从上往下，若先碰到了 CSS，那么开始解析，接着<strong>不被阻塞的</strong>继续向下解析 HTML，这样既符合并行解析，又符合文档流自上往下解析规则。浏览器先下载 HTML 文件开始解析，遇到 CSS 标签就开始下载 CSS 并解析，这个过程不会阻塞 DOM 的构建。最后 DOM 树和 CSS 规则树生成渲染树，HTML 解析完成。</p><p>注意几点：</p><ol><li>CSS 加载不会阻塞 DOM 树的<strong>解析</strong></li><li>CSS 加载会阻塞 DOM 树的<strong>渲染</strong>（不阻塞解析），即合并成渲染树的过程，因为样式可能会导致重排重绘</li><li>CSS 加载会阻塞后面 JS 语句的执行</li></ol><p>解析、渲染这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时还可能通过网络下载其余内容。</p><h3 id="1-1-HTML-Parser"><a href="#1-1-HTML-Parser" class="headerlink" title="1.1 HTML Parser"></a>1.1 HTML Parser</h3><h4 id="1-1-1-解析"><a href="#1-1-1-解析" class="headerlink" title="1.1.1 解析"></a>1.1.1 解析</h4><p>解析的目的是：将文档转换为具有一定意义的结构，编码时可以理解和使用的东西。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。</p><blockquote><p>解析的目的在于让目标更接近于需要使用的形式，或更具体的描述一些信息。如高级语言先转换为汇编等低级语言，最后再转换成机器码，又或者是家具的运输与组装，零件形式更接近于运输模式，成品形式更接近于使用模式，由成品拆分成零件就是使其更接近于运输模式，同样的道理将文档解析成另外一个格式会更适合某一个场景的使用。</p></blockquote><p>如解析“2＋3－1”这个表达式，可能返回这样一棵树。</p><p><img src="/assets/image-20220902121038-5xudoir.png" alt="image.png"></p><p>解析过程与翻译过程类似，需要具备两个条件，字典和语法规则。</p><p><strong>文法（Grammars）</strong>：解析基于文档依据的语法规则——文档的语言或格式。每种可被解析的格式必须具有由词汇及语法规则组成的特定的文法，称为上下文无关文法。简单来说就是由词汇表、语法规则组成的对某一个格式的限制，与当前文件内容无关。</p><blockquote><p>文法不等于语法规则，文法是词汇表和语法规则的结合，如语法规则定义为“<strong>的</strong>字后面跟着表示事物的名词，<strong>地</strong>字跟在动词后面，<strong>得</strong>字后面跟着形容词”，词汇表则有“谁，得，的，地，花，走，快”，文法规则就是词汇表和语法规则的结合，包含任何一个可能选择，如“谁的花，走得快，的，得，地”等。</p></blockquote><p>解析可以分成两个子过程：</p><ul><li>词法分析</li><li>语法分析</li></ul><p><strong>词法分析</strong>是将文档中的字词按照一定地规则（词汇表）分成符号，符号对应的便是词汇表（基本有效单元的集合）中的某一项。对于人类语言来说，它相当于我们字典中出现的所有单词。</p><p><strong>语法分析</strong>是根据语法规则匹配词法分析后的符号，生成特定状态的过程。</p><p>词法分析器（有时也叫分词器）负责将输入分解为合法的符号，语法分析器则根据语言的语法规则分析文档结构，从而构建解析树，词法分析器知道怎么跳过空白和换行之类的无关字符。</p><p><img src="/assets/image-20220902133652-u2je5s2.png" alt="image.png"></p><p>解析过程是<strong>迭代的</strong>，语法分析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后语法分析器分析下一个符号。如果没有匹配到规则，语法分析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</p><blockquote><p>词法分析器和语法分析器的工作是同步的，正如组装家具时，找到一个一个零件，根据说明书进行组装，如果没有找齐零件，是无法组装某一个个体的。</p></blockquote><h4 id="1-1-2-转换"><a href="#1-1-2-转换" class="headerlink" title="1.1.2 转换"></a>1.1.2 转换</h4><p>转换对工作人员来说是一个隐式的过程，正如在浏览器开发者控制台运行一些代码、打印日志信息一样，开发者可能感受不到转换到机器码的过程。但是编写的源代码并不是最终的目标，底层机器码才是机器识别、运行的格式。</p><p>很多时候，解析树并不是最终结果。解析一般在转换中使用——将输入文档转换为另一种格式。编译就是个例子，编译器在将一段源码编译为机器码的时候，先将源码解析为解析树，然后将该树转换为一个机器码文档。</p><p>简单来说<strong>转换</strong>过程在编译运行时就存在，将源代码转换为机器码，转换时是无感的。</p><p><img src="/assets/image-20220902140802-boi3thw.png" alt="image.png"></p><p>详细的例子可以看看：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>，如不熟悉抽象语法树的概念，可以看看：<a href="https://juejin.cn/post/6844904035271573511">手把手带你入门 AST 抽象语法树 - 掘金 (juejin.cn)</a>。</p><h4 id="1-1-3-深入"><a href="#1-1-3-深入" class="headerlink" title="1.1.3 深入"></a>1.1.3 深入</h4><p><strong>HTML解析器（HTML Parser）：</strong>HTML解析器的工作是将html标识解析为解析树。</p><p><strong>HTML文法定义（The HTML grammar definition）：</strong>W3C组织制定规范定义了HTML的词汇表和语法。</p><p><strong>非上下文无关文法（Not a context free grammar）：</strong>正如在解析简介中提到的，上下文无关文法的语法可以用类似BNF的格式来定义。</p><blockquote><p>HTML 有一个正式的格式定义—— DTD（Document Type Definition文档类型定义），但它并不是上下文无关文法，HTML 更接近于 XML，现在有很多可用的xml 解析器，html 有个 xml 的变体——xhtml，不同在于 html 更宽容，它允许忽略一些特定标签，有时可以省略开始或结束标签。总的来说，它是一种 soft 语法，不像 xml 呆板、固执。</p><p>显然，这个看起来很小的差异却带来了很大的不同。一方面，这是 html 流行的原因——它的宽容使 web 开发人员的工作更加轻松，但另一方面，这也使很难去写一个格式化的文法。所以，html 的解析并不简单，它既不能用传统的解析器解析，也不能用 xml 解析器解析。</p></blockquote><p><strong>HTML DTD</strong></p><p>html 适用 DTD 格式进行定义，这一格式是用于定义 SGML 家族的语言，包括了对所有允许元素及它们的属性和层次关系的定义。正如前面提到的，html DTD 并没有生成一种上下文无关文法。DTD 有一些变种，标准模式只遵守规范，而其他模式则包含了对浏览器过去所使用标签的支持，这么做是为了兼容以前内容。最新的标准 DTD 在<a href="http://www.w3.org/TR/html4/strict.dtd">http://www.w3.org/TR/html4/strict.dtd</a>。</p><p><strong>DOM</strong></p><p>解析输出的树也就是解析树，是由 DOM 元素及属性节点组成的。DOM 是文档对象模型的缩写，它是 html 文档的对象表示，作为 html 元素的外部接口供 JS 等调用。DOM 和标签基本是一一对应的关系。</p><p><strong>解析器类型（Types of parsers）</strong></p><p>有两种基本的解析器——自顶向下解析及自底向上解析。比较直观的解释是，自顶向下解析，查看语法的最高层结构并试着匹配其中一个；自底向上解析则从输入开始，逐步将其转换为语法规则，从底层规则开始直到匹配高层规则。</p><p>来看一下这两种解析器如何解析 “2+3-1” 的例子：<strong>自顶向下</strong>解析器从最高层规则开始——它先识别出“2+3”，将其视为一个表达式，然后识别出 “2+3-1” 为一个表达式（识别表达式的过程中匹配了其他规则，但出发点是最高层规则）。<strong>自底向上</strong>解析会扫描输入直到匹配了一条规则，然后用该规则取代匹配的输入，直到解析完所有输入。部分匹配的表达式被放置在解析堆栈中。</p><p>自顶向下与递归过程类似，从整体开始逐步检查子问题，而自底向上与递推过程类似，从子问题开始推向整体。</p><p><strong>自动化解析（Generating parsers automatically）</strong></p><p>解析器生成器这个工具可以自动生成解析器，只需要指定语言的文法——词汇表及语法规则，它就可以生成一个解析器。创建一个解析器需要对解析有深入的理解，而且手动的创建一个由较好性能的解析器并不容易，所以解析生成器很有用。Webkit使用两个知名的解析生成器——<strong>用于创建语法分析器的Flex</strong>及<strong>创建解析器的Bison</strong>（你可能接触过Lex和Yacc）。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p><p>稍微总结：HTML 解析器按照 HTML DTD 文法定义进行 HTML 解析，可以认为解析生成的 DOM 树与解析树一一映射，DOM 树就是解析树。</p><h4 id="1-1-4-解析算法"><a href="#1-1-4-解析算法" class="headerlink" title="1.1.4 解析算法"></a>1.1.4 解析算法</h4><p>HTML 不能被一般的自顶向下或自底向上的解析器所解析，不能使用正则解析技术，浏览器为 HTML 定制了专属的解析器，原因是：</p><ol><li><p>这门语言本身的宽容特性</p></li><li><p>浏览器对一些常见的非法html有容错机制</p></li><li><p>解析过程是往复的，通常源码不会在解析过程中发生改变，但在 HTML 中，脚本标签包含的 “document.write” 可能添加标签，这说明在解析过程中实际上修改了输入，所以不能使用正则解析技术</p></li></ol><p>HTML5 规范中描述了这个解析算法，算法包括两个阶段——符号化及构建树。</p><p>符号化是<strong>词法分析</strong>的过程，将输入解析为符号，HTML 的符号包括开始标签、结束标签、属性名及属性值。符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，以识别下一个符号，直到处理完所有输入。</p><p><strong>符号识别算法（The tokenization algorithm）</strong></p><p>算法输出 HTML 符号，该算法用状态机表示。每次读取输入流中的一个或多个字符，并根据这些字符转移到下一个状态，当前的符号状态及构建树状态共同影响结果，这意味着，读取同样的字符，可能因为当前状态的不同，得到不同的结果以进入下一个正确的状态。</p><p>这个算法很复杂，这里用一个简单的例子来解释这个原理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello world</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>初始状态为“Data State”，当遇到“&lt;”字符，状态变为“Tag open state”，读取一个a－z的字符将产生一个开始标签符号，状态相应变为“Tag name state”，一直保持这个状态直到读取到“&gt;”，每个字符都附加到这个符号名上，例子中创建的是一个html符号。</p><p>当读取到“&gt;”，当前的符号就完成了，此时状态回到“Data state”，“<body>”重复这一处理过程。到这里，html和body标签都识别出来了。现在，回到“Data state”，读取“Hello world”中的字符“H”将创建并识别出一个字符符号，这里会<strong>为“Hello world”中的每个字符生成一个字符符号</strong>。</p><p>这样直到遇到“</body>”中的“&lt;”。现在，又回到了“Tag open state”，读取下一个字符“&#x2F;”将创建一个闭合标签符号，并且状态转移到“Tag name state”，还是保持这一状态，直到遇到“&gt;”。然后，产生一个新的标签符号并回到“Data state”。后面的“</html>”将和“</body>”一样处理。</p><p><img src="/assets/image-20220903152441-lnzo21q.png" alt="image.png"></p><p><strong>简单总结：</strong>因为 HTML 符号包括开始标签、结束标签、属性名及属性值，所以解析每一个符号都需要三个状态来决定。状态机+符号化+树构建器。<strong>符号并不仅仅只是一个字符</strong>，可以是标签符号包括标签名、属性等，除标签符号外，为每一个内容字符创建一个字符符号（Data State）。</p><p><strong>树的构建算法（Tree construction algorithm）</strong></p><p>在树的构建阶段，将<strong>修改</strong>以Document为根的DOM树，将元素附加到树上。每个由符号识别器识别生成的节点将会被树构造器进行处理，规范中定义了每个符号相对应的Dom元素，<strong>对应的Dom元素将会被创建</strong>。这些元素除了会被添加到Dom树上，还将被添加到开放元素堆栈中。这个堆栈用来纠正嵌套的未匹配和未闭合标签，这个算法也是用状态机来描述，所有的状态采用插入模式。</p><p>首先是“initial mode”，接收到html符号后将转换为“before html”模式，在这个模式中对这个符号进行再处理。此时，创建了一个HTMLHtmlElement元素，并将其附加到根Document对象上。</p><p>状态此时变为“before head”，接收到body符号时，即使这里没有head符号，也将自动创建一个HTMLHeadElement元素并附加到树上。</p><p>现在，转到“in head”模式，然后是“after head”。到这里，body符号会被再次处理，将创建一个HTMLBodyElement并插入到树中，同时，转移到“in body”模式。</p><p>然后，接收到字符串“Hello world”的字符符号，第一个字符将导致创建并插入一个text节点，其他字符将附加到该节点。</p><p>接收到body结束符号时，转移到“after body”模式，接着接收到html结束符号，这个符号意味着转移到了“after after body”模式，当接收到文件结束符时，整个解析过程结束。</p><p><img src="/assets/image-20220903152422-pm7uawo.png" alt="image.png"></p><p><strong>简单总结：</strong>树构建器根据符号创建对应的DOM元素，附加到以Document为根的DOM树上，并对一些常见的 HTML 错误进行处理。</p><h4 id="1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）"><a href="#1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）" class="headerlink" title="1.1.5 解析结束时的处理（Action when the parsing is finished）"></a>1.1.5 解析结束时的处理（Action when the parsing is finished）</h4><p>在这个阶段，浏览器将文档标记为可交互的，并开始解析处于延时模式中的脚本——这些脚本在文档解析后执行。文档状态将被设置为完成，同时触发一个 <strong>load</strong> 事件。</p><p>HTML5 规范中有符号化及构建树的完整算法：<a href="http://www.w3.org/TR/html5/syntax.html#html-parser">链接</a>。</p><h4 id="1-1-6-浏览器容错（Browsers-error-tolerance）"><a href="#1-1-6-浏览器容错（Browsers-error-tolerance）" class="headerlink" title="1.1.6 浏览器容错（Browsers error tolerance）"></a>1.1.6 浏览器容错（Browsers error tolerance）</h4><p>详细可查看原文：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><h3 id="1-2-CSS-Parser"><a href="#1-2-CSS-Parser" class="headerlink" title="1.2 CSS Parser"></a>1.2 CSS Parser</h3><p>CSS 的加载并不会阻塞 DOM 的解析，但是会阻塞 DOM 的渲染。因为加载 CSS 时，可能会修改当前解析位置以后的 DOM 节点的样式，如果 CSS 加载不阻塞 DOM 树渲染，那么当 CSS 加载完之后，DOM 树可能又得重新重排 layout（回流reflow）或者重绘了，这就造成了一些没有必要的损耗。</p><p>不同于HTML，CSS属于上下文无关文法，可以用前面所描述的解析器来解析。CSS规范定义了CSS的词法及语法文法。可以参考词汇表和语法规则：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>。</p><p>每个符号都由正则表达式定义了词法文法（词汇表）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comment<span class="comment">///*[^*]*/*+([^/*][^*]*/*+)*//</span></span><br><span class="line">num[<span class="number">0</span>-<span class="number">9</span>]+|[<span class="number">0</span>-<span class="number">9</span>]*<span class="string">&quot;.&quot;</span>[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">nonascii[<span class="regexp">/200-/</span><span class="number">377</span>]</span><br><span class="line">nmstart[_a-z]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">nmchar[_a-z0-<span class="number">9</span>-]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">name&#123;nmchar&#125;+</span><br><span class="line">ident&#123;nmstart&#125;&#123;nmchar&#125;*</span><br></pre></td></tr></table></figure><p>“ident”是识别器的缩写，相当于一个class名，“name”是一个元素id（用“＃”引用）。</p><p>语法用BNF进行描述：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">: selector [ <span class="string">&#x27;,&#x27;</span> S* selector ]*</span><br><span class="line"><span class="string">&#x27;&#123;&#x27;</span> S* declaration [ <span class="string">&#x27;;&#x27;</span> S* declaration ]* <span class="string">&#x27;&#125;&#x27;</span> S*</span><br><span class="line">;</span><br><span class="line">selector</span><br><span class="line">: simple_selector [ combinator selector | S+ [ combinator selector ] ]</span><br><span class="line">;</span><br><span class="line"><span class="keyword">class</span></span><br><span class="line">: <span class="string">&#x27;.&#x27;</span> <span class="variable constant_">IDENT</span></span><br><span class="line">;</span><br><span class="line">element_name</span><br><span class="line">: <span class="variable constant_">IDENT</span> | <span class="string">&#x27;*&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>一个规则集合具有一个或是可选个数的多个选择器，这些选择器以逗号和空格（S表示空格）进行分隔。每个规则集合包含大括号及大括号中的一条或多条以分号隔开的声明。声明和选择器在后面进行定义。</p><h4 id="1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）"><a href="#1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）" class="headerlink" title="1.2.1 Webkit CSS解析器（Webkit CSS parser）"></a>1.2.1 Webkit CSS解析器（Webkit CSS parser）</h4><p>Webkit使用Flex和Bison解析生成器从CSS语法文件中自动生成解析器。回忆一下解析器的介绍，Bison创建一个自底向上的解析器，Firefox使用自顶向下解析器。它们都是将每个css文件解析为样式表对象，每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。</p><blockquote><p>用于创建语法分析器的Flex及创建解析器的Bison。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p></blockquote><p><img src="/assets/image-20220903160338-wjh6j4x.png" alt="image.png"></p><p>注意：WebKit使用的是自底向上的解析器</p><blockquote><p>处理脚本及样式表的顺序（The order of processing scripts and style sheets）</p><p>脚本：web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。HTML5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。</p><p>async是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行；而Defer是在JS加载完成后，整个文档解析完成后执行。 Defer更像是将&lt;script&gt;标签放在&lt;&#x2F;body&gt;之后的效果，但是它由于是异步加载JS文件，所以可以节省时间。简单来说就是async和defer都是开启新线程（http线程）请求JS文件，和解析DOM并行不冲突，async在请求完成后就开始执行JS文件，而defer则是在整个DOM解析完成后再执行JS文件。</p><p>预解析（Speculative parsing）</p><p>Webkit和Firefox都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变Dom树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p></blockquote><p>StyleSheets样式表采用另一种模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。</p><p><strong>简单总结：</strong>WebKit用Flex生成CSS语法规则，Bison生成CSS解析器。样式表不阻塞DOM解析，但是阻塞DOM渲染，FireFox在样式文件未加载完成前阻塞JS脚本，目的是防止样式文件未加载完成而JS脚本需要获取样式文件信息的错误，Chrome只阻塞那些访问未加载完成的样式文件的JS脚本，样式加载完成即不堵塞。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二. Web性能与安全</title>
      <link href="/2023/08/03/%E4%BA%8C.%20Web%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
      <url>/2023/08/03/%E4%BA%8C.%20Web%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="二-Web性能与安全"><a href="#二-Web性能与安全" class="headerlink" title="二. Web性能与安全"></a>二. Web性能与安全</h1><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web性能与安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二. Web性能与安全 - 性能方向</title>
      <link href="/2023/08/03/%E4%BA%8C.%20Web%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8%20-%20%E6%80%A7%E8%83%BD%E6%96%B9%E5%90%91/"/>
      <url>/2023/08/03/%E4%BA%8C.%20Web%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8%20-%20%E6%80%A7%E8%83%BD%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="深入理解浏览器缓存机制"><a href="#深入理解浏览器缓存机制" class="headerlink" title="深入理解浏览器缓存机制"></a>深入理解浏览器缓存机制</h2><p><img src="/assets/image-20220907085640-8nz781x.png" alt="image"></p><p>缓存是提升网页性能最好的方式之一，开发者只需要控制几个字段就可以减少大量的数据传输和低效的网络请求。</p><p>目前几乎所有的<strong>缓存控制字段</strong>是来源于后端服务器的<strong>响应</strong>，这里不包括浏览器的存储如 <code>Storage</code>，<code>IndexedDB</code>。为什么前端工程师还需要学网络http部分？</p><p>答案是前端工程师才更了解业务的具体场景是什么，如图片加载缓存优化。前端不直接控制缓存字段，而是与后端沟通定义当前<strong>场景的缓存策略</strong>，只有了解了缓存有哪些策略才能够针对某一场景的缓存进行优化。</p><blockquote><p>由于之前一上来就是各种复杂的缓存组合策略，所以学而退，退而学。参考前辈的笔记，从主流的控制字段结合分析缓存字段的发展，相信会有入门理解的收获。</p></blockquote><p>一个数据请求过程可以分成发起网络请求，服务器处理，浏览器响应三个部分。浏览器缓存能够在第一、第三阶段，也就是发起网络请求、浏览器响应优化性能。比如第一阶段直接使用缓存<strong>不发起请求</strong>，第三阶段浏览器发起请求了但是请求资源未变化，不需要重新传送，<strong>减少响应数据</strong>。</p><p>学习缓存需要认识<strong>缓存位置</strong>，<strong>缓存策略</strong>以及实际场景<strong>如何应用缓存策略</strong>。</p><h2 id="1-缓存位置"><a href="#1-缓存位置" class="headerlink" title="1. 缓存位置"></a>1. 缓存位置</h2><p>从缓存位置上来说缓存分为四种，并各有优先级，按照优先级查找缓存，找到且符合要求即结束查找并返回，注意Chrome中，Memory Cache优先级是最高的</p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><h3 id="1-1-Service-Worker（可先不深入，但需要了解）"><a href="#1-1-Service-Worker（可先不深入，但需要了解）" class="headerlink" title="1.1 Service Worker（可先不深入，但需要了解）"></a>1.1 Service Worker（可先不深入，但需要了解）</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。 <strong>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的</strong> 。</p><p>Service Worker 检查资源是否存在其缓存中，并根据其编程的缓存策略决定是否返回资源。这个操作不会自动发生，需要在注册的 Service Worker 中定义 <code>fetch</code> 事件去拦截并处理网络请求，这样才能命中 Service Worker 缓存而不是网络或者 HTTP 缓存。</p><p>简单的理解：<strong>前端</strong>定义规则手动控制文件的缓存，利用<code>fetch</code>事件，在发送网络请求前拦截并检查本地是否缓存了数据，以决定是否发起网络请求。相信作为一名前端工程师会有本地存储 token 的经验，发起网络请求前检查本地的 token，如果 token 不存在可以直接返回，不发起请求，Service Worker就是类似的工作原理。</p><p>Service Worker 看起来也是一个缓存技术，为什么要使用 Service Worker？</p><p>答案：</p><ul><li><p>提高WebApp的离线缓存能力，缩小 WebApp 与 NativeApp 之间差距。在无网情况下发起一个网络请求，网页会一直加载，最后跳出网络未连接的提示，而原生的App即使是在无网络情况下如单机游戏，还是正常运行。</p></li><li><p>事件同步：即使关闭了当前 Web 页面也可以正常工作。如 Web 邮件客户端通知</p></li><li><p><a href="https://x5.tencent.com/product/service-worker.html#:~:text=Service%20Worker%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF,1%E3%80%81%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%EF%BC%9A%E5%8F%AF%E4%BB%A5%E5%B0%86H5%E5%BA%94%E7%94%A8%E4%B8%AD%E4%B8%8D%E5%8F%98%E5%8C%96%E7%9A%84%E8%B5%84%E6%BA%90%E6%88%96%E8%80%85%E5%BE%88%E5%B0%91%E5%8F%98%E5%8C%96%E7%9A%84%E8%B5%84%E6%BA%90%E9%95%BF%E4%B9%85%E7%9A%84%E5%AD%98%E5%82%A8%E5%9C%A8%E7%94%A8%E6%88%B7%E7%AB%AF%EF%BC%8C%E6%8F%90%E5%8D%87%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E3%80%81%E9%99%8D%E4%BD%8E%E6%B5%81%E9%87%8F%E6%B6%88%E8%80%97%E3%80%81%E9%99%8D%E4%BD%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E3%80%82%20%E5%A6%82%E4%B8%AD%E9%87%8D%E5%BA%A6%E7%9A%84H5%E6%B8%B8%E6%88%8F%E3%80%81%E6%A1%86%E6%9E%B6%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E7%9A%84web%E8%B5%84%E8%AE%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%81web%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AD%89">腾讯浏览服务-Service Worker (tencent.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/115243059">service worker 是什么？看这篇就够了 - 知乎 (zhihu.com)</a></p></li></ul><h3 id="1-2-Memory-Cache"><a href="#1-2-Memory-Cache" class="headerlink" title="1.2 Memory Cache"></a>1.2 Memory Cache</h3><p>Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。  <strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了</strong> 。</p><blockquote><p>既然内存缓存效率那么高，是不是可以将所有的缓存都使用内存来存储呢？</p></blockquote><blockquote><p>这是不可能的。首先从容量上看，计算机内存容量比硬盘小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。其次，内存在断电情况下不保存数据的，所以不可能将所有的数据都放在内存。</p></blockquote><p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存（Size字段）</p><p><img src="/assets/image-20220907185452-fa5jojc.png" alt="image"></p><blockquote><p>古老的浏览器解析一个网页的流程是串行的，网络请求下载，解析，网络请求下载另外一个文件，解析。现代的浏览器都是并行下载的，即一边解析，一边可能几个线程在下载不同的资源文件。</p></blockquote><p>内存缓存中有一块重要的缓存资源是 <code>preloader</code> 、<code>preload</code>相关指令（例如<code>&lt;link rel=&quot;prefetch&quot;&gt;</code>）下载的资源。总所周知 preloader 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js&#x2F;css 文件，一边网络请求下一个资源，并不一定只是一个网络请求，可能同时存在多个线程在下载资源。关于缓存字段，将在下文详细介绍。</p><p>需要注意的是：<strong>内存缓存在缓存资源时并不关心 HTTP 缓存头 Cache-Control 是什么值</strong>，<strong>同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type ， CORS 等其他特征做校验</strong> 。</p><p>简单总结：目前几乎所有的 <strong>HTTP缓存控制字段</strong> 都来源于后端服务的<strong>响应</strong>，在Chrome中，内存缓存的优先级是最高的。内存缓存不关心HTTP响应的缓存头字段，同时资源的匹配也并非只是对URL做匹配，还可能会对Content-TYpe，CORS等其他特征做校验。</p><h3 id="1-3-Disk-Cache"><a href="#1-3-Disk-Cache" class="headerlink" title="1.3 Disk Cache"></a>1.3 Disk Cache</h3><p>Disk Cache 是存储在硬盘上的缓存，虽然读取速度较慢，但是什么都能存储到磁盘中， <strong>比之 Memory Cache 胜在容量和存储时效性上</strong> ，能够长时间的保存缓存。</p><blockquote><p>在所有浏览器缓存中，<strong>Disk Cache 覆盖面基本是最大的</strong>。它会根据 HTTP Herder 中的<strong>缓存字段判</strong>断哪些资源需要缓存，哪些资源可以不请求<strong>直接使用</strong>，哪些资源已经过期需要<strong>重新请求</strong>。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p><p>例如：常见的JQuery压缩包，在Disk Cache缓存后，所有使用JQuery的站点都可以使用本地缓存的JQuery。</p></blockquote><p>绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p><p>那么浏览器什么时候会将资源缓存到硬盘中呢？关于这点，网上说法不一，不过以下观点比较靠得住：</p><ul><li>对于<strong>大文件</strong>来说，大概率是不存储在内存中的，反之优先</li><li>当前<strong>系统内存使用率高</strong>的话，文件优先存储进硬盘</li></ul><p>简单总结 Disk Cache</p><ul><li>容量大</li><li>时间长</li><li>跨站点</li><li>覆盖范围最广</li></ul><h3 id="1-4-Push-Cache（需要了解，但在Service-Worker之后）"><a href="#1-4-Push-Cache（需要了解，但在Service-Worker之后）" class="headerlink" title="1.4 Push Cache（需要了解，但在Service Worker之后）"></a>1.4 Push Cache（需要了解，但在Service Worker之后）</h3><p>Push Cache（推送缓存）是 HTTP&#x2F;2 中的内容，按照缓存的优先级，当以上三种缓存都没有命中时，它才会被使用。 <strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂</strong> ，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP&#x2F;2 在国内不够普及。这里推荐阅读<code>Jake Archibald</code>的 <a href="https://links.jianshu.com/go?to=https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">HTTP&#x2F;2 push is tougher than I thought</a> 这篇文章，文章中的几个结论：</p><ul><li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</li><li>可以推送 no-cache 和 no-store 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用同一个HTTP&#x2F;2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>你可以给其他域名推送资源</li></ul><h2 id="2-缓存过程分析（缓存策略）"><a href="#2-缓存过程分析（缓存策略）" class="headerlink" title="2. 缓存过程分析（缓存策略）"></a>2. 缓存过程分析（缓存策略）</h2><p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。那么为了性能上的考虑，大部分的接口都应该选择好缓存策略， <strong>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的</strong> 。</p><p>浏览器与服务器通信的方式为<strong>应答模式</strong>，即是：浏览器发起HTTP请求 – 服务器响应该请求， <strong>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢</strong> ？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存， <strong>即浏览器对资源缓存的处理是根据第一次请求资源时返回的响应头来确定的</strong> 。具体过程如下图：</p><p><img src="/assets/image-20220907235229-v01zwzm.png" alt="image" title="第一次缓存过程"></p><blockquote><p>无论是什么时候发起的请求，浏览器首先匹配浏览器缓存，如果没有缓存命中或者缓存过期才会发送网络请求请求最新资源。在资源响应后，浏览器会根据HTTP响应中的<strong>缓存字段</strong>来控制缓存方式（若无缓存字段，则为默认缓存方式，默认缓存方式在下文介绍）。</p></blockquote><p>由上图我们可以知道：</p><ul><li>浏览器每次发起请求，都先在浏览器缓存中<strong>查找</strong>该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识<strong>存入浏览器缓存</strong>中</li></ul><p>以上两点结论就是浏览器缓存机制的关键，<strong>浏览器查找和存入确保了每个请求的缓存存入与读取</strong>，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据<strong>是否需要向服务器重新发起HTTP请求</strong>将缓存过程分为两个部分，分别是强缓存和协商缓存。</p><h2 id="3-强缓存和协商缓存"><a href="#3-强缓存和协商缓存" class="headerlink" title="3. 强缓存和协商缓存"></a>3. 强缓存和协商缓存</h2><p>强缓存和协商缓存两个<strong>阶段</strong>并不容易理解，读者需要细心阅读并反复思考。</p><p>按照是否需要<strong>向服务器重新发起HTTP请求</strong>将缓存的过程分为两个部分，<strong>强缓存阶段和协商缓存阶段</strong>。<strong>Memory Cache 和 Disk Cache 都属于强缓存</strong>。现代浏览器缓存存储图像和网页等(主要在磁盘上)，而你的操作系统缓存文件可能大部分在内存缓存中。</p><p>注意：<strong>强缓存和协商缓存是一个阶段</strong>，而不是指具体的缓存位置或形式。</p><p>浏览器每次发送请求前都会检查自身缓存，称为<strong>强缓存</strong>阶段，具有不存在、存在两种情况</p><ul><li><p>缓存不存在，属于强缓存失效阶段，请求新资源</p></li><li><p>缓存存在，可以分成未过期、已过期两种情况</p><ul><li><p>缓存未过期，属于强缓存<strong>生效</strong>，那么<strong>结束</strong>并返回对应缓存</p></li><li><p>缓存已过期，属于强缓存<strong>失效</strong>，那么进入<strong>协商</strong>缓存阶段，可以分成生效，失效两种情况</p><ul><li>服务器资源未修改，返回 <strong>304</strong>，属于协商缓存生效</li><li>服务器资源已修改，返回 <strong>200</strong>，属于协商缓存失效</li></ul></li></ul></li></ul><p>从以上分析中可以得到结论</p><p>每一次网络请求都会进入强缓存阶段，当 <strong>缓存存在</strong> 且 <strong>缓存已过期</strong> 时才能进入协商缓存阶段。<strong>缓存不存在</strong>时发起的网络请求不属于协商缓存阶段，这一点和后续的协商缓存容易混淆，也请记住<strong>缓存不存在</strong>能表达的两种情况，第一次请求和请求后被删除。特殊的，当<strong>缓存存在</strong>时，强缓存中有一个字段 <code>Cache-Control: no-cache</code> 可以直接使强缓存失效并进入协商缓存，将在强缓存中详细介绍。</p><p>简单总结：浏览器发送请求前检查自身缓存，属于强缓存阶段；<strong>缓存存在</strong> 且 <strong>缓存已过期，需要重新发起网络请求</strong>则是协商缓存阶段。</p><h3 id="3-1-强缓存"><a href="#3-1-强缓存" class="headerlink" title="3.1 强缓存"></a>3.1 强缓存</h3><p>强缓存：<strong>不会向服务器重新发送请求，直接从缓存中读取资源</strong>，在 Chrome 控制台的 Network 选项中可以看到该请求返回 <strong>200</strong> 的状态码，并且 Size 显示from disk cache 或 from memory cache。</p><p>强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p><h4 id="3-1-1-Expires"><a href="#3-1-1-Expires" class="headerlink" title="3.1.1 Expires"></a>3.1.1 Expires</h4><p><strong>Expires：缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点</strong> 。也就是说，Expires &#x3D; max-age + 请求时间，需要和 Last-modified 结合使用。Expires 是 Web 服务器<strong>响应消息头字段</strong>，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p><strong>Expires 是 HTTP&#x2F;1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效</strong> 。<code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code> 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。如果修改当前的时间查过Expires给定的时间，那么浏览器就会重新发起请求，进入<strong>协商缓存阶段</strong>。</p><h4 id="3-1-2-Cache-Control"><a href="#3-1-2-Cache-Control" class="headerlink" title="3.1.2 Cache-Control"></a>3.1.2 Cache-Control</h4><p>在 HTTP&#x2F;1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当<code>Cache-Control:max-age=300</code>时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p><p><img src="/assets/image-20220908002252-w0l3req.png" alt="image" title="组合使用多种指令"></p><ul><li><p><strong>public</strong> ： <strong>所有内容都将被缓存（客户端和代理服务器都可缓存）</strong> 。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;–  proxy2 &lt;– Server，中间的 proxy 可以缓存资源，比如下次再请求同一资源 proxy1 直接把自己缓存的东西给 Browser 而不再向 proxy2 要。</p></li><li><p><strong>private</strong> ： <strong>所有内容只有客户端可以缓存</strong> ，Cache-Control 的默认取值。具体来说，表示中间节点不允许缓存，对于 Browser &lt;– proxy1 &lt;–  proxy2 &lt;– Server，proxy 会老老实实把 Server 返回的数据发送给 proxy1，自己不缓存任何数据。当下次 Browser 再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。</p></li><li><p><strong>no-cache</strong> ：<strong>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。</strong>表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。<strong>需要注意的是，no-cache 这个名字有一点误导。设置了 no-cache 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</strong></p></li><li><p><strong>no-store</strong> ：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。</p></li><li><p><strong>max-age</strong> ：max-age&#x3D;xxx (xxx is numeric) 表示缓存内容将在当前响应时间的xxx秒后失效，一般响应头中会包含 Date 字段。</p></li><li><p><strong>s-maxage</strong> （单位为s)：同 max-age 作用一样，只在代理服务器中生效（比如CDN缓存）。比如当 s-maxage&#x3D;60 时，在这 60 秒中，即使更新了 CDN 的内容，浏览器也不会进行请求。max-age 用于普通缓存，而 s-maxage 用于代理缓存。 <strong>s-maxage 的优先级高于 max-age</strong> 。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。</p></li><li><p><strong>max-stale</strong> ：能容忍的最大过期时间。max-stale 指令标示了客户端愿意接收一个已经过期了的响应。如果指定了 max-stale 的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何 age 的响应（age 表示响应由源站生成或确认的时间与当前时间的差值）。</p></li><li><p><strong>min-fresh</strong> ：能够容忍的最小新鲜度。min-fresh 标示了客户端不愿意接受新鲜度不多于当前时间加上 min-fresh 设定的时间之和的响应。简单来说不要太新的资源。</p></li></ul><p><img src="/assets/image-20220908002929-cfakxvf.png" alt="image" title="强缓存流程分析"></p><p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。</p><p>Cache-Control字段属性解读</p><ul><li>可被复用指的是资源能否被缓存，不能缓存的标识是 <code>no-store</code>。</li><li>资源在使用时是否保持一致指的是是否需要每次都检查资源有效性。<code>no-cache</code> 的设计很容易让人误解，<code>no-cache</code> 指的是每次使用缓存资源是否都需要向服务器验证是否过期，如果不过期则返回 <strong>304</strong> 和空响应体表示直接使用缓存，过期则重新返回 <strong>200</strong> 和最新资源。</li><li>在网络请求中，可能会经过代理服务器，<code>public, private</code> 控制是否允许代理服务器缓存资源，<code>public</code> 表示均允许缓存，<code>private</code> 表示仅有客户端才允许缓存。</li><li>权限设置完成后，便是指定缓存的时效。代理服务器缓存有属性 <code>s-maxage</code> 属性，客户端缓存有属性 <code>max-age</code> 和缓存字段 <code>Expires</code> 控制时效。Cache-Control字段的优先级高于Expires字段，Cache-Control字段中的属性 <code>s-maxage</code>优先级高于 <code>max-age</code>。注意区分属性的优先级和字段的优先级。</li><li>最大过期时间设置后，还可以设置允许的最大过期时间 <code>max-state</code> 和允许的最小新鲜时间 <code>min-fresh</code>。</li></ul><h4 id="3-1-3-Expires-和-Cache-Control"><a href="#3-1-3-Expires-和-Cache-Control" class="headerlink" title="3.1.3 Expires 和 Cache-Control"></a>3.1.3 Expires 和 Cache-Control</h4><p>其实这两者差别不大，区别就在于 Expires 是 HTTP1.0 的产物，Cache-Control是HTTP1.1 的产物，两者同时存在的话，Cache-Control 优先级高于 Expires；在某些不支持 HTTP1.1 的环境下，Expires 就会发挥用处。所以 Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p><p>强缓存判断缓存是否有效的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新。Expires、Cache-Control 字段依赖于本地时间 +  过期时间 + 允许最大过期时间。</p><blockquote><p>如果设置max-age&#x3D;60s，请求完成后的 60s 内服务端修改了资源，那么浏览器获得的资源是什么呢？浏览器在 60s 内不会重新请求资源，这就导致浏览器获得的资源不是最新的。</p></blockquote><p>强缓存的判断策略可能会导致加载文件不是服务器端最新的内容，是否还记得在 Cache-Control 中，具有一个属性 <code>no-cache</code>，表示跳过强缓存阶段，每次使用资源都需要发送请求和服务器确认是否为最新资源。可以认为<code>no-cache</code> 正是解决因为依赖于时间的判断没有极高靠性问题而出现的。</p><p>那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。</p><h3 id="3-2-协商缓存"><a href="#3-2-协商缓存" class="headerlink" title="3.2 协商缓存"></a>3.2 协商缓存</h3><p>协商缓存就是在 <strong>缓存存在</strong> 且 <strong>缓存已过期</strong> 的情况下，浏览器（重新）发送网络请求请求最新的资源的过程。特殊的，当<strong>缓存存在</strong>，强缓存中的一个属性 <code>Cache-Control:no-cache</code> 可以让强缓存失效并进入协商缓存。</p><p>协商缓存有两种情况</p><ul><li>服务器返回 <strong>304</strong> 和 Not Modified，协商缓存生效</li></ul><p><img src="/assets/image-20220908093254-l6lldq5.png" alt="image.png"></p><ul><li>服务器返回 <strong>200</strong> 和 最新资源，协商缓存失效</li></ul><p><img src="/assets/image-20220908113245-vjb4pbx.png" alt="image.png"></p><p><strong>条件：</strong>是否还记得进入协商缓存的要求？<strong>缓存存在</strong> 且 <strong>缓存已过期</strong> 是进入协商缓存的必要条件，特殊的，当<strong>缓存存在</strong>，强缓存中的一个属性 <code>Cache-Control:no-cache</code> 可以让强缓存失效并进入协商缓存。强缓存中通过 Expires 或 Cache-Control: max-age 判断缓存是否过期，那么在协商缓存中，如何确定是否协商生效呢？或者说服务器如何确定是否返回资源。</p><p>这个确定的方法很简单，协商缓存可以通过设置两种<strong>响应</strong> HTTP Header 实现，<strong>Last-Modified 和 ETag</strong> 。</p><h4 id="3-2-1-Last-Modified"><a href="#3-2-1-Last-Modified" class="headerlink" title="3.2.1 Last-Modified"></a>3.2.1 Last-Modified</h4><p>Last-Modified 字段是当前资源<strong>缓存不存在</strong>，请求成功后<strong>响应头</strong>中携带的参数字段，而后被浏览器缓存。Last-Modified 的值是这个资源在服务器上的<strong>最后修改时间</strong>，浏览器接收后缓存文件和 header 信息。</p><p>注意：缓存不存在能够表示两种情况：第一次请求、请求后被删除</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Fri, 22 Jul 2016 01:47:00 GMT</span><br></pre></td></tr></table></figure><p>浏览器下一次请求这个资源，浏览器检测到当前资源缓存中有 Last-Modified 这个 header 字段，于是在<strong>请求头</strong>中添加 If-Modified-Since 这个 header 字段，值就是 缓存的 header 信息中 Last-Modified 字段的值，服务器收到这个资源请求，会根据 If-Modified-Since 的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 <strong>304</strong> 和<strong>空的响应体</strong>，表示浏览器直接从缓存读取资源，此时表示<strong>协商缓存生效</strong>；如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回 <strong>200</strong> 和<strong>新的资源文件</strong>，此时表示<strong>协商缓存失效</strong>。返回 <strong>304</strong> 能够有效的降低数据的传输量，这也是为什么缓存能够提高性能的原因。</p><p><strong>简单总结：</strong>Last-Modified 和 If-Modified-Since 是配对的，Last-Modified 是缓存不存在时，发送网络请求且请求成功后携带的<strong>响应头</strong>的字段，而后被浏览器缓存，当浏览器再一次请求这个资源，浏览器检查缓存并发现 Last-Modified 字段，就会在<strong>请求头</strong>上添加 If-Modified-Since 字段，值就是 Last-Modified 的值。服务器收到请求后对比 if-Modified-Since 和 服务器中改资源的最后修改时间，如果相等返回 <strong>304</strong> 和空响应体，响应头中还会有 Last-Modified 字段，此时表示<strong>协商缓存生效</strong>，如果不相等则会返回 <strong>200</strong> 和最新资源，<strong>响应头</strong>中携带最新的最后修改时间即 Last-Modified 字段，此时表示协商缓存失效，浏览器缓存当前资源和 header 信息。</p><p><img src="/assets/image-20220908133821-ssuujgp.png" alt="image.png" title="协商缓存失效、生效"></p><p>Last-Modified 具有一些弊端</p><ul><li>如果<strong>本地</strong>打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified <strong>被修改</strong>，服务端不能命中缓存导致发送相同的资源</li><li>因为 Last-Modified 只能以秒计时，如果在<strong>不可感知的时间内</strong>修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li></ul><p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以 HTTP1.1 出现了 <code>ETag</code> 和 <code>If-None-Match</code>。</p><h4 id="3-2-2-ETag"><a href="#3-2-2-ETag" class="headerlink" title="3.2.2 ETag"></a>3.2.2 ETag</h4><p>ETag 和 Last-Modified 类似，是在<strong>缓存不存在</strong>时，浏览器发起请求，请求成功后<strong>响应头</strong>携带的字段，而后被浏览器缓存。与 Last-Modified 不同的是 ETag 的值是根据某一算法如哈希生成的文件唯一标识，<strong>只要资源有变化，ETag就会重新生成</strong> 。</p><p>浏览器在下一次加载该资源向服务器发送请求时，浏览器检查到当前资源的缓存具有 ETag，则会将缓存中的 ETag 值放到<strong>请求头</strong>中的 If-None-Match，服务器只需要比较客户端传来的 If-None-Match 和服务器上该资源的 ETag 是否一致，就能判断资源相对客户端是否被修改过。如果服务器发现 ETag 匹配不上，那么直接以常规 <strong>200</strong> 回包形式将新的资源（当然也包括了新的 ETag）发给客户端，此时表示<strong>协商缓存失效</strong>，浏览器缓存新的资源和 header 信息；如果 ETag 是一致的，则直接返回 <strong>304</strong> 和空响应体知会客户端直接使用本地缓存即可，此时响应头中还是携带有 ETag。</p><p><img src="/assets/image-20220908135926-h1v1twu.png" alt="image.png"></p><p>ETag 和 If-Node-Match 是配对的，与 Last-Modified 和 If-Modifed-Since 一样，但是 ETag 是使用的是文件的唯一标识，能够提升可靠性，但是因为需要计算文件的唯一标识，所以性能会比Last-Modified低。</p><h4 id="3-2-3-Last-Modified-和-ETag"><a href="#3-2-3-Last-Modified-和-ETag" class="headerlink" title="3.2.3 Last-Modified 和 ETag"></a>3.2.3 Last-Modified 和 ETag</h4><p>在<strong>缓存不存在</strong>时，浏览器发起网络请求请求资源，请求成功后，浏览器缓存资源文件和缓存 header 信息，在协商缓存阶段检查缓存的 header 信息，如果是 ETag 则给请求投添加 If-None-Match，如果是 Last-Modified，则给请求头添加 If-Modified-Since，服务器对字段做检查比较，决定协商缓存是否生效。注意：ETag 优先级高于 Last-Modified，也就是说会优先使用 ETag。</p><p>简单总结</p><ul><li>在精确度上，ETag 要优于 Last-Modified。</li></ul><p>Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么它们的Last-Modified 其实并没有体现出来修改，但是 ETag 每次都会改变确保了精度；<strong>如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致</strong>。</p><ul><li>在性能上，ETag 要逊于 Last-Modified，因为 Last-Modified 只需要记录时间，而 ETag 需要服务器通过算法来计算出一个 hash 值。</li><li>在优先级上，服务器校验优先考虑 ETag</li></ul><h2 id="4-缓存机制"><a href="#4-缓存机制" class="headerlink" title="4. 缓存机制"></a>4. 缓存机制</h2><p><strong>强缓存</strong>优先于<strong>协商缓存</strong>，若强制缓存 ( Expires 和 Cache-Control ) 生效则直接使用缓存，若不生效则进行协商缓存 (Last-Modified &#x2F; If-Modified-Since和Etag &#x2F; If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 <strong>200</strong>，重新返回资源和缓存标识，浏览器将缓存资源和 header 信息，此时表示<strong>协商缓存失效</strong>，若<strong>协商缓存生效</strong>则返回 <strong>304</strong> 和空响应体，表示继续使用缓存，此时响应头中仍然携带缓存控制字段， 此时表示协商缓存成功。</p><p>协商缓存只有在 <strong>缓存存在</strong> 且 <strong>缓存已过期</strong> 时才允许进入，特殊的，当缓存存在时，强制缓存（强缓存）的一个字段 <code>Cache-Control:no-cache</code> 可以强制缓存失效并进入协商缓存阶段，其原因就是 <code>Cache-Control:no-cache</code> 字段信息允许不检查强制缓存。</p><p><img src="/assets/image-20220908141753-3z6jz59.png" alt="image.png" title="缓存机制"></p><p>如果没有指定缓存策略，缓存的字段信息，那么浏览器会如何做呢？</p><p>对于这种情况，<strong>浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。</strong></p><h2 id="5-实际场景应用缓存策略"><a href="#5-实际场景应用缓存策略" class="headerlink" title="5. 实际场景应用缓存策略"></a>5. 实际场景应用缓存策略</h2><h3 id="5-1-频繁变动的资源"><a href="#5-1-频繁变动的资源" class="headerlink" title="5.1 频繁变动的资源"></a>5.1 频繁变动的资源</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br></pre></td></tr></table></figure><p>频繁变动的资源对时效性要求比较强，从直观上，可以不使用缓存字段，但是不使用缓存字段就意味着默认缓存策略即<strong>浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间</strong>，这不符合要求。</p><p>最理想的策略是：每当有该资源的请求时，就和服务器确认资源是否发生了变化，如果发生了变化则重新传送数据，如果没有发生变化则使用本地的缓存数据。</p><p>解析：按照理想策略，应该请服务器来鉴定资源有效性。每一个请求都会进入强缓存阶段，所以需要跳出强缓存阶段，接着才能请服务器鉴定。而使强缓存失效的方法有两种，资源不存在，资源已过期。可以设置<code>Cache-Control: max-age=0</code>，每一次请求都会发现资源过期，强缓存失效并进入协商缓存，携带 ETag 或 Last-Modified 并进行请求，服务器对比值决定协商缓存是否生效。之前也声明过，特殊的，在缓存存在时，强缓存的<code>Cache-Control: no-cache</code> 可以使强缓存失效并进入协商缓存，即跳过强缓存的检查（会进入强缓存阶段，但跳过对比检查）进入协商缓存，刚好符合频繁变动的缓存需求，所以这两种方式都可以，只不过设置过期时间方式浏览器会多做一步过期的检查。</p><h3 id="5-2-不常变化的资源"><a href="#5-2-不常变化的资源" class="headerlink" title="5.2 不常变化的资源"></a>5.2 不常变化的资源</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=31536000</span><br></pre></td></tr></table></figure><p>通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 <code>max-age=31536000</code> (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等<strong>动态字符</strong>，之后<strong>更改动态字符</strong>，从而达到<strong>更改引用 URL</strong> 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。</p><p>在线提供的类库 (如 <code>jquery-3.3.1.min.js</code>, <code>lodash.min.js</code> 等) 均采用这个模式。</p><h2 id="6-用户行为对缓存的影响"><a href="#6-用户行为对缓存的影响" class="headerlink" title="6. 用户行为对缓存的影响"></a>6. 用户行为对缓存的影响</h2><p>所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p><ul><li>打开网页，地址栏输入地址， 查找 Disk Cache 中是否有匹配。如有则使用，如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 Memory Cache 是可用的，会被优先使用(如果匹配的话)。其次才是 Disk Cache。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的<strong>请求头</strong>部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了 <code>Pragma: no-cache</code>),服务器直接返回 200 和最新内容。</li></ul><p>需要分清楚<strong>请求头</strong>中的 no-cache 和<strong>响应头</strong>中的 no-cache，两者的作用是不相同的。</p><p><strong>请求头</strong>的 no-cache 表示浏览器不想读缓存，并不是说没有缓存。一般在浏览器按 Ctrl+F5 强制刷新时，请求头里就有这个no-cache，也就是跳过强缓存和协商缓存阶段，直接请求服务器。（如果直接按F5的话，请求头是 max-age&#x3D;0，只跳过强缓存，但进行协商缓存）。</p><p><strong>响应头</strong>的 no-cache 表示跳过强缓存检查（会进入强缓存阶段，但不检查时间，使强缓存失效并接入协商缓存，max-age&#x3D;0 检查时间，使强缓存失效，再进入协商缓存）</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>缓存能够有效的减少网络请求数量或降低网络传送的数据量，主要用于页面的性能优化、降低数据流量成本等。</p><p>认识学习缓存需要从缓存的位置、缓存的策略和实际场景应用缓存策略三个方面入手。了解缓存位置可以知晓浏览器将缓存放在哪，各种不同的缓存位置有什么优势；了解基础缓存策略（强缓存、协商缓存可以看成是本地判断和远程判断）可以知晓缓存优先级需要控制在哪，是强缓存还是协商缓存。基础缓存策略配合缓存位置，就可以组合出针对不同场景地各种复杂的缓存方式。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.jianshu.com/p/54cc04190252">深入理解浏览器的缓存机制 - 简书 (jianshu.com)</a></li><li><a href="https://juejin.cn/post/6844903747357769742?utm_source=gold_browser_extension">一文读懂前端缓存 - 掘金 (juejin.cn)</a></li><li><a href="https://www.cnblogs.com/cxyqts/p/13093564.html">http缓存强制缓存和协商缓存？- 博客园 (cnblogs.com)</a></li><li><a href="https://juejin.cn/post/7031923575044964389">后端一次给你10万条数据，如何优雅展示，到底考察我什么? - 掘金 (juejin.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web性能与安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一. 输入URL到呈现页面</title>
      <link href="/2023/08/01/%E4%B8%80.%20%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%91%88%E7%8E%B0%E9%A1%B5%E9%9D%A2/"/>
      <url>/2023/08/01/%E4%B8%80.%20%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%91%88%E7%8E%B0%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一-输入URL到呈现页面"><a href="#一-输入URL到呈现页面" class="headerlink" title="一. 输入URL到呈现页面"></a>一. 输入URL到呈现页面</h1><p>按照实现的功能我认为可以划分为三个阶段</p><ul><li>本地校验阶段</li><li>网络请求阶段</li><li>本地渲染阶段</li></ul><h2 id="1-本地校验阶段"><a href="#1-本地校验阶段" class="headerlink" title="1. 本地校验阶段"></a>1. 本地校验阶段</h2><p>本地校验阶段其实很简单，判断输入的信息是搜索还是域名(服务器地址IP)</p><ul><li>如果是搜索，浏览器将会把默认<strong>搜索引擎URL</strong> + <strong>搜索内容</strong>合并成一个新的URL</li><li>如果是网址，浏览器则会根据URL协议，将网址补全为合法的URL</li></ul><p>常见的例子</p><ul><li><p>输入Hello World：<a href="https://cn.bing.com/search?q=hello+world&amp;FORM=ANAB01&amp;PC=U531">https://cn.bing.com/search?q=hello+world&amp;FORM=ANAB01&amp;PC=U531</a></p></li><li><p>输入 image.baidu.com：<a href="https://image.baidu.com/">https://image.baidu.com/</a></p></li></ul><p>可以看出：</p><ul><li>输入搜索内容时，浏览器会将默认搜索引擎URL + 搜索内容合并成一个新的URL，并且可能会添加其他的参数。</li><li>输入网址时，浏览器会自动将原有的网址补全为合法的 URL，如加上 http&#x2F;https，特别注意当输入 <code>baidu.com</code>时，可能会跳转 <code>www.baidu.com</code>，这并不是浏览器的操作而是由服务器重定向到下级的<code>www</code>，目的是 SEO 和保证 cookie 等存储的安全。</li></ul><h2 id="2-网络请求阶段"><a href="#2-网络请求阶段" class="headerlink" title="2. 网络请求阶段"></a>2. 网络请求阶段</h2><p>网络请求阶段是一个复杂的过程，为了优化用户体验，浏览器会尽可能早的将页面呈现在用户面前，所以<strong>网络请求阶段</strong>与第三个阶段<strong>本地渲染</strong>是同步进行的，请求完成可以解析的内容就开始解析，并同时加载剩下地资源。TCP是一个全双工协议。</p><p>网络请求阶段可以细分为四个阶段</p><ul><li>DNS解析（可选）</li><li>建立TCP连接</li><li>发送HTTP请求</li><li>关闭TCP连接</li></ul><h3 id="2-1-DNS解析"><a href="#2-1-DNS解析" class="headerlink" title="2.1 DNS解析"></a>2.1 DNS解析</h3><p>DNS解析是为解析域名的IP而存在的，反向解析则是通过IP查询对应的域名。因为仅靠数字点分型的IP是很难记住的，所以在大部分时候都是通过域名访问网站，因而也需要一个地址簿即 DNS 服务器。</p><p>DNS 服务器是高可用、高并发和分布式的，它是树状结构，如图：</p><p><img src="/assets/image-20220906101312-5na6p7a.png" alt="image"></p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器：返回顶级域 DNS 服务器的 IP 地址，存储如（.com, .cn）服务器的地址</li><li>顶级域 DNS 服务器（com）：返回权威 DNS 服务器的 IP 地址</li><li>权威 DNS 服务器（<a href="http://server.com/">server.com</a>）：返回相应主机的 IP 地址，真正存储当前查询域名的地址簿，如在阿里注册的域名会给分配DNS服务器存储解析<code>dns17.hichina.com</code>，可以在阿里买域名然后转腾讯，此时的阿里服务的权威DNS就会变成腾讯服务的权威DNS</li><li>本地域名服务器（查询代理和DNS查询结果缓存）: 只是一个查询代理，可以是路由器，也可以是运营商的服务器</li></ul><p>目前流行的是递归+迭代查询方式。</p><blockquote><p>如果手机或者电脑上设置解析的DNS为114.114.114.114，那么本地服务器就是114，从设备到114之间为递归查询，其余的为迭代查询。</p></blockquote><blockquote><p>如果设备设置的解析地址为DHCP即路由器或其他自动分配，那么可以认为当前设备到路由器是递归查询，其余为迭代查询。</p></blockquote><p><img src="/assets/image-20220906093724-2b83fv1.png" alt="image.png"></p><p><img src="/assets/image-20220906103913-4kgoi13.png" alt="image"></p><blockquote><p>注：未找到本地DNS解析器缓存，这里我认为是路由器缓存</p></blockquote><p>在客户端输入 URL 后，会有一个<strong>递归+迭代</strong>的过程，<strong>浏览器缓存</strong> -&gt; <strong>系统DNS缓存</strong> -&gt; <strong>本地hosts文件</strong> -&gt; <strong>本地DNS解析器缓存</strong> ?  -&gt; <strong>本地区域DNS服务器迭代查询</strong>，这个过程中任何一步找到了都会结束查找流程。如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式（是否委托其他服务器来干这件事），则迭代查找过程如下图：</p><p><img src="/assets/image-20220906104500-rmsecj0.png" alt="image"></p><p>在查找过程中，有以下优化点：</p><ul><li>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</li><li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li></ul><h3 id="2-2-建立Tcp连接"><a href="#2-2-建立Tcp连接" class="headerlink" title="2.2 建立Tcp连接"></a>2.2 建立Tcp连接</h3><p>首先，判断是不是 <strong>https</strong> ，如果是，则请求过程其实是 HTTP + SSL &#x2F; TLS 两部分组成，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，即传输都是加密后的数据。</p><p>三次握手，建立TCP连接</p><ol><li>第一次握手：建立连接，客户端发送连接请求报文段。将SYN位置为1，此时表示客户端向服务端请求建立连接，Sequence Number为x，随机数用于校验；客户端进入SYN_SEND状态，等待服务器的确认</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；发送SYN请求信息，将SYN位置为1，此时表示服务端向客户端发送建立连接的请求；Sequence Number为y，随机数用于校验；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入 <strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</li></ol><p><strong>简单总结：</strong>三次握手的原因是保证双方通信，TCP是一个全双工协议，所以链路需要分别建立，客户端向服务端请求建立连接，服务端向客户端应答同时请求建立连接，客户端向服务端应答。</p><p>SSL握手过程</p><ol><li><strong>第一步</strong> ：爱丽丝给出支持SSL协议版本号，一个客户端 <strong>随机数</strong> (Client random，第一个随机数)，客户端支持的加密方法等信息</li><li><strong>第二步：</strong> 鲍勃收到信息后，确认双方使用的加密方法，并返回数字证书，一个服务器生成的 <strong>随机数</strong> (Server random，第二个随机数)等信息</li><li><strong>第三步：</strong> 爱丽丝确认数字证书的有效性（计算机系统已默认存储相关机构的证书），然后生成一个新的 <strong>随机数</strong> (Premaster secret)，然后使用数字证书中的公钥，加密这个随机数，发给鲍勃。</li><li><strong>第四步：</strong> 鲍勃使用自己的私钥，获取爱丽丝发来的 <strong>随机数</strong> (即Premaster secret)；(第三、四步就是非对称加密的过程了)</li><li><strong>第五步：</strong> 爱丽丝和鲍勃通过约定的加密方法(通常是<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">AES算法</a>)，使用前面三个随机数，生成 <strong>对话密钥</strong> ，用来加密接下来的通信内容</li></ol><p><img src="/assets/image-20220906111112-swzpduo.png" alt="image"></p><p>完成之后，客户端和服务器端就可以开始传送数据。更多 HTTPS 的资料可以看这里：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/32513816">SSL协议之数据加密过程详解 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/26682342">深入理解HTTPS原理、过程与实践 - 知乎 (zhihu.com)</a></li><li><a href="https://segmentfault.com/a/1190000012196642">解析HTTPS - SegmentFault 思否</a></li></ul><p>简单总结：Tcp建立完成后，如果没有加密 SSL&#x2F;TLS 过程，此时可以开始 HTTP 请求，如果有加密过程，则按照五个阶段进行准备，SSL使用非对称来加密会话密钥，后期使用会话密钥对称加密会话。</p><blockquote><p>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP协议规定，只有ACK&#x3D;1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</p><p>SYN(SYNchronization)：在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN&#x3D;1和ACK&#x3D;1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</p><p>FIN(finis）即完，终结的意思， 用来释放一个连接。当 FIN &#x3D; 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</p></blockquote><h3 id="2-3-http-x2F-https请求"><a href="#2-3-http-x2F-https请求" class="headerlink" title="2.3 http&#x2F;https请求"></a>2.3 http&#x2F;https请求</h3><p>TCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200.</p><p>这里有发生一个<strong>HTTP缓存</strong>过程，是一个常考的考点，大致过程如图：</p><p><img src="/assets/image-20220906112223-hedug48.png" alt="image"></p><p>细节放到了《二. Web性能与安全》处，也可以参考 <a href="https://juejin.cn/post/6844903962216824839#heading-10">浏览器相关原理(面试题)详细总结一 - 掘金 (juejin.cn)</a> 中浏览器缓存这一部分。</p><h3 id="2-5-断开Tcp连接"><a href="#2-5-断开Tcp连接" class="headerlink" title="2.5 断开Tcp连接"></a>2.5 断开Tcp连接</h3><ul><li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我”同意”你的关闭请求；</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ul><p><strong>简单总结：</strong>TCP是一个全双工协议，所以链路需要分别拆除，因为链路是双向的，所以无论是建立还是拆除，都需要分别建立，分别拆除，建立和拆除都是一问一答的形式。</p><p>在建立链路时，客户端发送请求建立，服务端应答同时也请求建立，客户端应答。</p><p>在拆除链路时，客户端发送拆除链路，服务端第一次应答，第二次发送拆除链路请求，客户端发送应答。可以是客户端先发送拆除，也可以是服务端先发送拆除，没有顺序要求但是要符合一问一答，与建立连接不同的是拆除链路的应答和发送分开发送，所以是四次挥手。</p><p>分开发送的目的是一条链路不再需要后可以<strong>及时断开</strong>，如果与建立连接类似同时发送 Ack + Fin，那么只有等到被动关闭端处理所有的信息后才会发送。</p><p>举个例子，A向B<strong>紧急</strong>借钱，B可以选择<strong>立刻</strong>给钱或者开一个借条后再给钱，立刻给钱可以<strong>及时响应</strong>，而开借条后再借钱则是<strong>耗费</strong>了A的<strong>等待时间</strong>，必须等B处理完所有借条工作后才能够拿到。</p><blockquote><p><strong>为什么需要四次挥手？</strong></p><p>因为TCP是一个全双工协议，必须单独拆除每一条信道。4次挥手的目的是终止数据传输，并回收资源，此时两个端点两个方向的序列号已经没有了任何关系，必须等待两方向都没有数据传输时才能拆除虚链路，不像初始化时那么简单，发现SYN标志就初始化一个序列号并确认SYN的序列号。因此必须单独分别在一个方向上终止该方向的数据传输。</p><p>如果是三次挥手，会怎么样？三次的话，被动关闭端在收到FIN消息之后，需要同时回复ACK和Server端的FIN消息。如果Server端在该连接上面并没有Pending的消息要处理，那么是可以的，如果Server端还需要等待一段时间才可以关闭另外一个方向的连接，那么这样的三次挥手就不能满足条件。</p><p><a href="https://www.jianshu.com/p/7ddb0e7867ac">【TCP&#x2F;IP】四次挥手的过程及原因 - 简书 (jianshu.com)</a></p></blockquote><h2 id="3-本地渲染阶段"><a href="#3-本地渲染阶段" class="headerlink" title="3. 本地渲染阶段"></a>3. 本地渲染阶段</h2><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树，CSSOM树、样式计算、布局阶段、分层、栅格化和显示。如图：</p><p><img src="/assets/image-20220906122229-s89ggsz.png" alt="image"></p><ul><li>渲染进程将 HTML 内容转换为能够读懂DOM 树结构，渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式，此时的过程是同步的，即HTML Parser 和 CSS Parser，Render Tree构建是同步的。</li><li>创建layout布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。</li><li>合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。</li></ul><h3 id="3-1-构建-DOM-树"><a href="#3-1-构建-DOM-树" class="headerlink" title="3.1 构建 DOM 树"></a>3.1 构建 DOM 树</h3><p>浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程即将字节解析为DOM树，先将HTML的原始字节数据转换为文件<strong>指定编码</strong>的字符，然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。</p><p><img src="/assets/image-20220906122855-4obxhof.png" alt="image"></p><ul><li>转码（Bytes -&gt; Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</li><li>Tokens 化（Characters -&gt; Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</li><li>构建 Nodes（Tokens -&gt; Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）</li><li>构建 DOM 树（Nodes -&gt; DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系</li></ul><p>具体的步骤可以参考《三. 浏览器内部工作 - 解析方向》</p><h3 id="3-2-样式计算"><a href="#3-2-样式计算" class="headerlink" title="3.2 样式计算"></a>3.2 样式计算</h3><p>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</p><p>CSS 样式来源主要有 3 种，分别是<code>通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。</code>，其样式计算过程主要为：</p><p><img src="/assets/image-20220906123225-36r2wq2.png" alt="image"></p><p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。处理完成后再处理样式的继承和层叠，有些文章将这个过程称为CSSOM的构建过程。</p><p>具体的可以参考：《三. 浏览器内部工作 - 解析方向》</p><h3 id="3-3-页面布局"><a href="#3-3-页面布局" class="headerlink" title="3.3 页面布局"></a>3.3 页面布局</h3><p>布局过程，即排除 <code>script、meta</code> 等功能化、非视觉节点，排除 <code>display: none</code> 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图：</p><p><img src="/assets/image-20220906123341-1ba6ky0.png" alt="image"></p><p>其中，这个过程需要注意的是<code>回流和重绘</code>，具体的可以参考《三. 浏览器内部工作 - 解析方向》</p><h3 id="3-4-生成分层树"><a href="#3-4-生成分层树" class="headerlink" title="3.4 生成分层树"></a>3.4 生成分层树</h3><p>页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），如图：</p><p><img src="/assets/image-20220906123525-cem0mn0.png" alt="image"></p><p>如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。在浏览器中，你可以打开 Chrome 的”开发者工具”，选择”Layers”标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。</p><p>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？</p><p>具体参考：<a href="https://juejin.cn/post/6844903969693646862#heading-4">浏览器相关原理(面试题)详细总结二 - 掘金 (juejin.cn)</a></p><h3 id="3-5-栅格化"><a href="#3-5-栅格化" class="headerlink" title="3.5 栅格化"></a>3.5 栅格化</h3><p>合成线程会按照视口附近的图块来<strong>优先</strong>生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。如图：</p><p><img src="/assets/image-20220906123907-bjyj2ua.png" alt="image"></p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><h3 id="3-6-显示"><a href="#3-6-显示" class="headerlink" title="3.6 显示"></a>3.6 显示</h3><p>最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。</p><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4. 参考文章"></a>4. 参考文章</h2><ul><li><a href="https://juejin.cn/post/6844904054074654728">细说浏览器输入URL后发生了什么 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6994066112203718686">输入URL到页面显示的前端体系知识 - 掘金 (juejin.cn)</a></li></ul><p>‍</p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端：个人前端项目的有关约定和规范</title>
      <link href="/2023/07/29/%E5%89%8D%E7%AB%AF%EF%BC%9A%E9%84%99%E4%BA%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%89%E5%85%B3%E7%BA%A6%E5%AE%9A%E5%92%8C%E8%A7%84%E8%8C%83/"/>
      <url>/2023/07/29/%E5%89%8D%E7%AB%AF%EF%BC%9A%E9%84%99%E4%BA%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%89%E5%85%B3%E7%BA%A6%E5%AE%9A%E5%92%8C%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>个人认为技术人员掌握的前端框架不应该只限定在某一个（如 React、Vue），对于不同框架一般我是按照以下规则进行规范的，可有选择性的调整。</p><blockquote><p>小驼峰式命名法 camelCase | lowerCamelCase</p><p>大驼峰式命名法 CamelCase | UpperCamelCase</p><p>蛇形命名法，也称下划线命名法 snake_case | SNAKE_CASE</p><p>串式命名法，也称破折号式、连字符式 kebab-case | dash-case</p></blockquote><h3 id="1-项目组织"><a href="#1-项目组织" class="headerlink" title="1. 项目组织"></a>1. 项目组织</h3><p>ToDo</p><h3 id="2-类、变量、参数"><a href="#2-类、变量、参数" class="headerlink" title="2. 类、变量、参数"></a>2. 类、变量、参数</h3><ul><li>类采用 <code>UpperCamelCase</code> （大驼峰命名）形式。</li><li>接口参数为了序列化一般设计成 <code>snake_case</code> 形式，为了对齐接口参数，变量命名一般也采用 <code>snake_case</code> 形式。如果与后端更习惯于 <code>camelCase</code>，那么接口参数和变量可以统一采用 <code>camelCase</code>。</li><li>（不建议使用）接口参数为 <code>snake_case</code> 形式，变量为 <code>camelCase</code> 形式，这种形式可能需要大量转换命名。</li></ul><h3 id="3-函数、工具"><a href="#3-函数、工具" class="headerlink" title="3. 函数、工具"></a>3. 函数、工具</h3><ul><li>习惯上，为了快速区分 <code>组件</code> 、<code>变量</code> 、<code>参数</code>，函数的命名是 <code>camelCase</code>，如 <code>useColumns</code>、<code>useLocalStorage</code>。</li><li>函数、工具文件、文件夹的命名是 <code>kebab-case</code>形式，如 <code>use-column.ts</code>。</li></ul><h3 id="4-常量、枚举"><a href="#4-常量、枚举" class="headerlink" title="4. 常量、枚举"></a>4. 常量、枚举</h3><ul><li>常量和枚举的命名统一是 <code>SNAKE_CASE</code> 形式。与普通全小写 <code>snake_case</code> 不同，常量和枚举需要采用全大写的 <code>SNAKE_CASE</code> 形式。</li><li>常量和枚举存储文件以 <code>constants.ts</code> 或 <code>enums.ts</code> 命名，存放在各个使用对象的最小父级目录。如果常量和枚举数量极少，可以直接存放在 <code>api</code> 文件内。</li></ul><h3 id="5-组件"><a href="#5-组件" class="headerlink" title="5. 组件"></a>5. 组件</h3><ul><li>文件、文件夹命名格式统一是 <code>kebab-case</code>，即小写字母和短横线(-)的组合，如文件夹 <code>header-search</code> ，文件 <code>modal-form.vue</code>、 <code>modal-form.tsx</code>。</li><li>使用组件时，统一使用 <code>UpperCamelCase</code> 形式。</li><li>props 稍有区分，Vue 偏好于 <code>kebab-case</code>，React 只能用 <code>camelCase</code>。约定优先使用 <code>camelCase</code>。</li></ul><h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import HeaderSearch from &quot;@/components/header-search.vue&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;HeaderSearch :modelValue=&quot;model_value&quot;&gt;&lt;/HeaderSearch&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HeaderSearch</span> <span class="keyword">from</span> <span class="string">&quot;@/components/header-search.tsx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">HeaderSearch</span> <span class="attr">modelValue</span>=<span class="string">&quot;&#123;model_value&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">HeaderSearch</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 约定与规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust: unit 02-数值类型</title>
      <link href="/2023/06/06/Rust-unit-02-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/06/06/Rust-unit-02-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><h3 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1. 数值类型"></a>1. 数值类型</h3><p><a href="https://course.rs/basic/base-type/numbers.html">https://course.rs/basic/base-type/numbers.html</a></p><p>整形类型，默认为 i32，即有符号 32 位。i 有符号，u 无符号，(i|u)size 视架构定。实现 std::cmp::Eq 特征，即完全比较。</p><p>i8, u8, i16, u16, i32, u32, i64, u64, i128, u128, isize, usize</p><p>浮点类型，默认为 f64，即双精度，实现的是 std::cmp::PartialEq 特征，即部分比较。</p><h3 id="2-浮点数陷阱"><a href="#2-浮点数陷阱" class="headerlink" title="2. 浮点数陷阱"></a>2. 浮点数陷阱</h3><p>0.1 + 0.2 !&#x3D; 0.3 在低精度条件下成立，高精度条件下不成立！这是由于二进制无法精确表达 0.2</p><p>f32 条件下 0.1 + 0.2: 3e99999a，0.3: 3e99999a</p><p>f64 条件下 0.1 + 0.2: 3fd3333333333334，0.3: 3fd3333333333333</p><h3 id="3-NaN"><a href="#3-NaN" class="headerlink" title="3. NaN"></a>3. NaN</h3><p>数学上未定义的数值类型，例如对负数取平方根 -42.1.sqrt()，所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较。</p><p>NaN !&#x3D; Nan，不能直接比较，而需要使用 number.is_nan()方法确定。</p><p>let x &#x3D; (-42.0_f32).sqrt(); assert_eq!(x, x);</p><p>相同类型的数字才能进行运算！才能赋值！</p><p>let v: u16 &#x3D; 38_u8 as u16;</p><h3 id="4-Range-序列"><a href="#4-Range-序列" class="headerlink" title="4. Range 序列"></a>4. Range 序列</h3><p>快速生成指定范围的类数值类型，如 1..&#x3D;5，’a’..&#x3D;’z’，序列只允许用于数字或字符类型。</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记：《Vue.js设计与实现》第二章阅读笔记</title>
      <link href="/2023/05/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E3%80%8AVue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/20/%E7%AC%94%E8%AE%B0%EF%BC%9A%E3%80%8AVue-js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree-Shaking"></a>Tree-Shaking</h3><p>在前端的发展历史中，Tree-Shaking 是由 Rollup.js 普及的，Tree-Shaking 的作用是去除运行时未使用或永远不会执行的代码以减少最终构建产物的体积。</p><p>Tree-Shaking 依赖于 ESModule 的静态结构，它的工作流程逻辑概括：未使用的代码不会加入到构建产物中，例如变量、函数。这些未使用的代码有一个名字 <code>dead code</code>，指未使用或者已使用但由于上层条件导致永远不会运行的代码。</p><p>除了 <code>dead code</code>，有一些代码执行了，但对外部没有任何影响也可以进行 Tree-Shaking，比如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj &amp;&amp; obj.<span class="property">foo</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>在这种情况下，由于 JavaScript 是一门动态语言，分析一个函数是否有<strong>副作用</strong>很有难度，比如 obj.foo，看似没有函数执行，但是如果 obj.foo 属性通过 Object.defineProperty 加入了 get 操作捕获或通过 Proxy 代理，就可能在这个捕获操作中发生了副作用，所以 foo 函数会加入到构建产物。</p><p>所以 Rollup.js 等打包工具提供了一个方式，使用 <code>/*#__PURE__*/</code> 明确这个函数是一个不会发生任何副作用的纯函数。</p><p>tips: 在开发的过程中，如果能以纯函数的形式实现，则以纯函数的形式实现。</p><p>一般说来，<code>/*#__PURE__*/</code> 只用在顶级调用中，可以看到如下代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj &amp;&amp; obj.<span class="property">foo</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&quot;foo.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 顶级调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">foo</span>(); <span class="comment">// 函数内调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶级调用是可能发生副作用的，因为执行了 foo 函数。函数内调用也是可能发生副作用的，但是发生的前提是上层条件允许或父函数执行了，否则由于 <code>dead code</code> 的存在，这些代码都会被移除。</p><p>所以只需要控制顶级调用，就能控制大部分无副作用的函数。</p><h3 id="构建不同产物"><a href="#构建不同产物" class="headerlink" title="构建不同产物"></a>构建不同产物</h3><ul><li>IIFE</li><li>esm<ul><li>直接在浏览器中运行 esm-browser</li><li>在打包工具中构建 esm-bundler</li></ul></li><li>cjs</li></ul><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ul><li><a href="https://juejin.cn/post/7235091963312947261">笔记：《Vue.js 设计与实现》第二章阅读笔记 - 掘金 (juejin.cn)</a></li><li><a href="https://blog.csdn.net/qq_45759413/article/details/130782627">笔记：《Vue.js 设计与实现》第二章阅读笔记_一抹阳光&amp;的博客-CSDN 博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Vue.js设计与实现》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端：记录一次unocss+eslint的使用</title>
      <link href="/2023/05/19/%E5%89%8D%E7%AB%AF%EF%BC%9A%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1unocss-eslint%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/05/19/%E5%89%8D%E7%AB%AF%EF%BC%9A%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1unocss-eslint%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="遇到的坑和解决方案"><a href="#遇到的坑和解决方案" class="headerlink" title="遇到的坑和解决方案"></a>遇到的坑和解决方案</h3><p>问题</p><ul><li><code>import &#39;virtual:uno.css&#39;;</code> unresolved 报错</li><li><code>import/unresolved error</code></li></ul><p>解决方案</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;import/no-unresolved&#x27;</span>: [</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">ignore</span>: [<span class="string">&#x27;^virtual:&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eslint-disable-next-line import/no-unresolved</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;virtual:uno.css&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>在原子化 css (<code>Atomic CSS</code>) 的技术选型中，首先考虑的一定是<code>tailwindcss</code>，但截至本文编写日期 (<code>2023-05-19</code>) <code>tailwindcss</code> 还未提供属性写法。</p><p>个人觉得 <code>windicss</code> 的属性写法是最为优雅的，所以准备将项目的 <code>tailwindcss</code> 转到 <code>windicss</code>，但发现 <code>windicss</code> 的更新维护越来越少，所以再经过一番调查后，发现了 <code>unocss</code>。<code>unocss</code> 是由 <code>antfu</code> 发起的一项原子化 css 的项目，可以说是 <code>tailwindcss</code> 等其他原子化 css 的超集，详细请看官网 <a href="https://unocss.dev/">UnoCSS</a></p><p>集成出现的 bug 在上面已经说过，我根据官网配置的 <code>@unocss/eslint-config</code> 完成配置，但是还是出现了 <strong><code>import &#39;virtual:uno.css&#39;;</code> unresolved 报错</strong> 问题，经过上面解决后成功集成。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/425814828">重新构想原子化 CSS - 知乎 (zhihu.com)</a></li><li><a href="https://github.com/unocss/unocss/discussions/2448">import ‘virtual:uno.css’] syntax got unresolved problem? · unocss&#x2F;unocss · Discussion #2448 (github.com)</a></li></ul><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ul><li><a href="https://blog.csdn.net/qq_45759413/article/details/130764781">前端：记录一次 unocss + eslint 的使用_一抹阳光&amp;的博客-CSDN 博客</a></li><li><a href="https://juejin.cn/post/7234718074983743546">前端：记录一次 unocss + eslint 的使用 - 掘金 (juejin.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unocss </tag>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>V2ray: 记录一次公司VPN和V2rayN结合使用的过程</title>
      <link href="/2023/05/06/V2ray-%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%85%AC%E5%8F%B8VPN%E5%92%8CV2rayN%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/05/06/V2ray-%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%85%AC%E5%8F%B8VPN%E5%92%8CV2rayN%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>作为 Google, ChatGPT 的重度用户，拥有访问条件是一定的，如果加上再加一层代理，这个时候应该怎么做呢？</p><p>在公司使用的 VPN 中，设定了访问 <code>10.231.*</code> 的 IP 和 <code>example.com</code> 的公司域名，为了避免公司VPN无法访问，需要给 V2ray 加上规则。</p><p>个人选用的是绕过大陆，配置直连和端口以及公司的域名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outboundTag: direct</span><br><span class="line">port: 0-65535</span><br><span class="line">protocol: http tls</span><br><span class="line">inboundTag: socks http socks2 http2</span><br><span class="line"></span><br><span class="line">domain:cn.bing.com,</span><br><span class="line">domain:r.bing.com,</span><br><span class="line">domain:th.bing.com,</span><br><span class="line">regexp:.*example\.(com|net)$</span><br><span class="line">regixp:10.231.*</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>如上</p>]]></content>
      
      
      <categories>
          
          <category> vpn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> v2ray, 两个vpn结合使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端：记录一次 Vite 引入 Vant 的过程，生产环境不渲染 Vant 组件</title>
      <link href="/2023/05/05/%E5%89%8D%E7%AB%AF%EF%BC%9A%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Vite-%E5%BC%95%E5%85%A5-Vant%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/05/05/%E5%89%8D%E7%AB%AF%EF%BC%9A%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Vite-%E5%BC%95%E5%85%A5-Vant%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>经过前一个步骤引入 Vant 后（<a href="https://azin-cn.github.io/2023/05/03/Bugfix-unplugin-vue-component-%E6%89%BE%E4%B8%8D%E5%88%B0-Vant-%E7%BB%84%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/">Vant 组件的问题 | Az’s Blog (azin-cn.github.io)</a>），在开发环境下使用是正常的，但是当我在 <code>production</code> 环境打包时，又出现了一个新的问题，<code>vue</code> 并没有渲染 <code>vant</code> 组件标签，而是以 <code>van-tabs</code> 的形式出现。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>经过一番排查了对比 <code>Arco Design</code> 的引入方式发现，在 <code>Arco Design</code> 是将所有的组件导出为一个 <code>Vue</code> 插件，最后 <code>app.use(ArcoVue)</code> 实现全局注册组件，通过自定义 <code>unplugin-vue-component</code> <code>Resolver</code>的形式按需引入组件。而在 <code>Vant</code> 的官方文档中，我并未找到有关于系统的配置，文档只是简写了 <code>app.use(Vant)</code> 或使用 <code>unplugin-vue-component</code> 的 <code>VantResolver()</code> 的形式 。</p><ul><li><a href="https://vant-contrib.gitee.io/vant/#/zh-CN/quickstart">快速上手 - Vant 4 (gitee.io)</a></li></ul><p>最终不得已，我按照 <code>Arco Design</code> 的形式在 <code>main.ts</code> 中引入 <code>Vant</code>，我不知道我的做法正不正确，但是这着实解决了我目前的问题。希望有同学可以回答。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vant</span> <span class="keyword">from</span> <span class="string">&quot;vant&quot;</span>;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">Vant</span>);</span><br></pre></td></tr></table></figure><p>在 <code>vite.config.ts</code> 中</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&quot;unplugin-vue-components/vite&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">VantResolver</span> &#125; <span class="keyword">from</span> <span class="string">&quot;unplugin-vue-components/resolvers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line">    <span class="title function_">vueJsx</span>(),</span><br><span class="line">    <span class="title function_">svgLoader</span>(&#123; <span class="attr">svgoConfig</span>: &#123;&#125; &#125;),</span><br><span class="line">    <span class="title function_">configArcoStyleImportPlugin</span>(),</span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [<span class="title class_">VantResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://juejin.cn/post/7229660119658709049/">前端：记录一次 Vite 引入 Vant 的过程，生产环境不渲染 Vant 组件 - 掘金 (juejin.cn)</a></li><li><a href="https://blog.csdn.net/qq_45759413/article/details/130515966">前端：记录一次 Vite 引入 Vant 的过程，生产环境不渲染 Vant 组件_一抹阳光&amp;的博客-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vite, vant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugfix: unplugin-vue-component 找不到 Vant 组件的问题</title>
      <link href="/2023/05/03/Bugfix-unplugin-vue-component-%E6%89%BE%E4%B8%8D%E5%88%B0-Vant-%E7%BB%84%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/03/Bugfix-unplugin-vue-component-%E6%89%BE%E4%B8%8D%E5%88%B0-Vant-%E7%BB%84%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[plugin:vite:import-analysis] Failed to resolve import <span class="string">&quot;vant/es&quot;</span> from x Does the file exist?</span><br><span class="line"></span><br><span class="line">/* unplugin-vue-components disabled */import &#123; Button as __unplugin_components_0 &#125; from <span class="string">&#x27;vant/es&#x27;</span>; import <span class="string">&#x27;vant/es/button/style/index&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>如以上报错信息，<code>vite</code> 找不到 <code>Vant</code> 组件，记录本文时，<code>vant</code> <code>vite</code> <code>unplugin-vue-components</code> 等版本如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;vant&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.2.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;vite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.2.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;unplugin-vue-components&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.24.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Vant</code> 官方文档编写的按需引入方式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&quot;@vitejs/plugin-vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&quot;unplugin-vue-components/vite&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">VantResolver</span> &#125; <span class="keyword">from</span> <span class="string">&quot;unplugin-vue-components/resolvers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [<span class="title class_">VantResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>个人配置如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line">    <span class="title function_">vueJsx</span>(),</span><br><span class="line">    <span class="title function_">svgLoader</span>(&#123; <span class="attr">svgoConfig</span>: &#123;&#125; &#125;),</span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [<span class="title class_">VantResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">find</span>: <span class="string">&quot;@&quot;</span>,</span><br><span class="line">        <span class="attr">replacement</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.js&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">define</span>: &#123;</span><br><span class="line">    <span class="string">&quot;process.env&quot;</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>找了挺久的，最后发现是拓展名的问题，不限制拓展名或者加入 <code>.mjs</code> 拓展名即可解决。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">-   <span class="attr">extensions</span>: [<span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.js&quot;</span>],</span><br><span class="line">+   <span class="attr">extensions</span>: [<span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.mjs&quot;</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://juejin.cn/post/7228888046870102053">Bugfix: unplugin-vue-component 找不到 Vant 组件的问题 - 掘金 (juejin.cn)</a></li><li><a href="https://blog.csdn.net/qq_45759413/article/details/130475645">Bugfix: unplugin-vue-component 找不到 Vant 组件的问题_一抹阳光&amp;的博客-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> unplugin-vue-component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugfix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端：记录一次设置 NODE_ENV=production 后 pnpm install 自动删除 devDependencies 的过程</title>
      <link href="/2023/05/01/%E5%89%8D%E7%AB%AF%EF%BC%9A%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E8%AE%BE%E7%BD%AE-NODE-ENV-production-%E5%90%8E-pnpm-install-%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4-devDependencies-%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/05/01/%E5%89%8D%E7%AB%AF%EF%BC%9A%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E8%AE%BE%E7%BD%AE-NODE-ENV-production-%E5%90%8E-pnpm-install-%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4-devDependencies-%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在 Jenkins Pipeline 中，我为了便于构建生产和开发环境的项目，设置了 NODE_ENV 为参数的参数化构建过程。在构建的过程中，我将 NODE_ENV 设置为 <code>production</code>时， <code>pnpm install</code> 不会安装 <code>devDependencies</code> 并删除所有的 <code>devDependencies</code>。具体可以查看这些文档</p><ul><li><p><a href="https://pnpm.io/zh/cli/install#--prod--p">pnpm install | pnpm</a></p></li><li><p><a href="https://github.com/yarnpkg/yarn/issues/1830"><code>yarn</code> skips dev dependencies if NODE_ENV is set to “production” · Issue #1830 · yarnpkg&#x2F;yarn (github.com)</a></p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>由于设置 NODE_ENV 会导致这个问题，所以在有关于<code>pnpm install | run ...</code> 时，不能直接设置 <code>--mode production</code>。</p><p>个人的 <code>package.json : scripts</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite --config ./config/vite.config.dev.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-tsc --noEmit &amp;&amp; vite build --config ./config/vite.config.prod.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;report&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env REPORT=true npm run build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run build &amp;&amp; vite preview --host&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type:check&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-tsc --noEmit --skipLibCheck&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以在 scripts 中加入 <code>--mode development | production</code>，就能避免 <code>--mode prodution</code> 作用 <code>pnpm</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite --config ./config/vite.config.dev.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-tsc --noEmit &amp;&amp; vite build --config ./config/vite.config.prod.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line">+   <span class="attr">&quot;build:dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-tsc --noEmit &amp;&amp; vite build --config ./config/vite.config.prod.ts --mode development&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;report&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env REPORT=true npm run build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run build &amp;&amp; vite preview --host&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type:check&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-tsc --noEmit --skipLibCheck&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="其他拓展"><a href="#其他拓展" class="headerlink" title="其他拓展"></a>其他拓展</h3><p>升级包最好使用 <code>pnpm update</code>，因为 <code>pnpm add</code> 在升级安装时可能会自动 <code>semver range operator</code> ，如果要避免这种情况，第一个可以使用<code>pnpm add --save-exact, -E &lt;package&gt;</code>，第二种就是 <code>pnpm update &lt;package&gt;</code></p>]]></content>
      
      
      <categories>
          
          <category> pnpm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pnpm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端：记录一次monorepo的改造过程</title>
      <link href="/2023/04/30/%E5%89%8D%E7%AB%AF%EF%BC%9A%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1monorepo%E7%9A%84%E6%94%B9%E9%80%A0%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/04/30/%E5%89%8D%E7%AB%AF%EF%BC%9A%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1monorepo%E7%9A%84%E6%94%B9%E9%80%A0%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="itravel-web"><a href="#itravel-web" class="headerlink" title="itravel-web"></a>itravel-web</h2><p>使用 monorepo 管理项目</p><ul><li>admin</li><li>web</li></ul><h3 id="amin"><a href="#amin" class="headerlink" title="amin"></a>amin</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pnpm admin:dev</span><br><span class="line"></span><br><span class="line">pnpm admin:build</span><br></pre></td></tr></table></figure><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pnpm web:dev</span><br><span class="line"></span><br><span class="line">pnpm web:build</span><br><span class="line"></span><br><span class="line">pnpm web:build:dev</span><br></pre></td></tr></table></figure><h2 id="pnpm-monorepo-改造原有项目记录"><a href="#pnpm-monorepo-改造原有项目记录" class="headerlink" title="pnpm monorepo 改造原有项目记录"></a>pnpm monorepo 改造原有项目记录</h2><p>解决方案</p><ol><li>建立 monorepo 项目文件夹</li><li>pnpm init 初始化项目</li><li>建立 packages 文件夹</li><li>建立 pnpm-workspace.yaml 文件，写入以下内容</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">packages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;packages/**&#x27;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>建立 .npmrc 文件，写入以下内容</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shamefully-hoist=<span class="literal">true</span></span><br><span class="line">strict-peer-dependencies=<span class="literal">false</span></span><br><span class="line">ignore-workspace-root-check=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="6"><li><p>将原有项目复制到 packages，删除原有项目的以下内容<br>a. .git<br>b. .husky<br>c. commitlint.config.js<br>d. .gitignore</p></li><li><p>更改原有项目的 package.json，这一部分的功能是将原有的 git 提交策略删除，最后通过配置 monorepo 仓库的提交策略检查代码规范<br>a. 重命名项目名称 @itravel&#x2F;web<br>b. 删除 prepare script<br>c. 删除 lint-staged script<br>d. 删除 lint-staged 字段属性<br>e. 删除依赖 <code>@commitlint/cli</code>, <code>@commitlint/config-conventional</code>, <code>husky</code>, <code>lint-staged</code></p></li><li><p>git init monorepo 项目，将原有项目的 .gitignore 文件复制到根目录下</p></li><li><p>(可选择)增加 git 提交策略，commitlint 和 lint-staged<br>a. 在 monorepo 项目路径下安装 commitlint 和 lint-staged，-w 表示将依赖写入到根目录的 package.json 中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add -D -w @commitlint/cli @commitlint/config-conventional husky lint-staged</span><br></pre></td></tr></table></figure><p>b. 初始化 husky，出现 .husky 文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky install</span><br></pre></td></tr></table></figure><p>c. 更新 monorepo 项目的 package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prepare&quot;</span><span class="punctuation">:</span> <span class="string">&quot;husky insall&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>d. 将 commitlint 集成到 husky，这一部分是检查 commit 规范。配置 commitlint，根目录创建 commitlint-config.ts，写入以下内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;@commitlint/config-conventional&#x27;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>e. husky 回调 commitlint</p><p>shell 形式创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/commit-msg &quot;npx --no-install commitlint -e $HUSKY_GIT_PARAMS&quot;</span><br></pre></td></tr></table></figure><p>手动在 .husky 文件夹创建 <code>commit-msg</code>，写入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;</span><br><span class="line">npx --no-install commitlint -e $HUSKY_GIT_PARAMS</span><br></pre></td></tr></table></figure><p>f. 将 lint-staged 集成到 husky，这一部分是检查 git staged 缓存区代码的规范，配置 lint-staged，更新根目录的 package.json ，可根据自己的需求，增加写入以下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lint-staged&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx lint-staged&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;*.&#123;js,ts,jsx,tsx&#125;&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;prettier --write&quot;</span><span class="punctuation">,</span> <span class="string">&quot;eslint --fix&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;*.vue&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;stylelint --fix&quot;</span><span class="punctuation">,</span> <span class="string">&quot;prettier --write&quot;</span><span class="punctuation">,</span> <span class="string">&quot;eslint --fix&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;*.&#123;scss,sass,less,css&#125;&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;stylelint --fix --custom-syntax postcss&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;prettier --write&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>g. husky 回调 lint-staged<br>shell 形式创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit &quot;npm run lint-staged&quot;</span><br></pre></td></tr></table></figure><p>手动形式创建，在.husky 文件夹中创建 pre-commit，写入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;</span><br><span class="line">npm run lint-staged</span><br></pre></td></tr></table></figure></li><li><p>更新根目录 package.json，加入快捷启动命令，便能在根目录下直接启动某一个项目，–filter | -F 表示对某一个项目生效</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;admin:dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm --filter @itravel/admin dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;admin:build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm --filter @itravel/admin build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;admin:build:dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm --filter @itravel/admin build:dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;web:dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm --filter @itravel/web dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;web:build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm --filter @itravel/web build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;web:build:dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm --filter @itravel/web build:dev&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>现在一个带有 git 检测的 monorepo 项目就搭建完成了，更多的需求定义可以查看以下文章</p><ul><li><a href="https://juejin.cn/post/7227352009800138789">https://juejin.cn/post/7227352009800138789</a></li><li><a href="https://juejin.cn/post/7071992448511279141">https://juejin.cn/post/7071992448511279141</a></li><li><a href="https://lyh543.github.io/posts/2022-04-18-migrate-npm-multirepo-to-pnpm-monorepo.html">https://lyh543.github.io/posts/2022-04-18-migrate-npm-multirepo-to-pnpm-monorepo.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> monorepo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> monorepo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git pull/git push 每次需要账号密码的解决办法</title>
      <link href="/2023/04/21/git-pull-git-push-%E6%AF%8F%E6%AC%A1%E9%9C%80%E8%A6%81%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2023/04/21/git-pull-git-push-%E6%AF%8F%E6%AC%A1%E9%9C%80%E8%A6%81%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果希望全局使用</p><ol><li><code>git config --global credential.helper store</code></li><li><code>git pull / git push</code></li><li>输入账号密码，下次就可不再输入</li></ol><p>如果希望单个项目使用</p><ol><li><code>git config --local credential.helper store</code>，将 <code>global</code> 改为 <code>local</code> 即可</li><li><code>git pull / git push</code></li><li>输入账号密码，下次就可不再输入</li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记录一次 DTO，Pipe，class-validator 结合使用过程中 class-validator 不生效的原因</title>
      <link href="/2023/03/19/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1-DTO%EF%BC%8CPipe%EF%BC%8Cclass-validator-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD-class-validator-%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2023/03/19/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1-DTO%EF%BC%8CPipe%EF%BC%8Cclass-validator-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD-class-validator-%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p>记录一次 DTO，Pipe，class-validator 结合使用过程中 class-validator 不生效的原因</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>自定义 transform 方法中的 value 是一个来自前端的 <code>json obj</code>，需要将其转换成你用 <code>class-validator</code> 的装饰器修饰的 <code>class</code>，如 class UserDTO 或 class User（用 @IsNotEmpty 装饰器修饰字段&#x2F;类的 class），<strong>只有转换后校验才会生效！</strong> 转换方法：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TransformUserPipe</span> <span class="keyword">implements</span> <span class="title class_">PipeTransform</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">transform</span>(<span class="params">value: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 将来自请求的数据进项转换</span></span><br><span class="line">    value = <span class="title function_">plainToClass</span>(<span class="title class_">UserDTO</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>validate</code> 方法校验数据</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TransformUserPipe</span> <span class="keyword">implements</span> <span class="title class_">PipeTransform</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">transform</span>(<span class="params">value: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 将来自请求的数据进项转换</span></span><br><span class="line">    value = <span class="title function_">plainToClass</span>(<span class="title class_">UserDTO</span>, value);</span><br><span class="line">    <span class="keyword">const</span> errors = <span class="keyword">await</span> <span class="title function_">validate</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (errors.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&#x27;参数错误&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果不生效，检查一下是否加入了全局 或 Control 或 Method 或 参数</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="meta">@UsePipes</span>(<span class="keyword">new</span> <span class="title class_">TransformUserPipe</span>())</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">postUser</span>(<span class="meta">@Body</span>() <span class="attr">user</span>: <span class="title class_">User</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="title function_">create</span>(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">postUser</span>(<span class="meta">@Body</span>(<span class="keyword">new</span> <span class="title class_">TransformUserPipe</span>()) <span class="attr">user</span>: <span class="title class_">User</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">userService</span>.<span class="title function_">create</span>(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>检查一下是否开启了 ValidationPipe</li></ol><p>最好在 main.ts 中开启一下 <code>app.useGlobalPipes(new ValidationPipe());</code>，如果你能保证在每一个接口都能保持需要的数据类型，那么开不开没多大的意义。</p><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><p>因为刚上手 NestJS，对这个不太属性，刚开始我是直接将 DTO 对象(class) 拿到了 Control 层，这也没什么事情能够获取到数据，但是 Control 的各种判断和转换实在难看了，就想着有没有转换管道 Pipe，在查看文档之后发现是有的。</p><p>在查看了一番文档之后，便开始动手改造我的 DTO 和 Control</p><p>首先是 DTO，为了不写 if-else，我选择使用 class-validator 这个库，这个库具有非常丰富的校验装饰器，具体的可以看看 <a href="https://blog.csdn.net/qq_38734862/article/details/117265394">Nest class-validator 验证修饰器中文文档</a></p><p>修改完成之后，我的 DTO 为：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * uuid</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@IsNotEmpty</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;用户ID必须存在&#x27;</span> &#125;)</span><br><span class="line">  <span class="meta">@IsUUID</span>(<span class="literal">undefined</span>, &#123; <span class="attr">message</span>: <span class="string">&#x27;用户ID必须是UUID形式&#x27;</span> &#125;)</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用户名称</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@IsOptional</span>()</span><br><span class="line">  <span class="meta">@IsString</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;用户名必须是字符串！&#x27;</span> &#125;)</span><br><span class="line">  <span class="meta">@Length</span>(<span class="number">6</span>, <span class="number">20</span>, &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;用户名长度必须为 $constraint1 到 $constraint2 之间&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  username?: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用户密码</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@IsOptional</span>()</span><br><span class="line">  <span class="meta">@IsString</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;密码必须是字符串！&#x27;</span> &#125;)</span><br><span class="line">  <span class="meta">@Length</span>(<span class="number">6</span>, <span class="number">20</span>, &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;密码长度必须为 $constraint1 到 $constraint2 之间&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  password?: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，ID 是必须存在的，其他可以为不传。顺便提一句，如果更新的字段值为 undefined，TypeOrm 是不会进行更新的，只有设置空（null）才会更新。</p><p>其次是 Pipe：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TransformUserPipe</span> <span class="keyword">implements</span> <span class="title class_">PipeTransform</span> &#123;</span><br><span class="line">  <span class="comment">// 如果参数名称和原有的一样，那么可以直接使用 ClassTransformerPipe</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">transform</span>(<span class="attr">u</span>: <span class="title class_">Partial</span>&lt;<span class="title class_">UserDTO</span>&gt;): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.<span class="property">id</span> = u.<span class="property">id</span>;</span><br><span class="line">    user.<span class="property">username</span> = u.<span class="property">username</span>;</span><br><span class="line">    user.<span class="property">password</span> = u.<span class="property">password</span>;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉很奇怪，这种怎么会生效，再次查找之后，是需要加上 validate 进行验证，结果 class-validator 还是不生效</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TransformUserPipe</span> <span class="keyword">implements</span> <span class="title class_">PipeTransform</span> &#123;</span><br><span class="line">  <span class="comment">// 如果参数名称和原有的一样，那么可以直接使用 ClassTransformerPipe</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">transform</span>(<span class="attr">u</span>: <span class="title class_">Partial</span>&lt;<span class="title class_">UserDTO</span>&gt;): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 开始校验</span></span><br><span class="line">    <span class="keyword">const</span> errors = <span class="keyword">await</span> <span class="title function_">validate</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (errors.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(<span class="string">&#x27;参数错误&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.<span class="property">id</span> = u.<span class="property">id</span>;</span><br><span class="line">    user.<span class="property">username</span> = u.<span class="property">username</span>;</span><br><span class="line">    user.<span class="property">password</span> = u.<span class="property">password</span>;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次查找之后，发现这个 u 很奇怪，按照道理这阶段是 Pipe，接受的数据应该是前端发过来的 json 数据，是我想当然的将它当成 Partial&lt;UserDTO&gt;了，它并不是一个 <code>class</code>，而是一个 <code>json obj</code>，所以应该使用 Nest.js 提供的 plainToClass 函数进行转换，最后结合校验，完成功能</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TransformUserPipe</span> <span class="keyword">implements</span> <span class="title class_">PipeTransform</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">transform</span>(<span class="attr">u</span>: <span class="title class_">Partial</span>&lt;<span class="title class_">UserDTO</span>&gt;): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 将来自请求的数据进项转换</span></span><br><span class="line">    u = <span class="title function_">plainToClass</span>(<span class="title class_">UserDTO</span>, u);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始校验转换类型后的数据</span></span><br><span class="line">    <span class="keyword">const</span> errors = <span class="keyword">await</span> <span class="title function_">validate</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (errors.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> errMsg = errors</span><br><span class="line">        .<span class="title function_">map</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> constrains = e.<span class="property">constraints</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(constrains).<span class="title function_">join</span>(<span class="string">&#x27;; \n&#x27;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 为避免返回过多数据，限制10条</span></span><br><span class="line">        .<span class="title function_">filter</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> i &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="comment">// 再次格式化换行</span></span><br><span class="line">        .<span class="title function_">join</span>(<span class="string">&#x27;; \n&#x27;</span>);</span><br><span class="line">      <span class="comment">// log</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(errMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.<span class="property">id</span> = u.<span class="property">id</span>;</span><br><span class="line">    user.<span class="property">username</span> = u.<span class="property">username</span>;</span><br><span class="line">    user.<span class="property">password</span> = u.<span class="property">password</span>;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，最好在 main.ts 中开启一下 <code>app.useGlobalPipes(new ValidationPipe());</code>，如果你能保证在每一个接口都能保持需要的数据类型，那么开不开没多大的意义。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://blog.csdn.net/qq_45759413/article/details/129660140">记录一次 DTO，Pipe，class-validator 结合使用过程中 class-validator 不生效的原因 | class-validator 不生效_一抹阳光&amp;的博客-CSDN博客</a></li><li><a href="https://azin-cn.github.io/2023/03/19/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1-DTO%EF%BC%8CPipe%EF%BC%8Cclass-validator-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD-class-validator-%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0/">记录一次 DTO，Pipe，class-validator 结合使用过程中 class-validator 不生效的原因 | Az’s Blog (azin-cn.github.io)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> NestJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NestJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录实习期间的问题：网络的不确定时延</title>
      <link href="/2023/03/10/%E8%AE%B0%E5%BD%95%E5%AE%9E%E4%B9%A0%E6%9C%9F%E9%97%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%97%B6%E5%BB%B6/"/>
      <url>/2023/03/10/%E8%AE%B0%E5%BD%95%E5%AE%9E%E4%B9%A0%E6%9C%9F%E9%97%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%97%B6%E5%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>网络的不确定时延</p>]]></content>
      
      
      <categories>
          
          <category> 有趣的问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习项目 </tag>
            
            <tag> 网络的不确定时延 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript类型体操：获取数组中元素对象属性的值作为新类型</title>
      <link href="/2023/03/03/TypeScript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%9A%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E4%BD%9C%E4%B8%BA%E6%96%B0%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/03/03/TypeScript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%9A%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E4%BD%9C%E4%B8%BA%E6%96%B0%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>首先先说<strong>获取数组中元素对象属性的值作为新类型</strong>的解决方案</p><ul><li>使用 <code>as const</code> 强调不可变数组</li><li>使用 <code>typeof arr</code> 获取数组类型</li><li>使用 <code>[number]</code> 获取数组元素对象类型，这是关键！<code>[number]</code>表示获取数组对象元素类型，数组对象的 <code>key</code> 是 <code>number</code> 类型</li><li>最后指定元素属性 <code>key</code> 即可</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;update&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;delete&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>特别的需要指定 <code>update, delete</code> 作为某一个类型提示</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#x27;delete&#x27; | &#x27;update&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OperationalKey</span> = (<span class="keyword">typeof</span> arr)[<span class="built_in">number</span>][<span class="string">&#x27;key&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><p>遇到一个比较麻烦的问题，个人在项目中使用 <code>TypeScript + Vue</code> 的技术栈，当前的需求是给一个 <code>Action</code> 定义类型以获得类型提示，而这个 <code>Action</code> 内部有一个 <code>key</code> 属性，<code>key</code> 是一个字符串但是我希望仅限于某几个字符串。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;delete&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;update&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onAction</span> = (<span class="params">action: &#123;key: <span class="built_in">string</span>&#125;</span>) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，当我们直接使用 <code>string</code> 作为 <code>key</code> 的类型，我们只能具体看代码有哪些操作符，如果直接在 <code>action: &#123;key: type&#125;</code> 中重新写一遍字符串类型势必麻烦且不好维护，所以如何获取 <code>actions</code> 数组中元素对象的属性的值作为新类型就是我们要解决的问题。</p><p>对于一个对象，我们可以使用 <code>keyof</code> 来取出所有的属性并作为新类型返回，但是我们需要的是属性的值作为新类型，所以某一步操作必然是 <code>[&#39;key&#39;]</code>。</p><p>反过来看数组，如何获取数组元素类型？在经过一番查找后，发现使用 <code>[number]</code> 是符合要求的，<code>JavaScript</code> 的 <code>number</code> 类型索引一般是用户通过 <code>push, unshift</code> 等其他操作加入的数组，这么解释也许不正确，因为JavaScript数组是一个对象，而 <code>JavaScript </code> 的对象的 <code>key</code> 是字符串，详细可以看看  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87">Array - JavaScript | MDN (mozilla.org)</a>，总的来说，通过非负数字访问数组是我们需要的结果，所以<code>[number]</code> 没有任何问题。</p><p>可以获取数组元素对象类型后，还必须要注意一点，数组必须是不可变的，通常用 <code>as const</code> 来修饰，如果数组可变，那么相关元素属性就可变便无法正确获取。</p><h3 id="更好的解决方案"><a href="#更好的解决方案" class="headerlink" title="更好的解决方案"></a>更好的解决方案</h3><p>通常为了避免魔法数字，魔法字符串，也就是很难理解含义的一系列定义，我们会定义一些常量集合来确定，但有些时候觉得麻烦便可使用上述方法来确定类型。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://segmentfault.com/q/1010000040981136">typescript 如何从数组的项中获取某个值作为类型？ - SegmentFault 思否</a></li><li><a href="https://azin-cn.github.io/2023/03/03/TypeScript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%9A%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E4%BD%9C%E4%B8%BA%E6%96%B0%E7%B1%BB%E5%9E%8B/">TypeScript 类型体操：获取数组中元素对象属性的值作为新类型 | Az’s Blog (azin-cn.github.io)</a></li><li><a href="https://blog.csdn.net/qq_45759413/article/details/129327751">TypeScript 类型体操：获取数组中元素对象属性的值作为新类型 | 一抹阳光&amp; - CSDN</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> TypeScript类型体操 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript类型体操 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeError: opts.node.rangeBy is not a function</title>
      <link href="/2023/02/27/TypeError-opts-node-rangeBy-is-not-a-function/"/>
      <url>/2023/02/27/TypeError-opts-node-rangeBy-is-not-a-function/</url>
      
        <content type="html"><![CDATA[<p>今天遇到 <code>TypeError: opts.node.rangeBy is not a function</code> 的问题，网上寻找一番后发现这个解决方案，但是并不适合，因为我的版本已经高于问题版本。</p><h4 id="postcss-版本过高"><a href="#postcss-版本过高" class="headerlink" title="postcss 版本过高"></a>postcss 版本过高</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fix &quot;TypeError: opts.node.rangeBy is not a function&quot; with PostCSS 8.4.4</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/stylelint/stylelint/issues/5766">Fix “TypeError: opts.node.rangeBy is not a function” with PostCSS 8.4.4 · Issue #5766 · stylelint&#x2F;stylelint (github.com)</a></li></ul><h4 id="删除空的style"><a href="#删除空的style" class="headerlink" title="删除空的style"></a>删除空的style</h4><p>根据这个插件往回找，尝试了将空的 <code>&lt;style lang=&quot;less&quot;&gt;</code> 删除，问题解决，这或许是边界判断问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;Share&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="设置stylelint-–custom-syntax-postcss"><a href="#设置stylelint-–custom-syntax-postcss" class="headerlink" title="设置stylelint –custom-syntax postcss"></a>设置stylelint –custom-syntax postcss</h4><p>在使用stylelint时可以选择单独设置less，scss，也可以选择直接用postcss</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;*.&#123;scss,sass&#125;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stylelint --fix --custom-syntax postcss-scss&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;*.less&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stylelint --fix --custom-syntax postcss-less&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="attr">&quot;*.&#123;scss,sass,less,css&#125;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stylelint --fix --custom-syntax postcss&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p><a href="https://blog.csdn.net/qq_45759413/article/details/129261144">Fix TypeError: opts.node.rangeBy is not a function_一抹阳光&amp;-CSDN博客</a></p></li><li><p><a href="https://azin-cn.github.io/2023/02/27/TypeError-opts-node-rangeBy-is-not-a-function/">TypeError: opts.node.rangeBy is not a function | Az’s Blog (azin-cn.github.io)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Stylelint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postcss </tag>
            
            <tag> stylelint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 无重复字符的最长子串 | 字符串搜索 | Map | 哈希</title>
      <link href="/2023/02/19/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2-Map-%E5%93%88%E5%B8%8C/"/>
      <url>/2023/02/19/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2-Map-%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环<br> 定义两个 <code>for</code>，第一个 <code>for</code> 顺序遍历，第二个 <code>for</code> 每次从头开始顺序检查，这样即可拿到最长长度，时间复杂度为 <code>O(n^2)</code>。</li><li>map 结构<br> 定义一个 <code>while</code>，利用一个 <code>map</code> 记录遍历到的字符，利用内部 <code>while</code> 进行检查是否有重复字符</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = <span class="number">0</span>, res = <span class="number">0</span>, len = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        <span class="keyword">let</span> char = s[r++], count = (map.<span class="title function_">get</span>(char) || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        map.<span class="title function_">set</span>(char, count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (map.<span class="title function_">get</span>(char) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> left = s[l++]</span><br><span class="line">            map.<span class="title function_">set</span>(left, map.<span class="title function_">get</span>(left) - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, r - l); <span class="comment">// 此时的r属于后一位，不需要+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://blog.csdn.net/qq_45759413/article/details/129108885">3. 无重复字符的最长子串 | 字符串搜索 | Map | 哈希_一抹阳光&amp;的博客-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. 两数相加 | 链表 | 链表长度 | 等价链表长度</title>
      <link href="/2023/02/13/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6-%E7%AD%89%E4%BB%B7%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6/"/>
      <url>/2023/02/13/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6-%E7%AD%89%E4%BB%B7%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>总体上可以分为两类，迭代和递归</p><ol><li>迭代<br>迭代链表在边界判断上具有许多方式，这里选择将两条链表看成是<strong>相等长度</strong>的，利用两个变量，<code>dummy</code>，<code>p</code> 记录节点位置，在内部实现保证迭代不出错即可<ul><li>将两条链表视为相等长度，但是实际过程中，需要判断链表是否已经遍历到头，也就是两个 <code>if</code></li><li>两条链表对应节点的 <code>val</code> 相加后再次存入</li><li>两个 <code>if</code> 保证其链表不会遍历出错，而 <code>dummy</code>，<code>p</code> 记录对应的节点，最终如果有 <code>carry</code> 则新建 <code>node</code> 节点</li><li>理解 <code>while</code> 和 两个 <code>if</code> 之间的转换</li></ul></li><li>递归<br>待完善</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTwoNumbers</span>(<span class="params">l1: ListNode | <span class="literal">null</span>, l2: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    <span class="keyword">if</span> (l1 === <span class="literal">null</span> &amp;&amp; l2 === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p1 = l1, p2 = l2, <span class="attr">dummy</span>: <span class="title class_">ListNode</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(), <span class="attr">p</span>: <span class="title class_">ListNode</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 !== <span class="literal">null</span> || p2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n1 = p1 === <span class="literal">null</span> ? <span class="number">0</span> : p1.<span class="property">val</span>;</span><br><span class="line">        <span class="keyword">const</span> n2 = p2 === <span class="literal">null</span> ? <span class="number">0</span> : p2.<span class="property">val</span>;</span><br><span class="line">        <span class="keyword">const</span> num = n1 + n2 + carry;</span><br><span class="line">        carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num / <span class="number">10</span>); <span class="comment">// JavaScript不是整除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实际过程中判断链表是否遍历到头，在遍历的过程中更新头节点和尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (p1 !== <span class="literal">null</span>) &#123;</span><br><span class="line">            dummy.<span class="property">next</span> = l1;</span><br><span class="line">            p = p1</span><br><span class="line">            p1.<span class="property">val</span> = num % <span class="number">10</span>;</span><br><span class="line">            p1 = p1.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">            dummy.<span class="property">next</span> = l2;</span><br><span class="line">            p = p2;</span><br><span class="line">            p2.<span class="property">val</span> = num % <span class="number">10</span>;</span><br><span class="line">            p2 = p2.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (carry !== <span class="number">0</span>) &#123;</span><br><span class="line">        p.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://blog.csdn.net/qq_45759413/article/details/129095739?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22129095739%22,%22source%22:%22qq_45759413%22%7D">2. 两数相加 | 链表长度_一抹阳光&amp;的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.两数之和 - Hash | 查找元素</title>
      <link href="/2023/01/07/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/01/07/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/two-sum/description/">1.两数之和</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li><p>暴力 for</p></li><li><p>查找时间为 <code>O(1)</code> 的 Hash，包括 Set 和 Map</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">twoSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> num = target - nums[i];</span><br><span class="line">    <span class="keyword">if</span>(map.<span class="title function_">has</span>(num)) &#123;</span><br><span class="line">      <span class="keyword">return</span> [map.<span class="title function_">get</span>(num), i];</span><br><span class="line">    &#125;</span><br><span class="line">    map.<span class="title function_">set</span>(nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25. K 个一组翻转链表 | 链表 | 递归 | 子问题分解</title>
      <link href="/2022/09/29/25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92-%E5%AD%90%E9%97%AE%E9%A2%98%E5%88%86%E8%A7%A3/"/>
      <url>/2022/09/29/25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92-%E5%AD%90%E9%97%AE%E9%A2%98%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>直接实现反转K个一组翻转链表可能非常困难，但是可以分成长度为K的子串，每一个字串分别反转并拼接，最后返回即可。</p><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>反转链表很容易实现，可以通过<strong>递归&#x2F;迭代</strong>的形式实现。<br>这里采用的是判断 递归 + 是否为null为basecase 实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span> || head.<span class="property">next</span> === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">const</span> prev = <span class="title function_">reverse</span>(head.<span class="property">next</span>);</span><br><span class="line">    head.<span class="property">next</span>.<span class="property">next</span> = head;</span><br><span class="line">    head.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转K个"><a href="#反转K个" class="headerlink" title="反转K个"></a>反转K个</h4><p>分析可以发现，整体的过程就可以分解成长度为 <code>K</code> 的部分字串，所以明显可以使用递归来实现。</p><ul><li>遍历当前的链表，如果<strong>长度不足 <code>k</code><strong>，则直接返回头节点，这里需要</strong>注意</strong>的是 <code>if</code> 判断条件需要放在p.next前还是后的问题</li><li>保留后驱节点以及设置满足反转的basecase，即记录 <code>successor</code> 和设置 <code>p.next = null</code></li><li>反转当前长度为 <code>k</code> 的字串，得到新的头节点</li><li>拼接 <code>当前的最新尾节点</code> 和 <strong><code>下一个</code></strong><code>最新的头节点</code></li><li>返回最新的头节点</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  理解题意：每隔K个就反转当前的短链表，不足K个则不反转</span></span><br><span class="line"><span class="comment">// 从理解提议中可以看出，每个K个就反转，不足K个不反转，可以使用子问题的方式，也就是可以使用递归</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseKGroup</span>(<span class="params">head: ListNode | <span class="literal">null</span>, k: <span class="built_in">number</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; k; i++) &#123; <span class="comment">// 从1开始算</span></span><br><span class="line">        p = p.<span class="property">next</span>; <span class="comment">// 进行迭代</span></span><br><span class="line">        <span class="keyword">if</span> (p === <span class="literal">null</span>) <span class="keyword">return</span> head; <span class="comment">// 如果不足k个，直接返回当前的头节点，注意放在前面和放在后面的不同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下的过程表示需要反转当前的部分链表</span></span><br><span class="line">    <span class="keyword">let</span> successor = p.<span class="property">next</span>; <span class="comment">// 保留后驱节点</span></span><br><span class="line">    p.<span class="property">next</span> = <span class="literal">null</span>; <span class="comment">// 为了形成basecase，切断next指针，使其指向null</span></span><br><span class="line">    <span class="keyword">const</span> newHead = <span class="title function_">reverse</span>(head); <span class="comment">// 开始反转得到新头节点</span></span><br><span class="line">    head.<span class="property">next</span> = <span class="title function_">reverseKGroup</span>(successor, k); <span class="comment">// 最新的尾节点拼接下一个最新的头节点</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span> || head.<span class="property">next</span> === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">const</span> prev = <span class="title function_">reverse</span>(head.<span class="property">next</span>);</span><br><span class="line">    head.<span class="property">next</span>.<span class="property">next</span> = head;</span><br><span class="line">    head.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://blog.csdn.net/qq_45759413/article/details/127113946?spm=1001.2014.3001.5502">CSDN：25. K 个一组翻转链表 | 链表 | 递归 | 子问题分解_一抹阳光&amp;的博客</a></p><p><a href="https://juejin.cn/post/7148785599401426958">掘金：25. K 个一组翻转链表 | 链表 | 递归 | 子问题分解</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Chic添加iconfont失败的临时解决方案</title>
      <link href="/2022/07/26/Hexo-Theme-Chic%E6%B7%BB%E5%8A%A0iconfont%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%B8%B4%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/07/26/Hexo-Theme-Chic%E6%B7%BB%E5%8A%A0iconfont%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%B8%B4%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>在Chic的issue中提到了很多自定义icon的解决方案，但是在2022&#x2F;07&#x2F;26查看时，有关于icon的解决方案都被删除了。</p><ul><li><p>问题：主页中自定义icon图标，在style.styl中@import “…” 加载失败，加载iconfont字体未404，还未找到原因。</p></li><li><p>解决方案：如果不嫌麻烦，直接在themes&#x2F;Chic&#x2F;Chic&#x2F;layout&#x2F;_partial&#x2F;head.ejs中加入 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/fonts/custom/iconfont.css&quot;&gt;</code> 直接加载即可，注意位置，themes&#x2F;Chic&#x2F;source&#x2F;fonts会被编译加载到public目录下。</p></li></ul><h3 id="Chic目录结构"><a href="#Chic目录结构" class="headerlink" title="Chic目录结构"></a>Chic目录结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├─languages</span><br><span class="line">├─layout</span><br><span class="line">│  ├─_page</span><br><span class="line">│  ├─_partial</span><br><span class="line">│  └─_plugins</span><br><span class="line">├─scripts</span><br><span class="line">└─source</span><br><span class="line">    ├─css</span><br><span class="line">    │  ├─_highlight</span><br><span class="line">    │  ├─_lib</span><br><span class="line">    │  ├─_page</span><br><span class="line">    │  │  └─_post</span><br><span class="line">    │  └─_partial</span><br><span class="line">    ├─fonts</span><br><span class="line">    │  ├─custom</span><br><span class="line">    │  ├─iconfont</span><br><span class="line">    │  └─lanting</span><br><span class="line">    └─js</span><br></pre></td></tr></table></figure><p> <code>source</code> 文件夹内的所有的内容都会被编译打包到项目根目录下的 <code>public</code> 文件夹。</p><p>加入 stylesheet 示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%# css list %&gt;</span><br><span class="line">&lt;% if (theme.stylesheets !== undefined &amp;&amp; theme.stylesheets.length &gt; 0) &#123; %&gt;</span><br><span class="line">    &lt;!-- stylesheets list from _config.yml --&gt;</span><br><span class="line">    &lt;% theme.stylesheets.forEach(url =&gt; &#123; %&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- url_for(url) %&gt;&quot;&gt;</span><br><span class="line">    &lt;% &#125;); %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%# 新增 %&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/fonts/custom/iconfont.css&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Chic </tag>
            
            <tag> Hexo </tag>
            
            <tag> iconfont </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/26/hello-world/"/>
      <url>/2022/07/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
