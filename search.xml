<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>三. 浏览器内部工作原理-解析方向</title>
      <link href="/2022/09/06/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E6%80%BB%EF%BC%89/"/>
      <url>/2022/09/06/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E6%80%BB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为方便读者阅读，贴出以下参考链接，在此感谢前辈笔记。</p><p>浏览器解析过程分析：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>浏览器工作过程分析：<a href="https://zhuanlan.zhihu.com/p/96986818">万字详文：深入理解浏览器原理 - 知乎 (zhihu.com)</a></p><h2 id="1-树的构建流程"><a href="#1-树的构建流程" class="headerlink" title="1. 树的构建流程"></a>1. 树的构建流程</h2><p><img src="/assets/image-20220902091918-3jgz0jo.png" alt="image.png"></p><p>HTML 和 CSS 的页面解析是从上之下的，<strong>线程的</strong>。文档流从上往下，若先碰到了 CSS，那么开始解析，接着<strong>不被阻塞的</strong>继续向下解析 HTML，这样既符合并行解析，又符合文档流自上往下解析规则。浏览器先下载 HTML 文件开始解析，遇到 CSS 标签就开始下载 CSS 并解析，这个过程不会阻塞 DOM 的构建。最后 DOM 树和 CSS 规则树生成渲染树，HTML 解析完成。</p><p>注意几点：</p><ol><li>CSS 加载不会阻塞 DOM 树的<strong>解析</strong></li><li>CSS 加载会阻塞 DOM 树的<strong>渲染</strong>（不阻塞解析），即合并成渲染树的过程，因为样式可能会导致重排重绘</li><li>CSS 加载会阻塞后面 JS 语句的执行</li></ol><p>解析、渲染这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时还可能通过网络下载其余内容。</p><h3 id="1-1-HTML-Parser"><a href="#1-1-HTML-Parser" class="headerlink" title="1.1 HTML Parser"></a>1.1 HTML Parser</h3><h4 id="1-1-1-解析"><a href="#1-1-1-解析" class="headerlink" title="1.1.1 解析"></a>1.1.1 解析</h4><p>解析的目的是：将文档转换为具有一定意义的结构，编码时可以理解和使用的东西。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。</p><blockquote><p>解析的目的在于让目标更接近于需要使用的形式，或更具体的描述一些信息。如高级语言先转换为汇编等低级语言，最后再转换成机器码，又或者是家具的运输与组装，零件形式更接近于运输模式，成品形式更接近于使用模式，由成品拆分成零件就是使其更接近于运输模式，同样的道理将文档解析成另外一个格式会更适合某一个场景的使用。</p></blockquote><p>如解析“2＋3－1”这个表达式，可能返回这样一棵树。</p><p><img src="/assets/image-20220902121038-5xudoir.png" alt="image.png"></p><p>解析过程与翻译过程类似，需要具备两个条件，字典和语法规则。</p><p><strong>文法（Grammars）</strong>：解析基于文档依据的语法规则——文档的语言或格式。每种可被解析的格式必须具有由词汇及语法规则组成的特定的文法，称为上下文无关文法。简单来说就是由词汇表、语法规则组成的对某一个格式的限制，与当前文件内容无关。</p><blockquote><p>文法不等于语法规则，文法是词汇表和语法规则的结合，如语法规则定义为“<strong>的</strong>字后面跟着表示事物的名词，<strong>地</strong>字跟在动词后面，<strong>得</strong>字后面跟着形容词”，词汇表则有“谁，得，的，地，花，走，快”，文法规则就是词汇表和语法规则的结合，包含任何一个可能选择，如“谁的花，走得快，的，得，地”等。</p></blockquote><p>解析可以分成两个子过程：</p><ul><li>词法分析</li><li>语法分析</li></ul><p><strong>词法分析</strong>是将文档中的字词按照一定地规则（词汇表）分成符号，符号对应的便是词汇表（基本有效单元的集合）中的某一项。对于人类语言来说，它相当于我们字典中出现的所有单词。</p><p><strong>语法分析</strong>是根据语法规则匹配词法分析后的符号，生成特定状态的过程。</p><p>词法分析器（有时也叫分词器）负责将输入分解为合法的符号，语法分析器则根据语言的语法规则分析文档结构，从而构建解析树，词法分析器知道怎么跳过空白和换行之类的无关字符。</p><p><img src="/assets/image-20220902133652-u2je5s2.png" alt="image.png"></p><p>解析过程是<strong>迭代的</strong>，语法分析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后语法分析器分析下一个符号。如果没有匹配到规则，语法分析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</p><blockquote><p>词法分析器和语法分析器的工作是同步的，正如组装家具时，找到一个一个零件，根据说明书进行组装，如果没有找齐零件，是无法组装某一个个体的。</p></blockquote><h4 id="1-1-2-转换"><a href="#1-1-2-转换" class="headerlink" title="1.1.2 转换"></a>1.1.2 转换</h4><p>转换对工作人员来说是一个隐式的过程，正如在浏览器开发者控制台运行一些代码、打印日志信息一样，开发者可能感受不到转换到机器码的过程。但是编写的源代码并不是最终的目标，底层机器码才是机器识别、运行的格式。</p><p>很多时候，解析树并不是最终结果。解析一般在转换中使用——将输入文档转换为另一种格式。编译就是个例子，编译器在将一段源码编译为机器码的时候，先将源码解析为解析树，然后将该树转换为一个机器码文档。</p><p>简单来说<strong>转换</strong>过程在编译运行时就存在，将源代码转换为机器码，转换时是无感的。</p><p><img src="/assets/image-20220902140802-boi3thw.png" alt="image.png"></p><p>详细的例子可以看看：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>，如不熟悉抽象语法树的概念，可以看看：<a href="https://juejin.cn/post/6844904035271573511">手把手带你入门 AST 抽象语法树 - 掘金 (juejin.cn)</a>。</p><h4 id="1-1-3-深入"><a href="#1-1-3-深入" class="headerlink" title="1.1.3 深入"></a>1.1.3 深入</h4><p><strong>HTML解析器（HTML Parser）：</strong>HTML解析器的工作是将html标识解析为解析树。</p><p><strong>HTML文法定义（The HTML grammar definition）：</strong>W3C组织制定规范定义了HTML的词汇表和语法。</p><p><strong>非上下文无关文法（Not a context free grammar）：</strong>正如在解析简介中提到的，上下文无关文法的语法可以用类似BNF的格式来定义。</p><blockquote><p>HTML 有一个正式的格式定义—— DTD（Document Type Definition文档类型定义），但它并不是上下文无关文法，HTML 更接近于 XML，现在有很多可用的xml 解析器，html 有个 xml 的变体——xhtml，不同在于 html 更宽容，它允许忽略一些特定标签，有时可以省略开始或结束标签。总的来说，它是一种 soft 语法，不像 xml 呆板、固执。</p><p>显然，这个看起来很小的差异却带来了很大的不同。一方面，这是 html 流行的原因——它的宽容使 web 开发人员的工作更加轻松，但另一方面，这也使很难去写一个格式化的文法。所以，html 的解析并不简单，它既不能用传统的解析器解析，也不能用 xml 解析器解析。</p></blockquote><p><strong>HTML DTD</strong></p><p>html 适用 DTD 格式进行定义，这一格式是用于定义 SGML 家族的语言，包括了对所有允许元素及它们的属性和层次关系的定义。正如前面提到的，html DTD 并没有生成一种上下文无关文法。DTD 有一些变种，标准模式只遵守规范，而其他模式则包含了对浏览器过去所使用标签的支持，这么做是为了兼容以前内容。最新的标准 DTD 在<a href="http://www.w3.org/TR/html4/strict.dtd">http://www.w3.org/TR/html4/strict.dtd</a>。</p><p><strong>DOM</strong></p><p>解析输出的树也就是解析树，是由 DOM 元素及属性节点组成的。DOM 是文档对象模型的缩写，它是 html 文档的对象表示，作为 html 元素的外部接口供 JS 等调用。DOM 和标签基本是一一对应的关系。</p><p><strong>解析器类型（Types of parsers）</strong></p><p>有两种基本的解析器——自顶向下解析及自底向上解析。比较直观的解释是，自顶向下解析，查看语法的最高层结构并试着匹配其中一个；自底向上解析则从输入开始，逐步将其转换为语法规则，从底层规则开始直到匹配高层规则。</p><p>来看一下这两种解析器如何解析 “2+3-1” 的例子：<strong>自顶向下</strong>解析器从最高层规则开始——它先识别出“2+3”，将其视为一个表达式，然后识别出 “2+3-1” 为一个表达式（识别表达式的过程中匹配了其他规则，但出发点是最高层规则）。<strong>自底向上</strong>解析会扫描输入直到匹配了一条规则，然后用该规则取代匹配的输入，直到解析完所有输入。部分匹配的表达式被放置在解析堆栈中。</p><p>自顶向下与递归过程类似，从整体开始逐步检查子问题，而自底向上与递推过程类似，从子问题开始推向整体。</p><p><strong>自动化解析（Generating parsers automatically）</strong></p><p>解析器生成器这个工具可以自动生成解析器，只需要指定语言的文法——词汇表及语法规则，它就可以生成一个解析器。创建一个解析器需要对解析有深入的理解，而且手动的创建一个由较好性能的解析器并不容易，所以解析生成器很有用。Webkit使用两个知名的解析生成器——<strong>用于创建语法分析器的Flex</strong>及<strong>创建解析器的Bison</strong>（你可能接触过Lex和Yacc）。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p><p>稍微总结：HTML 解析器按照 HTML DTD 文法定义进行 HTML 解析，可以认为解析生成的 DOM 树与解析树一一映射，DOM 树就是解析树。</p><h4 id="1-1-4-解析算法"><a href="#1-1-4-解析算法" class="headerlink" title="1.1.4 解析算法"></a>1.1.4 解析算法</h4><p>HTML 不能被一般的自顶向下或自底向上的解析器所解析，不能使用正则解析技术，浏览器为 HTML 定制了专属的解析器，原因是：</p><ol><li>这门语言本身的宽容特性</li><li>浏览器对一些常见的非法html有容错机制</li><li>解析过程是往复的，通常源码不会在解析过程中发生改变，但在 HTML 中，脚本标签包含的 “document.write” 可能添加标签，这说明在解析过程中实际上修改了输入，所以不能使用正则解析技术</li></ol><p>HTML5 规范中描述了这个解析算法，算法包括两个阶段——符号化及构建树。</p><p>符号化是<strong>词法分析</strong>的过程，将输入解析为符号，HTML 的符号包括开始标签、结束标签、属性名及属性值。符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，以识别下一个符号，直到处理完所有输入。</p><p><strong>符号识别算法（The tokenization algorithm）</strong></p><p>算法输出 HTML 符号，该算法用状态机表示。每次读取输入流中的一个或多个字符，并根据这些字符转移到下一个状态，当前的符号状态及构建树状态共同影响结果，这意味着，读取同样的字符，可能因为当前状态的不同，得到不同的结果以进入下一个正确的状态。</p><p>这个算法很复杂，这里用一个简单的例子来解释这个原理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello world</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>初始状态为“Data State”，当遇到“&lt;”字符，状态变为“Tag open state”，读取一个a－z的字符将产生一个开始标签符号，状态相应变为“Tag name state”，一直保持这个状态直到读取到“&gt;”，每个字符都附加到这个符号名上，例子中创建的是一个html符号。</p><p>当读取到“&gt;”，当前的符号就完成了，此时状态回到“Data state”，“\body&gt;”重复这一处理过程。到这里，html和body标签都识别出来了。现在，回到“Data state”，读取“Hello world”中的字符“H”将创建并识别出一个字符符号，这里会<strong>为“Hello world”中的每个字符生成一个字符符号</strong>。</p><p>这样直到遇到“&lt;&#x2F;body&gt;”中的“&lt;”。现在，又回到了“Tag open state”，读取下一个字符“/”将创建一个闭合标签符号，并且状态转移到“Tag name state”，还是保持这一状态，直到遇到“&gt;”。然后，产生一个新的标签符号并回到“Data state”。后面的“&lt;&#x2F;html&gt;”将和“&lt;&#x2F;body&gt;”一样处理。</p><p><img src="/assets/image-20220903152441-lnzo21q.png" alt="image.png"></p><p><strong>简单总结：</strong>因为 HTML 符号包括开始标签、结束标签、属性名及属性值，所以解析每一个符号都需要三个状态来决定。状态机+符号化+树构建器。<strong>符号并不仅仅只是一个字符</strong>，可以是标签符号包括标签名、属性等，除标签符号外，为每一个内容字符创建一个字符符号（Data State）。</p><p><strong>树的构建算法（Tree construction algorithm）</strong></p><p>在树的构建阶段，将<strong>修改</strong>以Document为根的DOM树，将元素附加到树上。每个由符号识别器识别生成的节点将会被树构造器进行处理，规范中定义了每个符号相对应的Dom元素，<strong>对应的Dom元素将会被创建</strong>。这些元素除了会被添加到Dom树上，还将被添加到开放元素堆栈中。这个堆栈用来纠正嵌套的未匹配和未闭合标签，这个算法也是用状态机来描述，所有的状态采用插入模式。</p><p>首先是“initial mode”，接收到html符号后将转换为“before html”模式，在这个模式中对这个符号进行再处理。此时，创建了一个HTMLHtmlElement元素，并将其附加到根Document对象上。</p><p>状态此时变为“before head”，接收到body符号时，即使这里没有head符号，也将自动创建一个HTMLHeadElement元素并附加到树上。</p><p>现在，转到“in head”模式，然后是“after head”。到这里，body符号会被再次处理，将创建一个HTMLBodyElement并插入到树中，同时，转移到“in body”模式。</p><p>然后，接收到字符串“Hello world”的字符符号，第一个字符将导致创建并插入一个text节点，其他字符将附加到该节点。</p><p>接收到body结束符号时，转移到“after body”模式，接着接收到html结束符号，这个符号意味着转移到了“after after body”模式，当接收到文件结束符时，整个解析过程结束。</p><p><img src="/assets/image-20220903152422-pm7uawo.png" alt="image.png"></p><p><strong>简单总结：</strong>树构建器根据符号创建对应的DOM元素，附加到以Document为根的DOM树上，并对一些常见的 HTML 错误进行处理。</p><h4 id="1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）"><a href="#1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）" class="headerlink" title="1.1.5 解析结束时的处理（Action when the parsing is finished）"></a>1.1.5 解析结束时的处理（Action when the parsing is finished）</h4><p>在这个阶段，浏览器将文档标记为可交互的，并开始解析处于延时模式中的脚本——这些脚本在文档解析后执行。文档状态将被设置为完成，同时触发一个 <strong>load</strong> 事件。</p><p>HTML5 规范中有符号化及构建树的完整算法：<a href="http://www.w3.org/TR/html5/syntax.html#html-parser">链接</a>。</p><h4 id="1-1-6-浏览器容错（Browsers-error-tolerance）"><a href="#1-1-6-浏览器容错（Browsers-error-tolerance）" class="headerlink" title="1.1.6 浏览器容错（Browsers error tolerance）"></a>1.1.6 浏览器容错（Browsers error tolerance）</h4><p>详细可查看原文：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><h3 id="1-2-CSS-Parser"><a href="#1-2-CSS-Parser" class="headerlink" title="1.2 CSS Parser"></a>1.2 CSS Parser</h3><p>CSS 的加载并不会阻塞 DOM 的解析，但是会阻塞 DOM 的渲染。因为加载 CSS 时，可能会修改当前解析位置以后的 DOM 节点的样式，如果 CSS 加载不阻塞 DOM 树渲染，那么当 CSS 加载完之后，DOM 树可能又得重新重排 layout（回流reflow）或者重绘了，这就造成了一些没有必要的损耗。</p><p>不同于HTML，CSS属于上下文无关文法，可以用前面所描述的解析器来解析。CSS规范定义了CSS的词法及语法文法。可以参考词汇表和语法规则：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>。</p><p>每个符号都由正则表达式定义了词法文法（词汇表）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comment<span class="comment">///*[^*]*/*+([^/*][^*]*/*+)*//</span></span><br><span class="line">num[<span class="number">0</span>-<span class="number">9</span>]+|[<span class="number">0</span>-<span class="number">9</span>]*<span class="string">&quot;.&quot;</span>[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">nonascii[<span class="regexp">/200-/</span><span class="number">377</span>]</span><br><span class="line">nmstart[_a-z]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">nmchar[_a-z0-<span class="number">9</span>-]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">name&#123;nmchar&#125;+</span><br><span class="line">ident&#123;nmstart&#125;&#123;nmchar&#125;*</span><br></pre></td></tr></table></figure><p>“ident”是识别器的缩写，相当于一个class名，“name”是一个元素id（用“＃”引用）。</p><p>语法用BNF进行描述：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">: selector [ <span class="string">&#x27;,&#x27;</span> S* selector ]*</span><br><span class="line"><span class="string">&#x27;&#123;&#x27;</span> S* declaration [ <span class="string">&#x27;;&#x27;</span> S* declaration ]* <span class="string">&#x27;&#125;&#x27;</span> S*</span><br><span class="line">;</span><br><span class="line">selector</span><br><span class="line">: simple_selector [ combinator selector | S+ [ combinator selector ] ]</span><br><span class="line">;</span><br><span class="line"><span class="keyword">class</span></span><br><span class="line">: <span class="string">&#x27;.&#x27;</span> <span class="variable constant_">IDENT</span></span><br><span class="line">;</span><br><span class="line">element_name</span><br><span class="line">: <span class="variable constant_">IDENT</span> | <span class="string">&#x27;*&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>一个规则集合具有一个或是可选个数的多个选择器，这些选择器以逗号和空格（S表示空格）进行分隔。每个规则集合包含大括号及大括号中的一条或多条以分号隔开的声明。声明和选择器在后面进行定义。</p><h4 id="1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）"><a href="#1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）" class="headerlink" title="1.2.1 Webkit CSS解析器（Webkit CSS parser）"></a>1.2.1 Webkit CSS解析器（Webkit CSS parser）</h4><p>Webkit使用Flex和Bison解析生成器从CSS语法文件中自动生成解析器。回忆一下解析器的介绍，Bison创建一个自底向上的解析器，Firefox使用自顶向下解析器。它们都是将每个css文件解析为样式表对象，每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。</p><blockquote><p>用于创建语法分析器的Flex及创建解析器的Bison。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p></blockquote><p><img src="/assets/image-20220903160338-wjh6j4x.png" alt="image.png"></p><p>注意：WebKit使用的是自底向上的解析器</p><blockquote><p>处理脚本及样式表的顺序（The order of processing scripts and style sheets）</p><p>脚本：web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。HTML5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。</p><p>async是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行；而Defer是在JS加载完成后，整个文档解析完成后执行。 Defer更像是将&lt;script&gt;标签放在&lt;&#x2F;body&gt;之后的效果，但是它由于是异步加载JS文件，所以可以节省时间。简单来说就是async和defer都是开启新线程（http线程）请求JS文件，和解析DOM并行不冲突，async在请求完成后就开始执行JS文件，而defer则是在整个DOM解析完成后再执行JS文件。</p><p>预解析（Speculative parsing）</p><p>Webkit和Firefox都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变Dom树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p></blockquote><p>StyleSheets样式表采用另一种模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。</p><p><strong>简单总结：</strong>WebKit用Flex生成CSS语法规则，Bison生成CSS解析器。样式表不阻塞DOM解析，但是阻塞DOM渲染，FireFox在样式文件未加载完成前阻塞JS脚本，目的是防止样式文件未加载完成而JS脚本需要获取样式文件信息的错误，Chrome只阻塞那些访问未加载完成的样式文件的JS脚本，样式加载完成即不堵塞。</p><h3 id="1-3-Render-Tree"><a href="#1-3-Render-Tree" class="headerlink" title="1.3 Render Tree"></a>1.3 Render Tree</h3><h4 id="1-3-1-渲染树的定义"><a href="#1-3-1-渲染树的定义" class="headerlink" title="1.3.1 渲染树的定义"></a>1.3.1 渲染树的定义</h4><p>当Dom树构建完成时，浏览器开始构建另一棵树——渲染树。渲染树由元素显示序列中的可见元素组成，它是文档的可视化表示，构建这棵树是为了以正确的顺序绘制文档内容。</p><p>Firefox将渲染树中的元素称为frames，WebKit则用renderer或渲染对象来描述这些元素.一个渲染对象知道怎么布局及绘制自己及它的 children？</p><p>RenderObject是Webkit的渲染对象基类，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RenderObject</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">layout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(PaintInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> rect <span class="title">repaintRect</span><span class="params">()</span></span>;</span><br><span class="line">    Node* node;<span class="comment">//the DOM node</span></span><br><span class="line">    RenderStyle* style;<span class="comment">// the computed style</span></span><br><span class="line">    RenderLayer* containgLayer; <span class="comment">//the containing z-index layer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个渲染节点对象用一个和该节点 CSS 盒模型相对应的矩形区域来表示，正如 CSS2 所描述的那样，它包含诸如宽、高和位置之类的几何信息。盒模型的类型受该节点相关的 display 样式属性的影响（参考样式计算章节）。下面的 WebKit 代码说明了如何根据 display 属性决定某个节点创建何种类型的渲染对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RenderObject* <span class="title">RenderObject::createObject</span><span class="params">(Node* node, RenderStyle* style)</span> </span>&#123;</span><br><span class="line">    Document* doc = node-&gt;<span class="built_in">document</span>();</span><br><span class="line">    RenderArena* arena = doc-&gt;<span class="built_in">renderArena</span>();</span><br><span class="line">    ...</span><br><span class="line">    RenderObject* o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (style-&gt;<span class="built_in">display</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> NONE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderInline</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE_BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LIST_ITEM:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderListItem</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的类型也需要考虑，例如，表单控件和表格带有特殊的框架。</p><p>在Webkit中，如果一个元素想创建一个特殊的渲染对象，它需要重写“createRenderer”方法，使渲染对象指向不包含几何信息的样式对象。</p><p><strong>简单总结：</strong>渲染树是可视节点的集合，即在页面真实渲染的元素集合，底层使用c++进行渲染，通过c++定义不同的对象实现不同类型节点的渲染</p><h4 id="1-3-2-渲染树和DOM树的关系"><a href="#1-3-2-渲染树和DOM树的关系" class="headerlink" title="1.3.2 渲染树和DOM树的关系"></a>1.3.2 渲染树和DOM树的关系</h4><p>渲染对象和Dom元素相对应，但这种对应关系不是一对一的，不可见的Dom元素不会被插入渲染树，如head元素，display属性为none的元素（渲染树中存在 visibility 属性为 hidden 或着 opacity 属性为0的元素）。</p><p>还有一些Dom元素对应几个可见对象，它们一般是具有<strong>复杂结构</strong>的元素，无法用一个矩形来描述。例如，select元素有三个渲染对象——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而<strong>换行</strong>时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的 HTML结构，根据 CSS 规范，<strong>一个行内元素只能仅包含行内元素或仅包含块状元素，存在混合内容时，将会创建匿名的块状渲染对象包裹行内元素</strong>。</p><p><img src="/assets/image-20220905163521-nfbbt1n.png" alt="image.png"></p><h4 id="1-3-3-创建树的流程（The-flow-of-constructing-the-tree）"><a href="#1-3-3-创建树的流程（The-flow-of-constructing-the-tree）" class="headerlink" title="1.3.3 创建树的流程（The flow of constructing the tree）"></a>1.3.3 创建树的流程（The flow of constructing the tree）</h4><p>Firefox中，表述为一个监听Dom更新的监听器，将frame的创建委派给Frame Constructor，这个构建器计算样式（参看样式计算）并创建一个frame。</p><p>Webkit中，计算样式并生成渲染对象的过程称为 attachment，每个Dom节点有一个attach方法，attachment的过程是<strong>同步</strong>的，调用新节点的 attach 方法将节点插入到Dom树中。处理 html 和 body 标签将构建渲染树的根，这个<strong>根渲染对象</strong>对应被 css 规范称为 containing block 的元素——<strong>包含</strong>了其他所有块元素的顶级块元素。它的大小就是 <strong>viewport</strong>——浏览器窗口的显示区域，Firefox称它为 viewPortFrame，webkit称为 RenderView，这个就是文档 document 所指向的渲染对象，树中其他的部分都将作为一个插入的Dom节点被创建。</p><p><strong>简单总结：</strong>不同的内核对于合并的过程有不同的称呼，WebKit中使用attachment，构建渲染树会扫描DOM树和CSSOM树，扫描DOM树发现HTML、BODY元素时，就会创建一个根渲染对象，称为<strong>containing block</strong>，大小就是viewport。</p><h4 id="1-3-4-样式计算（Style-Computation）"><a href="#1-3-4-样式计算（Style-Computation）" class="headerlink" title="1.3.4 样式计算（Style Computation）"></a>1.3.4 样式计算（Style Computation）</h4><p>创建渲染树需要计算出每个渲染对象的可视属性，这可以通过计算每个元素的样式属性得到。</p><p>样式包括各种来源的<strong>样式表</strong>，<strong>行内样式元素</strong>及html中的<strong>可视化属性</strong>（例如bgcolor），可视化属性转化为css样式属性。</p><p>样式表的来源包括浏览器默认样式表、页面作者以及用户提供的样式表（有些样式是浏览器用户提供的（浏览器允许用户定义喜欢的样式，例如，在Firefox中可以通过在Firefox Profile目录下放置样式表实现））。</p><p>计算样式的一些困难：</p><ol><li>样式数据是非常大的结构，保存大量的样式属性会带来内存问题。</li><li>如果不进行优化，找到每个元素匹配的规则会导致性能问题，为每个元素查找匹配的规则都需要遍历整个规则表，这个过程有很大的工作量。选择符可能有复杂的结构，匹配过程如果沿着一条开始看似正确，后来却被证明是无用的路径，则必须去尝试另一条路径。例如，复杂选择符 <code>div div div div｛…｝</code> 这意味着规则应用到三个div的后代div元素，选择树某一条特定的路径去检查，这可能需要遍历节点树，最后却发现它只是两个div的后代，并不使用该规则，然后则需要沿着另一条路径去尝试</li><li>应用规则涉及非常复杂的级联，它们定义了规则的层次</li></ol><p><strong>浏览器如何处理这些问题？</strong></p><p>共享样式数据（Sharing style data）</p><p>WebKit节点引用样式对象（渲染样式），某些情况下，这些对象可以被节点间共享，这些节点需要是兄弟或是表兄弟节点，并且：</p><ol><li>这些元素必须处于相同的鼠标状态（比如不能一个处于hover，而另一个不是）</li><li>不能有元素具有id</li><li>标签名必须匹配</li><li>class属性必须匹配</li><li>对应的属性必须相同</li><li>链接状态必须匹配</li><li>焦点状态必须匹配</li><li>不能有元素被属性选择器影响</li><li>元素不能有行内样式属性</li><li>不能有生效的兄弟选择器，webcore在任何兄弟选择器相遇时只是简单的抛出一个全局转换，并且在它们显示时使整个文档的样式共享失效，这些包括＋选择器和类似:first-child和:last-child这样的选择器。</li></ol><p>Firefox规则树（Firefox rule tree）</p><p>Firefox用两个树用来简化样式计算－规则树和样式上下文树，WebKit也有样式对象，但它们并没有存储在类似样式上下文树这样的树中，只是由Dom节点指向其相关的样式。</p><p><img src="/assets/image-20220905204116-occzqvw.png" alt="image.png" title="Firefox样式上下文树"></p><p>具体细节可以阅读原文：<a href="https://kb.cnblogs.com/page/129756/#chapter4">浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>Webkit中，并没有规则树，匹配的声明会被遍历四次，先是应用非important的高优先级属性（之所以先应用这些属性，是因为其他的依赖于它们－比如display），其次是高优先级important的，接着是一般优先级非important的，最后是一般优先级important的规则。这样，出现多次的属性将被按照正确的级联顺序进行处理，最后一个生效。</p><h3 id="1-4-Layout"><a href="#1-4-Layout" class="headerlink" title="1.4 Layout"></a>1.4 Layout</h3><p>当渲染对象被创建并添加到树中，它们仅具有对应的布局规则，并没有实际的位置和大小，计算这些值的过程称为 layout 或 reflow。</p><p>Html使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中<strong>从右向左</strong>、<strong>自上而下</strong>的进行。也存在一些例外，比如 html tables。</p><p>坐标系统相对于根frame，使用 top 和 left 坐标。布局是一个<strong>递归</strong>的过程，由根渲染对象开始，它对应 html 文档document元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。根渲染对象的位置是 0,0，它的大小是viewport－浏览器窗口的可见部分。所有的渲染对象都有一个 layout 或 reflow 方法，每个渲染对象调用<strong>需要布局</strong>的 children 的 layout 方法。</p><p><strong>简单总结：</strong>通过父元素掉调用需要布局的 children 的 layout 方法，如何明确元素需要布局，则需要使用到 Dirty bit 系统</p><h4 id="1-4-1-Dirty-bit系统"><a href="#1-4-1-Dirty-bit系统" class="headerlink" title="1.4.1 Dirty bit系统"></a>1.4.1 Dirty bit系统</h4><p>为了不因为每个小变化都<strong>全部重新布局</strong>，浏览器使用一个 dirty bit 系统，一个渲染对象发生了<strong>变化</strong>或是被<strong>添加</strong>了，就标记<strong>它及它的children</strong>为dirty——需要layout。</p><p>dirty bit 设置元素存在两个标识——dirty及children are dirty，children are dirty标识说明即使这个渲染对象本身的属性没变化，它也至少有一个child需要layout。</p><h4 id="1-4-2-全局和增量layout"><a href="#1-4-2-全局和增量layout" class="headerlink" title="1.4.2 全局和增量layout"></a>1.4.2 全局和增量layout</h4><p>当layout在整棵渲染树触发时，称为全局layout，这可能在下面这些情况下发生：</p><ol><li>一个全局的样式改变影响所有的渲染对象，比如字号的改变。</li><li>窗口resize。</li></ol><p>layout也可以是增量的，这样只有标志为dirty的渲染对象会重新布局（也将导致一些额外的布局）。增量layout会在渲染对象dirty时<strong>异步触发</strong>，例如，当网络接收到新的内容并添加到DOM树后，新的渲染对象会添加到渲染树中，即在初次渲染时，是一个增量layout的过程。</p><p><img src="/assets/image-20220905210504-r5cgwfg.png" alt="image.png" title="增量layout过程"></p><p><strong>异步和同步layout</strong></p><p><strong>增量layout的过程是异步的</strong>，Firefox为增量 layout 生成了 reflow 队列，以及一个调度执行这些批处理命令。WebKit也有一个计时器用来执行增量layout－遍历树，为dirty状态的渲染对象重新布局。另外，当脚本请求样式信息时，例如“offsetHeight”，会同步的触发增量布局。</p><p>全局的layout一般都是同步触发。有些时候，layout会被作为一个初始layout之后的回调，比如滑动条的滑动。</p><p><strong>优化</strong></p><p>当一个layout因为resize或是渲染位置改变（并不是大小改变）而触发时，渲染对象的大小将会从缓存中读取，而不会重新计算。</p><p>一般情况下，如果只有子树发生改变，则layout并不从根开始。这种情况发生在，变化发生在元素自身并且不影响它周围元素，例如，将文本插入文本域（否则，每次击键都将触发从根开始的重排）。</p><h4 id="1-4-3-layout过程"><a href="#1-4-3-layout过程" class="headerlink" title="1.4.3 layout过程"></a>1.4.3 layout过程</h4><p>layout一般有下面这几个部分：</p><ol><li><p>parent渲染对象决定它的宽度</p></li><li><p>parent渲染对象读取chilidren，并：</p><ul><li>放置child渲染对象（设置它的x和y）</li><li>在需要时（它们当前为dirty或是处于全局layout或者其他原因）调用child渲染对象的layout，这将计算child的高度</li><li>parent渲染对象使用child渲染对象的累积高度，以及margin和padding的高度来设置自己的高度－这将被parent渲染对象的parent使用</li><li>将dirty标识设置为false</li></ul></li></ol><p>Firefox使用一个“state”对象（nsHTMLReflowState）做为参数去布局（firefox称为reflow），state包含parent的宽度及其他内容。</p><p>Firefox布局的输出是一个“metrics”对象（nsHTMLReflowMetrics）。它包括渲染对象计算出的高度。</p><p><strong>宽度计算</strong></p><p>渲染对象的宽度使用容器的宽度、渲染对象样式中的宽度及margin、border进行计算。例如，下面这个div的宽度：</p><p>　　<kbd><div /></kbd></p><p>webkit中宽度的计算过程是（RenderBox类的 <strong>calcWidth</strong> 方法）：</p><ul><li>容器的宽度是容器的<strong>可用宽度和0</strong>中的最大值，这里的可用宽度为：contentWidth&#x3D;clientWidth()-paddingLeft()-paddingRight()，clientWidth和clientHeight代表一个对象内部的不包括border和滑动条的大小</li><li>元素的宽度指样式属性width的值，它可以通过计算容器的百分比得到一个绝对值</li><li>加上水平方向上的border和padding</li></ul><p>到这里是最佳宽度的计算过程，现在计算宽度的最大值和最小值，如果最佳宽度大于最大宽度则使用最大宽度，如果小于最小宽度则使用最小宽度。最后缓存这个值，当需要layout但宽度未改变时使用。</p><p><strong>Line breaking</strong></p><p>当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的parent它需要折行，parent将创建额外的渲染对象并调用它们的layout。</p><h3 id="1-5-绘制（Painting）"><a href="#1-5-绘制（Painting）" class="headerlink" title="1.5 绘制（Painting）"></a>1.5 绘制（Painting）</h3><p>　　绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件，这在UI的章节有更多的介绍。</p><h4 id="1-5-1-全局和增量"><a href="#1-5-1-全局和增量" class="headerlink" title="1.5.1 全局和增量"></a>1.5.1 全局和增量</h4><p>和布局一样，绘制也可以是<strong>全局的</strong>——绘制完整的树，或<strong>增量的</strong>。在增量的绘制过程中，一些渲染对象以不影响整棵树的方式改变，改变的渲染对象使其在屏幕上的矩形区域失效，这将导致操作系统将其看作dirty区域，并产生一个paint事件，操作系统很巧妙的处理这个过程，并将<strong>多个区域合并为一个</strong>，提高性能。Chrome中，这个过程更复杂些，因为渲染对象在不同的进程中，而不是在主进程中。Chrome在一定程度上模拟操作系统的行为，表现为监听事件并派发消息给渲染根，在树中查找到相关的渲染对象，重绘这个对象（往往还包括它的children）。</p><h4 id="1-5-2-绘制顺序"><a href="#1-5-2-绘制顺序" class="headerlink" title="1.5.2 绘制顺序"></a>1.5.2 绘制顺序</h4><p>css2定义了绘制过程的顺序——<a href="http://www.w3.org/TR/CSS21/zindex.html">http://www.w3.org/TR/CSS21/zindex.html</a>。这个就是元素压入堆栈的顺序，这个顺序影响着绘制，<strong>堆栈从后向前进行绘制</strong>。</p><p>一个块渲染对象的堆栈顺序是：</p><ol><li>背景色</li><li>背景图</li><li>border</li><li>children</li><li>outline</li></ol><h4 id="1-5-3-Firefox显示列表"><a href="#1-5-3-Firefox显示列表" class="headerlink" title="1.5.3 Firefox显示列表"></a>1.5.3 Firefox显示列表</h4><p>Firefox读取渲染树并为绘制的矩形创建一个<strong>显示列表</strong>，该列表以<strong>正确的绘制顺序</strong>包含这个矩形<strong>相关的渲染对象</strong>（背景、图片、样式属性等以正确的顺序排序）。用这样的方法，可以使重绘时只需查找一次树，而不需要多次查找——绘制所有的背景、所有的图片、所有的border等等。</p><p>Firefox优化了这个过程，它不添加会被隐藏的元素，比如元素完全在其他不透明元素下面。</p><h4 id="1-5-4-WebKit矩形存储"><a href="#1-5-4-WebKit矩形存储" class="headerlink" title="1.5.4 WebKit矩形存储"></a>1.5.4 WebKit矩形存储</h4><p>重绘前，WebKit将旧的矩形保存为位图，然后<strong>只绘制新旧矩形的差集</strong>。</p><h4 id="1-5-5-动态变化"><a href="#1-5-5-动态变化" class="headerlink" title="1.5.5 动态变化"></a>1.5.5 动态变化</h4><p>浏览器总是试着以<strong>最小的动作响应一个变化</strong>，所以一个元素颜色的变化将只导致该元素的重绘，元素位置的变化将大致元素的布局和重绘，添加一个Dom节点，也会导致这个元素的布局和重绘。一些主要的变化，比如增加html元素的字号，将会导致<strong>缓存失效</strong>，从而引起整体的布局和重绘。</p><h3 id="1-6-渲染引擎的线程"><a href="#1-6-渲染引擎的线程" class="headerlink" title="1.6 渲染引擎的线程"></a>1.6 渲染引擎的线程</h3><p>渲染引擎是<strong>单线程</strong>的，除了网络操作以外，几乎所有的事情都在单一的线程中处理，在Firefox和Safari中，这是浏览器的<strong>主线程</strong>，Chrome中这是tab的主线程（Chrome一个Tab一个进程，一个进程中含有一个主线程，负责大部分的代码执行）。</p><p>网络操作由几个并行线程执行，并行连接的个数是受限的（通常是2－6个）。</p><h3 id="1-7-事件循环"><a href="#1-7-事件循环" class="headerlink" title="1.7 事件循环"></a>1.7 事件循环</h3><p>浏览器主线程是一个事件循环，它被设计为无限循环以保持执行过程的可用，等待事件（例如layout和paint事件）并执行它们，注意并不是无限制的轮询，而是一个带有阻塞的轮询。下面是Firefox的主要事件循环代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mExiting)</span><br><span class="line">    <span class="built_in">NS_ProcessNextEvent</span>(thread);</span><br></pre></td></tr></table></figure><h3 id="1-8-CSS2可视模型（CSS2-visual-module）"><a href="#1-8-CSS2可视模型（CSS2-visual-module）" class="headerlink" title="1.8 CSS2可视模型（CSS2 visual module）"></a>1.8 CSS2可视模型（CSS2 visual module）</h3><h4 id="1-8-1-画布The-Canvas"><a href="#1-8-1-画布The-Canvas" class="headerlink" title="1.8.1 画布The Canvas"></a>1.8.1 画布The Canvas</h4><p>根据CSS2规范，术语canvas用来描述<strong>格式化的结构所渲染的空间</strong>——浏览器绘制内容的地方。画布对每个维度空间都是无限大的，但浏览器基于viewport的大小选择了一个初始宽度。根据<a href="http://www.w3.org/TR/CSS2/zindex.html">http://www.w3.org/TR/CSS2/zindex.html</a>的定义，画布如果是包含在其他画布内则是透明的，否则浏览器会指定一个颜色。</p><h4 id="1-8-2-CSS盒模型"><a href="#1-8-2-CSS盒模型" class="headerlink" title="1.8.2 CSS盒模型"></a>1.8.2 CSS盒模型</h4><p>CSS盒模型描述了矩形盒，这些矩形盒是为文档树中的元素生成的，并根据可视的格式化模型进行布局。每个box包括内容区域（如图片、文本等）及可选的四周padding、border和margin区域。</p><p><img src="/assets/image-20220905213040-ukvs7qo.png" alt="image.png" title="CSS盒子模型"></p><p>每个节点生成0－n个这样的box。所有的元素都有一个display属性，用来决定它们生成box的类型，例如：</p><ul><li>block －生成块状box</li><li>inline －生成一个或多个行内box</li><li>none －不生成box</li></ul><p>默认的是inline，但浏览器样式表设置了其他默认值，例如，div元素默认为block。可以访问<a href="http://www.w3.org/TR/CSS2/sample.html">http://www.w3.org/TR/CSS2/sample.html</a>查看更多的默认样式表示例。</p><h4 id="1-8-3-定位策略Position-scheme"><a href="#1-8-3-定位策略Position-scheme" class="headerlink" title="1.8.3 定位策略Position scheme"></a>1.8.3 定位策略Position scheme</h4><p>这里有三种策略：</p><ol><li>normal －对象根据它在文档的中位置定位，这意味着它在渲染树和在Dom树中位置一致，并根据它的盒模型和大小进行布局。</li><li>float －对象先像普通流一样布局，然后尽可能的向左或是向右移动。</li><li>absolute －对象在渲染树中的位置和Dom树中<strong>位置无关</strong>。</li></ol><p><strong>static 和 relative 是normal， float属于float，absolute和fixed属于absolute。</strong></p><p>在static定位中，不定义位置而使用默认的位置。其他策略中，作者指定位置——top、bottom、left、right。</p><h4 id="1-8-4-Box布局"><a href="#1-8-4-Box布局" class="headerlink" title="1.8.4 Box布局"></a>1.8.4 Box布局</h4><p>Box布局的方式由这几项决定：box的类型、box的大小、定位策略及扩展信息（比如图片大小和屏幕尺寸）。</p><p><strong>Box类型</strong></p><ul><li>Block box：构成一个块，即在浏览器窗口上有自己的矩形</li><li>Inline box：并没有自己的块状区域，但包含在一个块状区域内</li></ul><p>区分</p><ul><li>block一个挨着一个垂直格式化，inline则在水平方向上格式化。</li></ul><p><img src="/assets/image-20220905214925-cfzraou.png" alt="image.png"></p><ul><li>Inline盒模型放置在行内或是line box中，每行至少和最高的box一样高，当box以baseline对齐时——即一个元素的底部和另一个box上除底部以外的某点对齐，行高可以比最高的box高。当容器宽度不够时，行内元素将被放到多行中，这在一个p元素中经常发生。</li></ul><p><img src="/assets/image-20220905215128-dc6mo20.png" alt="image.png"></p><h4 id="定位Position"><a href="#定位Position" class="headerlink" title="定位Position"></a>定位Position</h4><p><strong>Relative</strong></p><p>相对定位——先按照一般的定位，然后按所要求的差值移动。</p><p><img src="/assets/image-20220905215245-d8kp87q.png" alt="image.png"></p><p><strong>Floats</strong></p><p>一个浮动的box移动到一行的最左边或是最右边，其余的box围绕在它周围。下面这段html：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;img src=<span class="string">&quot;images/image.gif&quot;</span> width=<span class="string">&quot;100&quot;</span> height=<span class="string">&quot;100&quot;</span>&gt;Lorem ipsum dolor sit amet, consectetuer...</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215332-ibisnl2.png" alt="image.png"></p><p><strong>Absolute和Fixed</strong></p><p>这种情况下的布局完全<strong>不顾普通的文档流</strong>，<strong>元素不属于文档流的一部分</strong>，大小取决于容器。Fixed时，容器为viewport（可视区域）。</p><p><img src="/assets/image-20220905215416-ftp14sx.png" alt="image.png"></p><p><strong>Layered representation</strong></p><p>这个由CSS属性中的<strong>z-index</strong>指定，表示盒模型的第三个大小，即在<strong>z轴上的位置</strong>。Box分发到堆栈中（称为堆栈上下文），每个堆栈中<strong>靠后的元素将被较早绘制</strong>，栈顶靠前的元素离用户最近，当发生交叠时，将隐藏靠后的元素。<strong>堆栈根据z-index属性排序</strong>，拥有z-index属性的box形成了一个局部堆栈，viewport有外部堆栈</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">STYLE</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215620-7cst2bt.png" alt="image.png"></p><p>虽然绿色div排在红色div后面，可能在正常流中也已经被绘制在后面，但z-index有更高优先级，所以在根box的堆栈中更靠前。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> 浏览器内部工作原理-解析方向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三. 浏览器内部工作原理-解析方向（二）</title>
      <link href="/2022/09/06/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/09/06/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="三-浏览器内部工作原理-解析方向（二）"><a href="#三-浏览器内部工作原理-解析方向（二）" class="headerlink" title="三. 浏览器内部工作原理-解析方向（二）"></a>三. 浏览器内部工作原理-解析方向（二）</h1><h2 id="树的构建流程"><a href="#树的构建流程" class="headerlink" title="树的构建流程"></a>树的构建流程</h2><h3 id="1-3-Render-Tree"><a href="#1-3-Render-Tree" class="headerlink" title="1.3 Render Tree"></a>1.3 Render Tree</h3><h4 id="1-3-1-渲染树的定义"><a href="#1-3-1-渲染树的定义" class="headerlink" title="1.3.1 渲染树的定义"></a>1.3.1 渲染树的定义</h4><p>当Dom树构建完成时，浏览器开始构建另一棵树——渲染树。渲染树由元素显示序列中的可见元素组成，它是文档的可视化表示，构建这棵树是为了以正确的顺序绘制文档内容。</p><p>Firefox将渲染树中的元素称为frames，WebKit则用renderer或渲染对象来描述这些元素.一个渲染对象知道怎么布局及绘制自己及它的 children？</p><p>RenderObject是Webkit的渲染对象基类，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RenderObject</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">layout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(PaintInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> rect <span class="title">repaintRect</span><span class="params">()</span></span>;</span><br><span class="line">    Node* node;<span class="comment">//the DOM node</span></span><br><span class="line">    RenderStyle* style;<span class="comment">// the computed style</span></span><br><span class="line">    RenderLayer* containgLayer; <span class="comment">//the containing z-index layer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个渲染节点对象用一个和该节点 CSS 盒模型相对应的矩形区域来表示，正如 CSS2 所描述的那样，它包含诸如宽、高和位置之类的几何信息。盒模型的类型受该节点相关的 display 样式属性的影响（参考样式计算章节）。下面的 WebKit 代码说明了如何根据 display 属性决定某个节点创建何种类型的渲染对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RenderObject* <span class="title">RenderObject::createObject</span><span class="params">(Node* node, RenderStyle* style)</span> </span>&#123;</span><br><span class="line">    Document* doc = node-&gt;<span class="built_in">document</span>();</span><br><span class="line">    RenderArena* arena = doc-&gt;<span class="built_in">renderArena</span>();</span><br><span class="line">    ...</span><br><span class="line">    RenderObject* o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (style-&gt;<span class="built_in">display</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> NONE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderInline</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE_BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LIST_ITEM:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderListItem</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的类型也需要考虑，例如，表单控件和表格带有特殊的框架。</p><p>在Webkit中，如果一个元素想创建一个特殊的渲染对象，它需要重写“createRenderer”方法，使渲染对象指向不包含几何信息的样式对象。</p><p><strong>简单总结：</strong>渲染树是可视节点的集合，即在页面真实渲染的元素集合，底层使用c++进行渲染，通过c++定义不同的对象实现不同类型节点的渲染</p><h4 id="1-3-2-渲染树和DOM树的关系"><a href="#1-3-2-渲染树和DOM树的关系" class="headerlink" title="1.3.2 渲染树和DOM树的关系"></a>1.3.2 渲染树和DOM树的关系</h4><p>渲染对象和Dom元素相对应，但这种对应关系不是一对一的，不可见的Dom元素不会被插入渲染树，如head元素，display属性为none的元素（渲染树中存在 visibility 属性为 hidden 或着 opacity 属性为0的元素）。</p><p>还有一些Dom元素对应几个可见对象，它们一般是具有<strong>复杂结构</strong>的元素，无法用一个矩形来描述。例如，select元素有三个渲染对象——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而<strong>换行</strong>时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的 HTML结构，根据 CSS 规范，<strong>一个行内元素只能仅包含行内元素或仅包含块状元素，存在混合内容时，将会创建匿名的块状渲染对象包裹行内元素</strong>。</p><p><img src="/assets/image-20220905163521-nfbbt1n.png" alt="image.png"></p><h4 id="1-3-3-创建树的流程（The-flow-of-constructing-the-tree）"><a href="#1-3-3-创建树的流程（The-flow-of-constructing-the-tree）" class="headerlink" title="1.3.3 创建树的流程（The flow of constructing the tree）"></a>1.3.3 创建树的流程（The flow of constructing the tree）</h4><p>Firefox中，表述为一个监听Dom更新的监听器，将frame的创建委派给Frame Constructor，这个构建器计算样式（参看样式计算）并创建一个frame。</p><p>Webkit中，计算样式并生成渲染对象的过程称为 attachment，每个Dom节点有一个attach方法，attachment的过程是<strong>同步</strong>的，调用新节点的 attach 方法将节点插入到Dom树中。处理 html 和 body 标签将构建渲染树的根，这个<strong>根渲染对象</strong>对应被 css 规范称为 containing block 的元素——<strong>包含</strong>了其他所有块元素的顶级块元素。它的大小就是 <strong>viewport</strong>——浏览器窗口的显示区域，Firefox称它为 viewPortFrame，webkit称为 RenderView，这个就是文档 document 所指向的渲染对象，树中其他的部分都将作为一个插入的Dom节点被创建。</p><p><strong>简单总结：</strong>不同的内核对于合并的过程有不同的称呼，WebKit中使用attachment，构建渲染树会扫描DOM树和CSSOM树，扫描DOM树发现HTML、BODY元素时，就会创建一个根渲染对象，称为<strong>containing block</strong>，大小就是viewport。</p><h4 id="1-3-4-样式计算（Style-Computation）"><a href="#1-3-4-样式计算（Style-Computation）" class="headerlink" title="1.3.4 样式计算（Style Computation）"></a>1.3.4 样式计算（Style Computation）</h4><p>创建渲染树需要计算出每个渲染对象的可视属性，这可以通过计算每个元素的样式属性得到。</p><p>样式包括各种来源的<strong>样式表</strong>，<strong>行内样式元素</strong>及html中的<strong>可视化属性</strong>（例如bgcolor），可视化属性转化为css样式属性。</p><p>样式表的来源包括浏览器默认样式表、页面作者以及用户提供的样式表（有些样式是浏览器用户提供的（浏览器允许用户定义喜欢的样式，例如，在Firefox中可以通过在Firefox Profile目录下放置样式表实现））。</p><p>计算样式的一些困难：</p><ol><li>样式数据是非常大的结构，保存大量的样式属性会带来内存问题。</li><li>如果不进行优化，找到每个元素匹配的规则会导致性能问题，为每个元素查找匹配的规则都需要遍历整个规则表，这个过程有很大的工作量。选择符可能有复杂的结构，匹配过程如果沿着一条开始看似正确，后来却被证明是无用的路径，则必须去尝试另一条路径。例如，复杂选择符 <code>div div div div｛…｝</code> 这意味着规则应用到三个div的后代div元素，选择树某一条特定的路径去检查，这可能需要遍历节点树，最后却发现它只是两个div的后代，并不使用该规则，然后则需要沿着另一条路径去尝试</li><li>应用规则涉及非常复杂的级联，它们定义了规则的层次</li></ol><p><strong>浏览器如何处理这些问题？</strong></p><p>共享样式数据（Sharing style data）</p><p>WebKit节点引用样式对象（渲染样式），某些情况下，这些对象可以被节点间共享，这些节点需要是兄弟或是表兄弟节点，并且：</p><ol><li>这些元素必须处于相同的鼠标状态（比如不能一个处于hover，而另一个不是）</li><li>不能有元素具有id</li><li>标签名必须匹配</li><li>class属性必须匹配</li><li>对应的属性必须相同</li><li>链接状态必须匹配</li><li>焦点状态必须匹配</li><li>不能有元素被属性选择器影响</li><li>元素不能有行内样式属性</li><li>不能有生效的兄弟选择器，webcore在任何兄弟选择器相遇时只是简单的抛出一个全局转换，并且在它们显示时使整个文档的样式共享失效，这些包括＋选择器和类似:first-child和:last-child这样的选择器。</li></ol><p>Firefox规则树（Firefox rule tree）</p><p>Firefox用两个树用来简化样式计算－规则树和样式上下文树，WebKit也有样式对象，但它们并没有存储在类似样式上下文树这样的树中，只是由Dom节点指向其相关的样式。</p><p><img src="/assets/image-20220905204116-occzqvw.png" alt="image.png" title="Firefox样式上下文树"></p><p>具体细节可以阅读原文：<a href="https://kb.cnblogs.com/page/129756/#chapter4">浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>Webkit中，并没有规则树，匹配的声明会被遍历四次，先是应用非important的高优先级属性（之所以先应用这些属性，是因为其他的依赖于它们－比如display），其次是高优先级important的，接着是一般优先级非important的，最后是一般优先级important的规则。这样，出现多次的属性将被按照正确的级联顺序进行处理，最后一个生效。</p><h3 id="1-4-Layout"><a href="#1-4-Layout" class="headerlink" title="1.4 Layout"></a>1.4 Layout</h3><p>当渲染对象被创建并添加到树中，它们仅具有对应的布局规则，并没有实际的位置和大小，计算这些值的过程称为 layout 或 reflow。</p><p>Html使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中<strong>从右向左</strong>、<strong>自上而下</strong>的进行。也存在一些例外，比如 html tables。</p><p>坐标系统相对于根frame，使用 top 和 left 坐标。布局是一个<strong>递归</strong>的过程，由根渲染对象开始，它对应 html 文档document元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。根渲染对象的位置是 0,0，它的大小是viewport－浏览器窗口的可见部分。所有的渲染对象都有一个 layout 或 reflow 方法，每个渲染对象调用<strong>需要布局</strong>的 children 的 layout 方法。</p><p><strong>简单总结：</strong>通过父元素掉调用需要布局的 children 的 layout 方法，如何明确元素需要布局，则需要使用到 Dirty bit 系统</p><h4 id="1-4-1-Dirty-bit系统"><a href="#1-4-1-Dirty-bit系统" class="headerlink" title="1.4.1 Dirty bit系统"></a>1.4.1 Dirty bit系统</h4><p>为了不因为每个小变化都<strong>全部重新布局</strong>，浏览器使用一个 dirty bit 系统，一个渲染对象发生了<strong>变化</strong>或是被<strong>添加</strong>了，就标记<strong>它及它的children</strong>为dirty——需要layout。</p><p>dirty bit 设置元素存在两个标识——dirty及children are dirty，children are dirty标识说明即使这个渲染对象本身的属性没变化，它也至少有一个child需要layout。</p><h4 id="1-4-2-全局和增量layout"><a href="#1-4-2-全局和增量layout" class="headerlink" title="1.4.2 全局和增量layout"></a>1.4.2 全局和增量layout</h4><p>当layout在整棵渲染树触发时，称为全局layout，这可能在下面这些情况下发生：</p><ol><li>一个全局的样式改变影响所有的渲染对象，比如字号的改变。</li><li>窗口resize。</li></ol><p>layout也可以是增量的，这样只有标志为dirty的渲染对象会重新布局（也将导致一些额外的布局）。增量layout会在渲染对象dirty时<strong>异步触发</strong>，例如，当网络接收到新的内容并添加到DOM树后，新的渲染对象会添加到渲染树中，即在初次渲染时，是一个增量layout的过程。</p><p><img src="/assets/image-20220905210504-r5cgwfg.png" alt="image.png" title="增量layout过程"></p><p><strong>异步和同步layout</strong></p><p><strong>增量layout的过程是异步的</strong>，Firefox为增量 layout 生成了 reflow 队列，以及一个调度执行这些批处理命令。WebKit也有一个计时器用来执行增量layout－遍历树，为dirty状态的渲染对象重新布局。另外，当脚本请求样式信息时，例如“offsetHeight”，会同步的触发增量布局。</p><p>全局的layout一般都是同步触发。有些时候，layout会被作为一个初始layout之后的回调，比如滑动条的滑动。</p><p><strong>优化</strong></p><p>当一个layout因为resize或是渲染位置改变（并不是大小改变）而触发时，渲染对象的大小将会从缓存中读取，而不会重新计算。</p><p>一般情况下，如果只有子树发生改变，则layout并不从根开始。这种情况发生在，变化发生在元素自身并且不影响它周围元素，例如，将文本插入文本域（否则，每次击键都将触发从根开始的重排）。</p><h4 id="1-4-3-layout过程"><a href="#1-4-3-layout过程" class="headerlink" title="1.4.3 layout过程"></a>1.4.3 layout过程</h4><p>layout一般有下面这几个部分：</p><ol><li><p>parent渲染对象决定它的宽度</p></li><li><p>parent渲染对象读取chilidren，并：</p><ul><li>放置child渲染对象（设置它的x和y）</li><li>在需要时（它们当前为dirty或是处于全局layout或者其他原因）调用child渲染对象的layout，这将计算child的高度</li><li>parent渲染对象使用child渲染对象的累积高度，以及margin和padding的高度来设置自己的高度－这将被parent渲染对象的parent使用</li><li>将dirty标识设置为false</li></ul></li></ol><p>Firefox使用一个“state”对象（nsHTMLReflowState）做为参数去布局（firefox称为reflow），state包含parent的宽度及其他内容。</p><p>Firefox布局的输出是一个“metrics”对象（nsHTMLReflowMetrics）。它包括渲染对象计算出的高度。</p><p><strong>宽度计算</strong></p><p>渲染对象的宽度使用容器的宽度、渲染对象样式中的宽度及margin、border进行计算。例如，下面这个div的宽度：</p><p>　　<kbd><div /></kbd></p><p>webkit中宽度的计算过程是（RenderBox类的 <strong>calcWidth</strong> 方法）：</p><ul><li>容器的宽度是容器的<strong>可用宽度和0</strong>中的最大值，这里的可用宽度为：contentWidth&#x3D;clientWidth()-paddingLeft()-paddingRight()，clientWidth和clientHeight代表一个对象内部的不包括border和滑动条的大小</li><li>元素的宽度指样式属性width的值，它可以通过计算容器的百分比得到一个绝对值</li><li>加上水平方向上的border和padding</li></ul><p>到这里是最佳宽度的计算过程，现在计算宽度的最大值和最小值，如果最佳宽度大于最大宽度则使用最大宽度，如果小于最小宽度则使用最小宽度。最后缓存这个值，当需要layout但宽度未改变时使用。</p><p><strong>Line breaking</strong></p><p>当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的parent它需要折行，parent将创建额外的渲染对象并调用它们的layout。</p><h3 id="1-5-绘制（Painting）"><a href="#1-5-绘制（Painting）" class="headerlink" title="1.5 绘制（Painting）"></a>1.5 绘制（Painting）</h3><p>　　绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件，这在UI的章节有更多的介绍。</p><h4 id="1-5-1-全局和增量"><a href="#1-5-1-全局和增量" class="headerlink" title="1.5.1 全局和增量"></a>1.5.1 全局和增量</h4><p>和布局一样，绘制也可以是<strong>全局的</strong>——绘制完整的树，或<strong>增量的</strong>。在增量的绘制过程中，一些渲染对象以不影响整棵树的方式改变，改变的渲染对象使其在屏幕上的矩形区域失效，这将导致操作系统将其看作dirty区域，并产生一个paint事件，操作系统很巧妙的处理这个过程，并将<strong>多个区域合并为一个</strong>，提高性能。Chrome中，这个过程更复杂些，因为渲染对象在不同的进程中，而不是在主进程中。Chrome在一定程度上模拟操作系统的行为，表现为监听事件并派发消息给渲染根，在树中查找到相关的渲染对象，重绘这个对象（往往还包括它的children）。</p><h4 id="1-5-2-绘制顺序"><a href="#1-5-2-绘制顺序" class="headerlink" title="1.5.2 绘制顺序"></a>1.5.2 绘制顺序</h4><p>css2定义了绘制过程的顺序——<a href="http://www.w3.org/TR/CSS21/zindex.html">http://www.w3.org/TR/CSS21/zindex.html</a>。这个就是元素压入堆栈的顺序，这个顺序影响着绘制，<strong>堆栈从后向前进行绘制</strong>。</p><p>一个块渲染对象的堆栈顺序是：</p><ol><li>背景色</li><li>背景图</li><li>border</li><li>children</li><li>outline</li></ol><h4 id="1-5-3-Firefox显示列表"><a href="#1-5-3-Firefox显示列表" class="headerlink" title="1.5.3 Firefox显示列表"></a>1.5.3 Firefox显示列表</h4><p>Firefox读取渲染树并为绘制的矩形创建一个<strong>显示列表</strong>，该列表以<strong>正确的绘制顺序</strong>包含这个矩形<strong>相关的渲染对象</strong>（背景、图片、样式属性等以正确的顺序排序）。用这样的方法，可以使重绘时只需查找一次树，而不需要多次查找——绘制所有的背景、所有的图片、所有的border等等。</p><p>Firefox优化了这个过程，它不添加会被隐藏的元素，比如元素完全在其他不透明元素下面。</p><h4 id="1-5-4-WebKit矩形存储"><a href="#1-5-4-WebKit矩形存储" class="headerlink" title="1.5.4 WebKit矩形存储"></a>1.5.4 WebKit矩形存储</h4><p>重绘前，WebKit将旧的矩形保存为位图，然后<strong>只绘制新旧矩形的差集</strong>。</p><h4 id="1-5-5-动态变化"><a href="#1-5-5-动态变化" class="headerlink" title="1.5.5 动态变化"></a>1.5.5 动态变化</h4><p>浏览器总是试着以<strong>最小的动作响应一个变化</strong>，所以一个元素颜色的变化将只导致该元素的重绘，元素位置的变化将大致元素的布局和重绘，添加一个Dom节点，也会导致这个元素的布局和重绘。一些主要的变化，比如增加html元素的字号，将会导致<strong>缓存失效</strong>，从而引起整体的布局和重绘。</p><h3 id="1-6-渲染引擎的线程"><a href="#1-6-渲染引擎的线程" class="headerlink" title="1.6 渲染引擎的线程"></a>1.6 渲染引擎的线程</h3><p>渲染引擎是<strong>单线程</strong>的，除了网络操作以外，几乎所有的事情都在单一的线程中处理，在Firefox和Safari中，这是浏览器的<strong>主线程</strong>，Chrome中这是tab的主线程（Chrome一个Tab一个进程，一个进程中含有一个主线程，负责大部分的代码执行）。</p><p>网络操作由几个并行线程执行，并行连接的个数是受限的（通常是2－6个）。</p><h3 id="1-7-事件循环"><a href="#1-7-事件循环" class="headerlink" title="1.7 事件循环"></a>1.7 事件循环</h3><p>浏览器主线程是一个事件循环，它被设计为无限循环以保持执行过程的可用，等待事件（例如layout和paint事件）并执行它们，注意并不是无限制的轮询，而是一个带有阻塞的轮询。下面是Firefox的主要事件循环代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mExiting)</span><br><span class="line">    <span class="built_in">NS_ProcessNextEvent</span>(thread);</span><br></pre></td></tr></table></figure><h3 id="1-8-CSS2可视模型（CSS2-visual-module）"><a href="#1-8-CSS2可视模型（CSS2-visual-module）" class="headerlink" title="1.8 CSS2可视模型（CSS2 visual module）"></a>1.8 CSS2可视模型（CSS2 visual module）</h3><h4 id="1-8-1-画布The-Canvas"><a href="#1-8-1-画布The-Canvas" class="headerlink" title="1.8.1 画布The Canvas"></a>1.8.1 画布The Canvas</h4><p>根据CSS2规范，术语canvas用来描述<strong>格式化的结构所渲染的空间</strong>——浏览器绘制内容的地方。画布对每个维度空间都是无限大的，但浏览器基于viewport的大小选择了一个初始宽度。根据<a href="http://www.w3.org/TR/CSS2/zindex.html">http://www.w3.org/TR/CSS2/zindex.html</a>的定义，画布如果是包含在其他画布内则是透明的，否则浏览器会指定一个颜色。</p><h4 id="1-8-2-CSS盒模型"><a href="#1-8-2-CSS盒模型" class="headerlink" title="1.8.2 CSS盒模型"></a>1.8.2 CSS盒模型</h4><p>CSS盒模型描述了矩形盒，这些矩形盒是为文档树中的元素生成的，并根据可视的格式化模型进行布局。每个box包括内容区域（如图片、文本等）及可选的四周padding、border和margin区域。</p><p><img src="/assets/image-20220905213040-ukvs7qo.png" alt="image.png" title="CSS盒子模型"></p><p>每个节点生成0－n个这样的box。所有的元素都有一个display属性，用来决定它们生成box的类型，例如：</p><ul><li>block －生成块状box</li><li>inline －生成一个或多个行内box</li><li>none －不生成box</li></ul><p>默认的是inline，但浏览器样式表设置了其他默认值，例如，div元素默认为block。可以访问<a href="http://www.w3.org/TR/CSS2/sample.html">http://www.w3.org/TR/CSS2/sample.html</a>查看更多的默认样式表示例。</p><h4 id="1-8-3-定位策略Position-scheme"><a href="#1-8-3-定位策略Position-scheme" class="headerlink" title="1.8.3 定位策略Position scheme"></a>1.8.3 定位策略Position scheme</h4><p>这里有三种策略：</p><ol><li>normal －对象根据它在文档的中位置定位，这意味着它在渲染树和在Dom树中位置一致，并根据它的盒模型和大小进行布局。</li><li>float －对象先像普通流一样布局，然后尽可能的向左或是向右移动。</li><li>absolute －对象在渲染树中的位置和Dom树中<strong>位置无关</strong>。</li></ol><p><strong>static 和 relative 是normal， float属于float，absolute和fixed属于absolute。</strong></p><p>在static定位中，不定义位置而使用默认的位置。其他策略中，作者指定位置——top、bottom、left、right。</p><h4 id="1-8-4-Box布局"><a href="#1-8-4-Box布局" class="headerlink" title="1.8.4 Box布局"></a>1.8.4 Box布局</h4><p>Box布局的方式由这几项决定：box的类型、box的大小、定位策略及扩展信息（比如图片大小和屏幕尺寸）。</p><p><strong>Box类型</strong></p><ul><li>Block box：构成一个块，即在浏览器窗口上有自己的矩形</li><li>Inline box：并没有自己的块状区域，但包含在一个块状区域内</li></ul><p>区分</p><ul><li>block一个挨着一个垂直格式化，inline则在水平方向上格式化。</li></ul><p><img src="/assets/image-20220905214925-cfzraou.png" alt="image.png"></p><ul><li>Inline盒模型放置在行内或是line box中，每行至少和最高的box一样高，当box以baseline对齐时——即一个元素的底部和另一个box上除底部以外的某点对齐，行高可以比最高的box高。当容器宽度不够时，行内元素将被放到多行中，这在一个p元素中经常发生。</li></ul><p><img src="/assets/image-20220905215128-dc6mo20.png" alt="image.png"></p><h4 id="定位Position"><a href="#定位Position" class="headerlink" title="定位Position"></a>定位Position</h4><p><strong>Relative</strong></p><p>相对定位——先按照一般的定位，然后按所要求的差值移动。</p><p><img src="/assets/image-20220905215245-d8kp87q.png" alt="image.png"></p><p><strong>Floats</strong></p><p>一个浮动的box移动到一行的最左边或是最右边，其余的box围绕在它周围。下面这段html：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;img src=<span class="string">&quot;images/image.gif&quot;</span> width=<span class="string">&quot;100&quot;</span> height=<span class="string">&quot;100&quot;</span>&gt;Lorem ipsum dolor sit amet, consectetuer...</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215332-ibisnl2.png" alt="image.png"></p><p><strong>Absolute和Fixed</strong></p><p>这种情况下的布局完全<strong>不顾普通的文档流</strong>，<strong>元素不属于文档流的一部分</strong>，大小取决于容器。Fixed时，容器为viewport（可视区域）。</p><p><img src="/assets/image-20220905215416-ftp14sx.png" alt="image.png"></p><p><strong>Layered representation</strong></p><p>这个由CSS属性中的<strong>z-index</strong>指定，表示盒模型的第三个大小，即在<strong>z轴上的位置</strong>。Box分发到堆栈中（称为堆栈上下文），每个堆栈中<strong>靠后的元素将被较早绘制</strong>，栈顶靠前的元素离用户最近，当发生交叠时，将隐藏靠后的元素。<strong>堆栈根据z-index属性排序</strong>，拥有z-index属性的box形成了一个局部堆栈，viewport有外部堆栈</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">STYLE</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215620-7cst2bt.png" alt="image.png"></p><p>虽然绿色div排在红色div后面，可能在正常流中也已经被绘制在后面，但z-index有更高优先级，所以在根box的堆栈中更靠前。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> 浏览器内部工作原理-解析方向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三. 浏览器内部工作原理-解析方向（一）</title>
      <link href="/2022/09/06/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/09/06/%E4%B8%89.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="三-浏览器内部工作原理-解析方向（一）"><a href="#三-浏览器内部工作原理-解析方向（一）" class="headerlink" title="三. 浏览器内部工作原理-解析方向（一）"></a>三. 浏览器内部工作原理-解析方向（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为方便读者阅读，贴出以下参考链接，在此感谢前辈笔记。</p><p>浏览器解析过程分析：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>浏览器工作过程分析：<a href="https://zhuanlan.zhihu.com/p/96986818">万字详文：深入理解浏览器原理 - 知乎 (zhihu.com)</a></p><h2 id="树的构建流程"><a href="#树的构建流程" class="headerlink" title="树的构建流程"></a>树的构建流程</h2><p><img src="/assets/image-20220902091918-3jgz0jo.png" alt="image.png"></p><p>HTML 和 CSS 的页面解析是从上之下的，<strong>线程的</strong>。文档流从上往下，若先碰到了 CSS，那么开始解析，接着<strong>不被阻塞的</strong>继续向下解析 HTML，这样既符合并行解析，又符合文档流自上往下解析规则。浏览器先下载 HTML 文件开始解析，遇到 CSS 标签就开始下载 CSS 并解析，这个过程不会阻塞 DOM 的构建。最后 DOM 树和 CSS 规则树生成渲染树，HTML 解析完成。</p><p>注意几点：</p><ol><li>CSS 加载不会阻塞 DOM 树的<strong>解析</strong></li><li>CSS 加载会阻塞 DOM 树的<strong>渲染</strong>（不阻塞解析），即合并成渲染树的过程，因为样式可能会导致重排重绘</li><li>CSS 加载会阻塞后面 JS 语句的执行</li></ol><p>解析、渲染这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时还可能通过网络下载其余内容。</p><h3 id="1-1-HTML-Parser"><a href="#1-1-HTML-Parser" class="headerlink" title="1.1 HTML Parser"></a>1.1 HTML Parser</h3><h4 id="1-1-1-解析"><a href="#1-1-1-解析" class="headerlink" title="1.1.1 解析"></a>1.1.1 解析</h4><p>解析的目的是：将文档转换为具有一定意义的结构，编码时可以理解和使用的东西。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。</p><blockquote><p>解析的目的在于让目标更接近于需要使用的形式，或更具体的描述一些信息。如高级语言先转换为汇编等低级语言，最后再转换成机器码，又或者是家具的运输与组装，零件形式更接近于运输模式，成品形式更接近于使用模式，由成品拆分成零件就是使其更接近于运输模式，同样的道理将文档解析成另外一个格式会更适合某一个场景的使用。</p></blockquote><p>如解析“2＋3－1”这个表达式，可能返回这样一棵树。</p><p><img src="/assets/image-20220902121038-5xudoir.png" alt="image.png"></p><p>解析过程与翻译过程类似，需要具备两个条件，字典和语法规则。</p><p><strong>文法（Grammars）</strong>：解析基于文档依据的语法规则——文档的语言或格式。每种可被解析的格式必须具有由词汇及语法规则组成的特定的文法，称为上下文无关文法。简单来说就是由词汇表、语法规则组成的对某一个格式的限制，与当前文件内容无关。</p><blockquote><p>文法不等于语法规则，文法是词汇表和语法规则的结合，如语法规则定义为“<strong>的</strong>字后面跟着表示事物的名词，<strong>地</strong>字跟在动词后面，<strong>得</strong>字后面跟着形容词”，词汇表则有“谁，得，的，地，花，走，快”，文法规则就是词汇表和语法规则的结合，包含任何一个可能选择，如“谁的花，走得快，的，得，地”等。</p></blockquote><p>解析可以分成两个子过程：</p><ul><li>词法分析</li><li>语法分析</li></ul><p><strong>词法分析</strong>是将文档中的字词按照一定地规则（词汇表）分成符号，符号对应的便是词汇表（基本有效单元的集合）中的某一项。对于人类语言来说，它相当于我们字典中出现的所有单词。</p><p><strong>语法分析</strong>是根据语法规则匹配词法分析后的符号，生成特定状态的过程。</p><p>词法分析器（有时也叫分词器）负责将输入分解为合法的符号，语法分析器则根据语言的语法规则分析文档结构，从而构建解析树，词法分析器知道怎么跳过空白和换行之类的无关字符。</p><p><img src="/assets/image-20220902133652-u2je5s2.png" alt="image.png"></p><p>解析过程是<strong>迭代的</strong>，语法分析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后语法分析器分析下一个符号。如果没有匹配到规则，语法分析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</p><blockquote><p>词法分析器和语法分析器的工作是同步的，正如组装家具时，找到一个一个零件，根据说明书进行组装，如果没有找齐零件，是无法组装某一个个体的。</p></blockquote><h4 id="1-1-2-转换"><a href="#1-1-2-转换" class="headerlink" title="1.1.2 转换"></a>1.1.2 转换</h4><p>转换对工作人员来说是一个隐式的过程，正如在浏览器开发者控制台运行一些代码、打印日志信息一样，开发者可能感受不到转换到机器码的过程。但是编写的源代码并不是最终的目标，底层机器码才是机器识别、运行的格式。</p><p>很多时候，解析树并不是最终结果。解析一般在转换中使用——将输入文档转换为另一种格式。编译就是个例子，编译器在将一段源码编译为机器码的时候，先将源码解析为解析树，然后将该树转换为一个机器码文档。</p><p>简单来说<strong>转换</strong>过程在编译运行时就存在，将源代码转换为机器码，转换时是无感的。</p><p><img src="/assets/image-20220902140802-boi3thw.png" alt="image.png"></p><p>详细的例子可以看看：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>，如不熟悉抽象语法树的概念，可以看看：<a href="https://juejin.cn/post/6844904035271573511">手把手带你入门 AST 抽象语法树 - 掘金 (juejin.cn)</a>。</p><h4 id="1-1-3-深入"><a href="#1-1-3-深入" class="headerlink" title="1.1.3 深入"></a>1.1.3 深入</h4><p><strong>HTML解析器（HTML Parser）：</strong>HTML解析器的工作是将html标识解析为解析树。</p><p><strong>HTML文法定义（The HTML grammar definition）：</strong>W3C组织制定规范定义了HTML的词汇表和语法。</p><p><strong>非上下文无关文法（Not a context free grammar）：</strong>正如在解析简介中提到的，上下文无关文法的语法可以用类似BNF的格式来定义。</p><blockquote><p>HTML 有一个正式的格式定义—— DTD（Document Type Definition文档类型定义），但它并不是上下文无关文法，HTML 更接近于 XML，现在有很多可用的xml 解析器，html 有个 xml 的变体——xhtml，不同在于 html 更宽容，它允许忽略一些特定标签，有时可以省略开始或结束标签。总的来说，它是一种 soft 语法，不像 xml 呆板、固执。</p><p>显然，这个看起来很小的差异却带来了很大的不同。一方面，这是 html 流行的原因——它的宽容使 web 开发人员的工作更加轻松，但另一方面，这也使很难去写一个格式化的文法。所以，html 的解析并不简单，它既不能用传统的解析器解析，也不能用 xml 解析器解析。</p></blockquote><p><strong>HTML DTD</strong></p><p>html 适用 DTD 格式进行定义，这一格式是用于定义 SGML 家族的语言，包括了对所有允许元素及它们的属性和层次关系的定义。正如前面提到的，html DTD 并没有生成一种上下文无关文法。DTD 有一些变种，标准模式只遵守规范，而其他模式则包含了对浏览器过去所使用标签的支持，这么做是为了兼容以前内容。最新的标准 DTD 在<a href="http://www.w3.org/TR/html4/strict.dtd">http://www.w3.org/TR/html4/strict.dtd</a>。</p><p><strong>DOM</strong></p><p>解析输出的树也就是解析树，是由 DOM 元素及属性节点组成的。DOM 是文档对象模型的缩写，它是 html 文档的对象表示，作为 html 元素的外部接口供 JS 等调用。DOM 和标签基本是一一对应的关系。</p><p><strong>解析器类型（Types of parsers）</strong></p><p>有两种基本的解析器——自顶向下解析及自底向上解析。比较直观的解释是，自顶向下解析，查看语法的最高层结构并试着匹配其中一个；自底向上解析则从输入开始，逐步将其转换为语法规则，从底层规则开始直到匹配高层规则。</p><p>来看一下这两种解析器如何解析 “2+3-1” 的例子：<strong>自顶向下</strong>解析器从最高层规则开始——它先识别出“2+3”，将其视为一个表达式，然后识别出 “2+3-1” 为一个表达式（识别表达式的过程中匹配了其他规则，但出发点是最高层规则）。<strong>自底向上</strong>解析会扫描输入直到匹配了一条规则，然后用该规则取代匹配的输入，直到解析完所有输入。部分匹配的表达式被放置在解析堆栈中。</p><p>自顶向下与递归过程类似，从整体开始逐步检查子问题，而自底向上与递推过程类似，从子问题开始推向整体。</p><p><strong>自动化解析（Generating parsers automatically）</strong></p><p>解析器生成器这个工具可以自动生成解析器，只需要指定语言的文法——词汇表及语法规则，它就可以生成一个解析器。创建一个解析器需要对解析有深入的理解，而且手动的创建一个由较好性能的解析器并不容易，所以解析生成器很有用。Webkit使用两个知名的解析生成器——<strong>用于创建语法分析器的Flex</strong>及<strong>创建解析器的Bison</strong>（你可能接触过Lex和Yacc）。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p><p>稍微总结：HTML 解析器按照 HTML DTD 文法定义进行 HTML 解析，可以认为解析生成的 DOM 树与解析树一一映射，DOM 树就是解析树。</p><h4 id="1-1-4-解析算法"><a href="#1-1-4-解析算法" class="headerlink" title="1.1.4 解析算法"></a>1.1.4 解析算法</h4><p>HTML 不能被一般的自顶向下或自底向上的解析器所解析，不能使用正则解析技术，浏览器为 HTML 定制了专属的解析器，原因是：</p><ol><li><p>这门语言本身的宽容特性</p></li><li><p>浏览器对一些常见的非法html有容错机制</p></li><li><p>解析过程是往复的，通常源码不会在解析过程中发生改变，但在 HTML 中，脚本标签包含的 “document.write” 可能添加标签，这说明在解析过程中实际上修改了输入，所以不能使用正则解析技术</p></li></ol><p>HTML5 规范中描述了这个解析算法，算法包括两个阶段——符号化及构建树。</p><p>符号化是<strong>词法分析</strong>的过程，将输入解析为符号，HTML 的符号包括开始标签、结束标签、属性名及属性值。符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，以识别下一个符号，直到处理完所有输入。</p><p><strong>符号识别算法（The tokenization algorithm）</strong></p><p>算法输出 HTML 符号，该算法用状态机表示。每次读取输入流中的一个或多个字符，并根据这些字符转移到下一个状态，当前的符号状态及构建树状态共同影响结果，这意味着，读取同样的字符，可能因为当前状态的不同，得到不同的结果以进入下一个正确的状态。</p><p>这个算法很复杂，这里用一个简单的例子来解释这个原理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello world</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>初始状态为“Data State”，当遇到“&lt;”字符，状态变为“Tag open state”，读取一个a－z的字符将产生一个开始标签符号，状态相应变为“Tag name state”，一直保持这个状态直到读取到“&gt;”，每个字符都附加到这个符号名上，例子中创建的是一个html符号。</p><p>当读取到“&gt;”，当前的符号就完成了，此时状态回到“Data state”，“<body>”重复这一处理过程。到这里，html和body标签都识别出来了。现在，回到“Data state”，读取“Hello world”中的字符“H”将创建并识别出一个字符符号，这里会<strong>为“Hello world”中的每个字符生成一个字符符号</strong>。</p><p>这样直到遇到“</body>”中的“&lt;”。现在，又回到了“Tag open state”，读取下一个字符“&#x2F;”将创建一个闭合标签符号，并且状态转移到“Tag name state”，还是保持这一状态，直到遇到“&gt;”。然后，产生一个新的标签符号并回到“Data state”。后面的“</html>”将和“</body>”一样处理。</p><p><img src="/assets/image-20220903152441-lnzo21q.png" alt="image.png"></p><p><strong>简单总结：</strong>因为 HTML 符号包括开始标签、结束标签、属性名及属性值，所以解析每一个符号都需要三个状态来决定。状态机+符号化+树构建器。<strong>符号并不仅仅只是一个字符</strong>，可以是标签符号包括标签名、属性等，除标签符号外，为每一个内容字符创建一个字符符号（Data State）。</p><p><strong>树的构建算法（Tree construction algorithm）</strong></p><p>在树的构建阶段，将<strong>修改</strong>以Document为根的DOM树，将元素附加到树上。每个由符号识别器识别生成的节点将会被树构造器进行处理，规范中定义了每个符号相对应的Dom元素，<strong>对应的Dom元素将会被创建</strong>。这些元素除了会被添加到Dom树上，还将被添加到开放元素堆栈中。这个堆栈用来纠正嵌套的未匹配和未闭合标签，这个算法也是用状态机来描述，所有的状态采用插入模式。</p><p>首先是“initial mode”，接收到html符号后将转换为“before html”模式，在这个模式中对这个符号进行再处理。此时，创建了一个HTMLHtmlElement元素，并将其附加到根Document对象上。</p><p>状态此时变为“before head”，接收到body符号时，即使这里没有head符号，也将自动创建一个HTMLHeadElement元素并附加到树上。</p><p>现在，转到“in head”模式，然后是“after head”。到这里，body符号会被再次处理，将创建一个HTMLBodyElement并插入到树中，同时，转移到“in body”模式。</p><p>然后，接收到字符串“Hello world”的字符符号，第一个字符将导致创建并插入一个text节点，其他字符将附加到该节点。</p><p>接收到body结束符号时，转移到“after body”模式，接着接收到html结束符号，这个符号意味着转移到了“after after body”模式，当接收到文件结束符时，整个解析过程结束。</p><p><img src="/assets/image-20220903152422-pm7uawo.png" alt="image.png"></p><p><strong>简单总结：</strong>树构建器根据符号创建对应的DOM元素，附加到以Document为根的DOM树上，并对一些常见的 HTML 错误进行处理。</p><h4 id="1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）"><a href="#1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）" class="headerlink" title="1.1.5 解析结束时的处理（Action when the parsing is finished）"></a>1.1.5 解析结束时的处理（Action when the parsing is finished）</h4><p>在这个阶段，浏览器将文档标记为可交互的，并开始解析处于延时模式中的脚本——这些脚本在文档解析后执行。文档状态将被设置为完成，同时触发一个 <strong>load</strong> 事件。</p><p>HTML5 规范中有符号化及构建树的完整算法：<a href="http://www.w3.org/TR/html5/syntax.html#html-parser">链接</a>。</p><h4 id="1-1-6-浏览器容错（Browsers-error-tolerance）"><a href="#1-1-6-浏览器容错（Browsers-error-tolerance）" class="headerlink" title="1.1.6 浏览器容错（Browsers error tolerance）"></a>1.1.6 浏览器容错（Browsers error tolerance）</h4><p>详细可查看原文：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><h3 id="1-2-CSS-Parser"><a href="#1-2-CSS-Parser" class="headerlink" title="1.2 CSS Parser"></a>1.2 CSS Parser</h3><p>CSS 的加载并不会阻塞 DOM 的解析，但是会阻塞 DOM 的渲染。因为加载 CSS 时，可能会修改当前解析位置以后的 DOM 节点的样式，如果 CSS 加载不阻塞 DOM 树渲染，那么当 CSS 加载完之后，DOM 树可能又得重新重排 layout（回流reflow）或者重绘了，这就造成了一些没有必要的损耗。</p><p>不同于HTML，CSS属于上下文无关文法，可以用前面所描述的解析器来解析。CSS规范定义了CSS的词法及语法文法。可以参考词汇表和语法规则：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>。</p><p>每个符号都由正则表达式定义了词法文法（词汇表）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comment<span class="comment">///*[^*]*/*+([^/*][^*]*/*+)*//</span></span><br><span class="line">num[<span class="number">0</span>-<span class="number">9</span>]+|[<span class="number">0</span>-<span class="number">9</span>]*<span class="string">&quot;.&quot;</span>[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">nonascii[<span class="regexp">/200-/</span><span class="number">377</span>]</span><br><span class="line">nmstart[_a-z]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">nmchar[_a-z0-<span class="number">9</span>-]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">name&#123;nmchar&#125;+</span><br><span class="line">ident&#123;nmstart&#125;&#123;nmchar&#125;*</span><br></pre></td></tr></table></figure><p>“ident”是识别器的缩写，相当于一个class名，“name”是一个元素id（用“＃”引用）。</p><p>语法用BNF进行描述：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">: selector [ <span class="string">&#x27;,&#x27;</span> S* selector ]*</span><br><span class="line"><span class="string">&#x27;&#123;&#x27;</span> S* declaration [ <span class="string">&#x27;;&#x27;</span> S* declaration ]* <span class="string">&#x27;&#125;&#x27;</span> S*</span><br><span class="line">;</span><br><span class="line">selector</span><br><span class="line">: simple_selector [ combinator selector | S+ [ combinator selector ] ]</span><br><span class="line">;</span><br><span class="line"><span class="keyword">class</span></span><br><span class="line">: <span class="string">&#x27;.&#x27;</span> <span class="variable constant_">IDENT</span></span><br><span class="line">;</span><br><span class="line">element_name</span><br><span class="line">: <span class="variable constant_">IDENT</span> | <span class="string">&#x27;*&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>一个规则集合具有一个或是可选个数的多个选择器，这些选择器以逗号和空格（S表示空格）进行分隔。每个规则集合包含大括号及大括号中的一条或多条以分号隔开的声明。声明和选择器在后面进行定义。</p><h4 id="1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）"><a href="#1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）" class="headerlink" title="1.2.1 Webkit CSS解析器（Webkit CSS parser）"></a>1.2.1 Webkit CSS解析器（Webkit CSS parser）</h4><p>Webkit使用Flex和Bison解析生成器从CSS语法文件中自动生成解析器。回忆一下解析器的介绍，Bison创建一个自底向上的解析器，Firefox使用自顶向下解析器。它们都是将每个css文件解析为样式表对象，每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。</p><blockquote><p>用于创建语法分析器的Flex及创建解析器的Bison。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p></blockquote><p><img src="/assets/image-20220903160338-wjh6j4x.png" alt="image.png"></p><p>注意：WebKit使用的是自底向上的解析器</p><blockquote><p>处理脚本及样式表的顺序（The order of processing scripts and style sheets）</p><p>脚本：web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。HTML5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。</p><p>async是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行；而Defer是在JS加载完成后，整个文档解析完成后执行。 Defer更像是将&lt;script&gt;标签放在&lt;&#x2F;body&gt;之后的效果，但是它由于是异步加载JS文件，所以可以节省时间。简单来说就是async和defer都是开启新线程（http线程）请求JS文件，和解析DOM并行不冲突，async在请求完成后就开始执行JS文件，而defer则是在整个DOM解析完成后再执行JS文件。</p><p>预解析（Speculative parsing）</p><p>Webkit和Firefox都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变Dom树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p></blockquote><p>StyleSheets样式表采用另一种模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。</p><p><strong>简单总结：</strong>WebKit用Flex生成CSS语法规则，Bison生成CSS解析器。样式表不阻塞DOM解析，但是阻塞DOM渲染，FireFox在样式文件未加载完成前阻塞JS脚本，目的是防止样式文件未加载完成而JS脚本需要获取样式文件信息的错误，Chrome只阻塞那些访问未加载完成的样式文件的JS脚本，样式加载完成即不堵塞。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> 浏览器内部工作原理-解析方向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一. 输入URL到呈现页面</title>
      <link href="/2022/09/06/%E4%B8%80.%20%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%91%88%E7%8E%B0%E9%A1%B5%E9%9D%A2/"/>
      <url>/2022/09/06/%E4%B8%80.%20%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%91%88%E7%8E%B0%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一-输入URL到呈现页面"><a href="#一-输入URL到呈现页面" class="headerlink" title="一. 输入URL到呈现页面"></a>一. 输入URL到呈现页面</h1><p>按照实现的功能我认为可以划分为三个阶段</p><ul><li>本地校验阶段</li><li>网络请求阶段</li><li>本地渲染阶段</li></ul><h2 id="1-本地校验阶段"><a href="#1-本地校验阶段" class="headerlink" title="1. 本地校验阶段"></a>1. 本地校验阶段</h2><p>本地校验阶段其实很简单，判断输入的信息是搜索还是域名(服务器地址IP)</p><ul><li>如果是搜索，浏览器将会把默认<strong>搜索引擎URL</strong> + <strong>搜索内容</strong>合并成一个新的URL</li><li>如果是网址，浏览器则会根据URL协议，将网址补全为合法的URL</li></ul><p>常见的例子</p><ul><li><p>输入Hello World：<a href="https://cn.bing.com/search?q=hello+world&amp;FORM=ANAB01&amp;PC=U531">https://cn.bing.com/search?q=hello+world&amp;FORM=ANAB01&amp;PC=U531</a></p></li><li><p>输入 image.baidu.com：<a href="https://image.baidu.com/">https://image.baidu.com/</a></p></li></ul><p>可以看出：</p><ul><li>输入搜索内容时，浏览器会将默认搜索引擎URL + 搜索内容合并成一个新的URL，并且可能会添加其他的参数。</li><li>输入网址时，浏览器会自动将原有的网址补全为合法的 URL，如加上 http&#x2F;https，特别注意当输入 <code>baidu.com</code>时，可能会跳转 <code>www.baidu.com</code>，这并不是浏览器的操作而是由服务器重定向到下级的<code>www</code>，目的是 SEO 和保证 cookie 等存储的安全。</li></ul><h2 id="2-网络请求阶段"><a href="#2-网络请求阶段" class="headerlink" title="2. 网络请求阶段"></a>2. 网络请求阶段</h2><p>网络请求阶段是一个复杂的过程，为了优化用户体验，浏览器会尽可能早的将页面呈现在用户面前，所以<strong>网络请求阶段</strong>与第三个阶段<strong>本地渲染</strong>是同步进行的，请求完成可以解析的内容就开始解析，并同时加载剩下地资源。TCP是一个全双工协议。</p><p>网络请求阶段可以细分为四个阶段</p><ul><li>DNS解析（可选）</li><li>建立TCP连接</li><li>发送HTTP请求</li><li>关闭TCP连接</li></ul><h3 id="2-1-DNS解析"><a href="#2-1-DNS解析" class="headerlink" title="2.1 DNS解析"></a>2.1 DNS解析</h3><p>DNS解析是为解析域名的IP而存在的，反向解析则是通过IP查询对应的域名。因为仅靠数字点分型的IP是很难记住的，所以在大部分时候都是通过域名访问网站，因而也需要一个地址簿即 DNS 服务器。</p><p>DNS 服务器是高可用、高并发和分布式的，它是树状结构，如图：</p><p><img src="/assets/image-20220906101312-5na6p7a.png" alt="image"></p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器：返回顶级域 DNS 服务器的 IP 地址，存储如（.com, .cn）服务器的地址</li><li>顶级域 DNS 服务器（com）：返回权威 DNS 服务器的 IP 地址</li><li>权威 DNS 服务器（<a href="http://server.com/">server.com</a>）：返回相应主机的 IP 地址，真正存储当前查询域名的地址簿，如在阿里注册的域名会给分配DNS服务器存储解析<code>dns17.hichina.com</code>，可以在阿里买域名然后转腾讯，此时的阿里服务的权威DNS就会变成腾讯服务的权威DNS</li><li>本地域名服务器（查询代理和DNS查询结果缓存）: 只是一个查询代理，可以是路由器，也可以是运营商的服务器</li></ul><p>目前流行的是递归+迭代查询方式。</p><blockquote><p>如果手机或者电脑上设置解析的DNS为114.114.114.114，那么本地服务器就是114，从设备到114之间为递归查询，其余的为迭代查询。</p></blockquote><blockquote><p>如果设备设置的解析地址为DHCP即路由器或其他自动分配，那么可以认为当前设备到路由器是递归查询，其余为迭代查询。</p></blockquote><p><img src="/assets/image-20220906093724-2b83fv1.png" alt="image.png"></p><p><img src="/assets/image-20220906103913-4kgoi13.png" alt="image"></p><blockquote><p>注：未找到本地DNS解析器缓存，这里我认为是路由器缓存</p></blockquote><p>在客户端输入 URL 后，会有一个<strong>递归+迭代</strong>的过程，<strong>浏览器缓存</strong> -&gt; <strong>系统DNS缓存</strong> -&gt; <strong>本地hosts文件</strong> -&gt; <strong>本地DNS解析器缓存</strong> ?  -&gt; <strong>本地区域DNS服务器迭代查询</strong>，这个过程中任何一步找到了都会结束查找流程。如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式（是否委托其他服务器来干这件事），则迭代查找过程如下图：</p><p><img src="/assets/image-20220906104500-rmsecj0.png" alt="image"></p><p>在查找过程中，有以下优化点：</p><ul><li>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</li><li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li></ul><h3 id="2-2-建立Tcp连接"><a href="#2-2-建立Tcp连接" class="headerlink" title="2.2 建立Tcp连接"></a>2.2 建立Tcp连接</h3><p>首先，判断是不是 <strong>https</strong> ，如果是，则请求过程其实是 HTTP + SSL &#x2F; TLS 两部分组成，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，即传输都是加密后的数据。</p><p>三次握手，建立TCP连接</p><ol><li>第一次握手：建立连接，客户端发送连接请求报文段。将SYN位置为1，此时表示客户端向服务端请求建立连接，Sequence Number为x，随机数用于校验；客户端进入SYN_SEND状态，等待服务器的确认</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；发送SYN请求信息，将SYN位置为1，此时表示服务端向客户端发送建立连接的请求；Sequence Number为y，随机数用于校验；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入 <strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</li></ol><p><strong>简单总结：</strong>三次握手的原因是保证双方通信，TCP是一个全双工协议，所以链路需要分别建立，客户端向服务端请求建立连接，服务端向客户端应答同时请求建立连接，客户端向服务端应答。</p><p>SSL握手过程</p><ol><li><strong>第一步</strong> ：爱丽丝给出支持SSL协议版本号，一个客户端 <strong>随机数</strong> (Client random，第一个随机数)，客户端支持的加密方法等信息</li><li><strong>第二步：</strong> 鲍勃收到信息后，确认双方使用的加密方法，并返回数字证书，一个服务器生成的 <strong>随机数</strong> (Server random，第二个随机数)等信息</li><li><strong>第三步：</strong> 爱丽丝确认数字证书的有效性（计算机系统已默认存储相关机构的证书），然后生成一个新的 <strong>随机数</strong> (Premaster secret)，然后使用数字证书中的公钥，加密这个随机数，发给鲍勃。</li><li><strong>第四步：</strong> 鲍勃使用自己的私钥，获取爱丽丝发来的 <strong>随机数</strong> (即Premaster secret)；(第三、四步就是非对称加密的过程了)</li><li><strong>第五步：</strong> 爱丽丝和鲍勃通过约定的加密方法(通常是<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">AES算法</a>)，使用前面三个随机数，生成 <strong>对话密钥</strong> ，用来加密接下来的通信内容</li></ol><p><img src="/assets/image-20220906111112-swzpduo.png" alt="image"></p><p>完成之后，客户端和服务器端就可以开始传送数据。更多 HTTPS 的资料可以看这里：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/32513816">SSL协议之数据加密过程详解 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/26682342">深入理解HTTPS原理、过程与实践 - 知乎 (zhihu.com)</a></li><li><a href="https://segmentfault.com/a/1190000012196642">解析HTTPS - SegmentFault 思否</a></li></ul><p>简单总结：Tcp建立完成后，如果没有加密 SSL&#x2F;TLS 过程，此时可以开始 HTTP 请求，如果有加密过程，则按照五个阶段进行准备，SSL使用非对称来加密会话密钥，后期使用会话密钥对称加密会话。</p><blockquote><p>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP协议规定，只有ACK&#x3D;1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</p><p>SYN(SYNchronization)：在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN&#x3D;1和ACK&#x3D;1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</p><p>FIN(finis）即完，终结的意思， 用来释放一个连接。当 FIN &#x3D; 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</p></blockquote><h3 id="2-3-http-x2F-https请求"><a href="#2-3-http-x2F-https请求" class="headerlink" title="2.3 http&#x2F;https请求"></a>2.3 http&#x2F;https请求</h3><p>TCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200.</p><p>这里有发生一个<strong>HTTP缓存</strong>过程，是一个常考的考点，大致过程如图：</p><p><img src="/assets/image-20220906112223-hedug48.png" alt="image"></p><p>细节放到了《二. Web性能与安全》处，也可以参考 <a href="https://juejin.cn/post/6844903962216824839#heading-10">浏览器相关原理(面试题)详细总结一 - 掘金 (juejin.cn)</a> 中浏览器缓存这一部分。</p><h3 id="2-5-断开Tcp连接"><a href="#2-5-断开Tcp连接" class="headerlink" title="2.5 断开Tcp连接"></a>2.5 断开Tcp连接</h3><ul><li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我”同意”你的关闭请求；</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ul><p><strong>简单总结：</strong>TCP是一个全双工协议，所以链路需要分别拆除，因为链路是双向的，所以无论是建立还是拆除，都需要分别建立，分别拆除，建立和拆除都是一问一答的形式。</p><p>在建立链路时，客户端发送请求建立，服务端应答同时也请求建立，客户端应答。</p><p>在拆除链路时，客户端发送拆除链路，服务端第一次应答，第二次发送拆除链路请求，客户端发送应答。可以是客户端先发送拆除，也可以是服务端先发送拆除，没有顺序要求但是要符合一问一答，与建立连接不同的是拆除链路的应答和发送分开发送，所以是四次挥手。</p><p>分开发送的目的是一条链路不再需要后可以<strong>及时断开</strong>，如果与建立连接类似同时发送 Ack + Fin，那么只有等到被动关闭端处理所有的信息后才会发送。</p><p>举个例子，A向B<strong>紧急</strong>借钱，B可以选择<strong>立刻</strong>给钱或者开一个借条后再给钱，立刻给钱可以<strong>及时响应</strong>，而开借条后再借钱则是<strong>耗费</strong>了A的<strong>等待时间</strong>，必须等B处理完所有借条工作后才能够拿到。</p><blockquote><p><strong>为什么需要四次挥手？</strong></p><p>因为TCP是一个全双工协议，必须单独拆除每一条信道。4次挥手的目的是终止数据传输，并回收资源，此时两个端点两个方向的序列号已经没有了任何关系，必须等待两方向都没有数据传输时才能拆除虚链路，不像初始化时那么简单，发现SYN标志就初始化一个序列号并确认SYN的序列号。因此必须单独分别在一个方向上终止该方向的数据传输。</p><p>如果是三次挥手，会怎么样？三次的话，被动关闭端在收到FIN消息之后，需要同时回复ACK和Server端的FIN消息。如果Server端在该连接上面并没有Pending的消息要处理，那么是可以的，如果Server端还需要等待一段时间才可以关闭另外一个方向的连接，那么这样的三次挥手就不能满足条件。</p><p><a href="https://www.jianshu.com/p/7ddb0e7867ac">【TCP&#x2F;IP】四次挥手的过程及原因 - 简书 (jianshu.com)</a></p></blockquote><h2 id="3-本地渲染阶段"><a href="#3-本地渲染阶段" class="headerlink" title="3. 本地渲染阶段"></a>3. 本地渲染阶段</h2><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树，CSSOM树、样式计算、布局阶段、分层、栅格化和显示。如图：</p><p><img src="/assets/image-20220906122229-s89ggsz.png" alt="image"></p><ul><li>渲染进程将 HTML 内容转换为能够读懂DOM 树结构，渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式，此时的过程是同步的，即HTML Parser 和 CSS Parser，Render Tree构建是同步的。</li><li>创建layout布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。</li><li>合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。</li></ul><h3 id="3-1-构建-DOM-树"><a href="#3-1-构建-DOM-树" class="headerlink" title="3.1 构建 DOM 树"></a>3.1 构建 DOM 树</h3><p>浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程即将字节解析为DOM树，先将HTML的原始字节数据转换为文件<strong>指定编码</strong>的字符，然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。</p><p><img src="/assets/image-20220906122855-4obxhof.png" alt="image"></p><ul><li>转码（Bytes -&gt; Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</li><li>Tokens 化（Characters -&gt; Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</li><li>构建 Nodes（Tokens -&gt; Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）</li><li>构建 DOM 树（Nodes -&gt; DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系</li></ul><p>具体的步骤可以参考《三. 浏览器内部工作 - 解析方向》</p><h3 id="3-2-样式计算"><a href="#3-2-样式计算" class="headerlink" title="3.2 样式计算"></a>3.2 样式计算</h3><p>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</p><p>CSS 样式来源主要有 3 种，分别是<code>通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。</code>，其样式计算过程主要为：</p><p><img src="/assets/image-20220906123225-36r2wq2.png" alt="image"></p><p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。处理完成后再处理样式的继承和层叠，有些文章将这个过程称为CSSOM的构建过程。</p><p>具体的可以参考：《三. 浏览器内部工作 - 解析方向》</p><h3 id="3-3-页面布局"><a href="#3-3-页面布局" class="headerlink" title="3.3 页面布局"></a>3.3 页面布局</h3><p>布局过程，即排除 <code>script、meta</code> 等功能化、非视觉节点，排除 <code>display: none</code> 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图：</p><p><img src="/assets/image-20220906123341-1ba6ky0.png" alt="image"></p><p>其中，这个过程需要注意的是<code>回流和重绘</code>，具体的可以参考《三. 浏览器内部工作 - 解析方向》</p><h3 id="3-4-生成分层树"><a href="#3-4-生成分层树" class="headerlink" title="3.4 生成分层树"></a>3.4 生成分层树</h3><p>页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），如图：</p><p><img src="/assets/image-20220906123525-cem0mn0.png" alt="image"></p><p>如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。在浏览器中，你可以打开 Chrome 的”开发者工具”，选择”Layers”标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。</p><p>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？</p><p>具体参考：<a href="https://juejin.cn/post/6844903969693646862#heading-4">浏览器相关原理(面试题)详细总结二 - 掘金 (juejin.cn)</a></p><h3 id="3-5-栅格化"><a href="#3-5-栅格化" class="headerlink" title="3.5 栅格化"></a>3.5 栅格化</h3><p>合成线程会按照视口附近的图块来<strong>优先</strong>生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。如图：</p><p><img src="/assets/image-20220906123907-bjyj2ua.png" alt="image"></p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><h3 id="3-6-显示"><a href="#3-6-显示" class="headerlink" title="3.6 显示"></a>3.6 显示</h3><p>最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。</p><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4. 参考文章"></a>4. 参考文章</h2><ul><li><a href="https://juejin.cn/post/6844904054074654728">细说浏览器输入URL后发生了什么 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6994066112203718686">输入URL到页面显示的前端体系知识 - 掘金 (juejin.cn)</a></li></ul><p>‍</p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> 输入URL到呈现页面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四. 浏览器内部工作原理-内存方向</title>
      <link href="/2022/09/06/%E5%9B%9B.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%96%B9%E5%90%91/"/>
      <url>/2022/09/06/%E5%9B%9B.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="四-浏览器内部工作原理-内存方向"><a href="#四-浏览器内部工作原理-内存方向" class="headerlink" title="四. 浏览器内部工作原理-内存方向"></a>四. 浏览器内部工作原理-内存方向</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为方便读者阅读，贴出以下参考链接，在此感谢前辈笔记。</p><p>浏览器解析过程分析：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>浏览器工作过程分析：<a href="https://zhuanlan.zhihu.com/p/96986818">万字详文：深入理解浏览器原理 - 知乎 (zhihu.com)</a></p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> 浏览器内部工作原理-内存方向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二. Web性能与安全</title>
      <link href="/2022/09/06/%E4%BA%8C.%20Web%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
      <url>/2022/09/06/%E4%BA%8C.%20Web%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="二-Web性能与安全"><a href="#二-Web性能与安全" class="headerlink" title="二. Web性能与安全"></a>二. Web性能与安全</h1><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> Web性能与安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Chic添加iconfont失败的临时解决方案</title>
      <link href="/2022/07/26/Hexo-Theme-Chic%E6%B7%BB%E5%8A%A0iconfont%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%B8%B4%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/07/26/Hexo-Theme-Chic%E6%B7%BB%E5%8A%A0iconfont%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%B8%B4%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>在Chic的issue中提到了很多自定义icon的解决方案，但是在2022&#x2F;07&#x2F;26查看时，有关于icon的解决方案都被删除了。</p><ul><li><p>问题：主页中自定义icon图标，在style.styl中@import “…” 加载失败，加载iconfont字体未404，还未找到原因。</p></li><li><p>解决方案：如果不嫌麻烦，直接在themes&#x2F;Chic&#x2F;Chic&#x2F;layout&#x2F;_partial&#x2F;head.ejs中加入 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/fonts/custom/iconfont.css&quot;&gt;</code> 直接加载即可，注意位置，themes&#x2F;Chic&#x2F;source&#x2F;fonts会被编译加载到public目录下。</p></li></ul><h3 id="Chic目录结构"><a href="#Chic目录结构" class="headerlink" title="Chic目录结构"></a>Chic目录结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├─languages</span><br><span class="line">├─layout</span><br><span class="line">│  ├─_page</span><br><span class="line">│  ├─_partial</span><br><span class="line">│  └─_plugins</span><br><span class="line">├─scripts</span><br><span class="line">└─source</span><br><span class="line">    ├─css</span><br><span class="line">    │  ├─_highlight</span><br><span class="line">    │  ├─_lib</span><br><span class="line">    │  ├─_page</span><br><span class="line">    │  │  └─_post</span><br><span class="line">    │  └─_partial</span><br><span class="line">    ├─fonts</span><br><span class="line">    │  ├─custom</span><br><span class="line">    │  ├─iconfont</span><br><span class="line">    │  └─lanting</span><br><span class="line">    └─js</span><br></pre></td></tr></table></figure><p> <code>source</code> 文件夹内的所有的内容都会被编译打包到项目根目录下的 <code>public</code> 文件夹。</p><p>加入 stylesheet 示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%# css list %&gt;</span><br><span class="line">&lt;% if (theme.stylesheets !== undefined &amp;&amp; theme.stylesheets.length &gt; 0) &#123; %&gt;</span><br><span class="line">    &lt;!-- stylesheets list from _config.yml --&gt;</span><br><span class="line">    &lt;% theme.stylesheets.forEach(url =&gt; &#123; %&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- url_for(url) %&gt;&quot;&gt;</span><br><span class="line">    &lt;% &#125;); %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%# 新增 %&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/fonts/custom/iconfont.css&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Chic </tag>
            
            <tag> Hexo </tag>
            
            <tag> iconfont </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/26/hello-world/"/>
      <url>/2022/07/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
