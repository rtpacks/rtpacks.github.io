<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeError: opts.node.rangeBy is not a function</title>
      <link href="/2023/02/27/TypeError-opts-node-rangeBy-is-not-a-function/"/>
      <url>/2023/02/27/TypeError-opts-node-rangeBy-is-not-a-function/</url>
      
        <content type="html"><![CDATA[<p>今天遇到 <code>TypeError: opts.node.rangeBy is not a function</code> 的问题，网上寻找一番后发现这个解决方案，但是并不适合，因为我的版本已经高于问题版本。</p><h4 id="postcss-版本过高"><a href="#postcss-版本过高" class="headerlink" title="postcss 版本过高"></a>postcss 版本过高</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fix &quot;TypeError: opts.node.rangeBy is not a function&quot; with PostCSS 8.4.4</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/stylelint/stylelint/issues/5766">Fix “TypeError: opts.node.rangeBy is not a function” with PostCSS 8.4.4 · Issue #5766 · stylelint&#x2F;stylelint (github.com)</a></li></ul><h4 id="删除空的style"><a href="#删除空的style" class="headerlink" title="删除空的style"></a>删除空的style</h4><p>根据这个插件往回找，尝试了将空的 <code>&lt;style lang=&quot;less&quot;&gt;</code> 删除，问题解决，这或许是边界判断问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;Share&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="设置stylelint-–custom-syntax-postcss"><a href="#设置stylelint-–custom-syntax-postcss" class="headerlink" title="设置stylelint –custom-syntax postcss"></a>设置stylelint –custom-syntax postcss</h4><p>在使用stylelint时可以选择单独设置less，scss，也可以选择直接用postcss</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;*.&#123;scss,sass&#125;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stylelint --fix --custom-syntax postcss-scss&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;*.less&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stylelint --fix --custom-syntax postcss-less&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="attr">&quot;*.&#123;scss,sass,less,css&#125;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stylelint --fix --custom-syntax postcss&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p><a href="https://blog.csdn.net/qq_45759413/article/details/129261144">Fix TypeError: opts.node.rangeBy is not a function_一抹阳光&amp;-CSDN博客</a></p></li><li><p><a href="https://azin-cn.github.io/2023/02/27/TypeError-opts-node-rangeBy-is-not-a-function/">TypeError: opts.node.rangeBy is not a function | Az’s Blog (azin-cn.github.io)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Stylelint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postcss </tag>
            
            <tag> stylelint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 无重复字符的最长子串 | 字符串搜索 | Map | 哈希</title>
      <link href="/2023/02/19/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2-Map-%E5%93%88%E5%B8%8C/"/>
      <url>/2023/02/19/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2-Map-%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环<br> 定义两个 <code>for</code>，第一个 <code>for</code> 顺序遍历，第二个 <code>for</code> 每次从头开始顺序检查，这样即可拿到最长长度，时间复杂度为 <code>O(n^2)</code>。</li><li>map 结构<br> 定义一个 <code>while</code>，利用一个 <code>map</code> 记录遍历到的字符，利用内部 <code>while</code> 进行检查是否有重复字符</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = <span class="number">0</span>, res = <span class="number">0</span>, len = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        <span class="keyword">let</span> char = s[r++], count = (map.<span class="title function_">get</span>(char) || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        map.<span class="title function_">set</span>(char, count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (map.<span class="title function_">get</span>(char) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> left = s[l++]</span><br><span class="line">            map.<span class="title function_">set</span>(left, map.<span class="title function_">get</span>(left) - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, r - l); <span class="comment">// 此时的r属于后一位，不需要+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://blog.csdn.net/qq_45759413/article/details/129108885">3. 无重复字符的最长子串 | 字符串搜索 | Map | 哈希_一抹阳光&amp;的博客-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. 两数相加 | 链表 | 链表长度 | 等价链表长度</title>
      <link href="/2023/02/13/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6-%E7%AD%89%E4%BB%B7%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6/"/>
      <url>/2023/02/13/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6-%E7%AD%89%E4%BB%B7%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>总体上可以分为两类，迭代和递归</p><ol><li>迭代<br>迭代链表在边界判断上具有许多方式，这里选择将两条链表看成是<strong>相等长度</strong>的，利用两个变量，<code>dummy</code>，<code>p</code> 记录节点位置，在内部实现保证迭代不出错即可<ul><li>将两条链表视为相等长度，但是实际过程中，需要判断链表是否已经遍历到头，也就是两个 <code>if</code></li><li>两条链表对应节点的 <code>val</code> 相加后再次存入</li><li>两个 <code>if</code> 保证其链表不会遍历出错，而 <code>dummy</code>，<code>p</code> 记录对应的节点，最终如果有 <code>carry</code> 则新建 <code>node</code> 节点</li><li>理解 <code>while</code> 和 两个 <code>if</code> 之间的转换</li></ul></li><li>递归<br>待完善</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTwoNumbers</span>(<span class="params">l1: ListNode | <span class="literal">null</span>, l2: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    <span class="keyword">if</span> (l1 === <span class="literal">null</span> &amp;&amp; l2 === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p1 = l1, p2 = l2, <span class="attr">dummy</span>: <span class="title class_">ListNode</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(), <span class="attr">p</span>: <span class="title class_">ListNode</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 !== <span class="literal">null</span> || p2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n1 = p1 === <span class="literal">null</span> ? <span class="number">0</span> : p1.<span class="property">val</span>;</span><br><span class="line">        <span class="keyword">const</span> n2 = p2 === <span class="literal">null</span> ? <span class="number">0</span> : p2.<span class="property">val</span>;</span><br><span class="line">        <span class="keyword">const</span> num = n1 + n2 + carry;</span><br><span class="line">        carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num / <span class="number">10</span>); <span class="comment">// JavaScript不是整除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实际过程中判断链表是否遍历到头，在遍历的过程中更新头节点和尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (p1 !== <span class="literal">null</span>) &#123;</span><br><span class="line">            dummy.<span class="property">next</span> = l1;</span><br><span class="line">            p = p1</span><br><span class="line">            p1.<span class="property">val</span> = num % <span class="number">10</span>;</span><br><span class="line">            p1 = p1.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">            dummy.<span class="property">next</span> = l2;</span><br><span class="line">            p = p2;</span><br><span class="line">            p2.<span class="property">val</span> = num % <span class="number">10</span>;</span><br><span class="line">            p2 = p2.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (carry !== <span class="number">0</span>) &#123;</span><br><span class="line">        p.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://blog.csdn.net/qq_45759413/article/details/129095739?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22129095739%22,%22source%22:%22qq_45759413%22%7D">2. 两数相加 | 链表长度_一抹阳光&amp;的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.两数之和 - Hash | 查找元素</title>
      <link href="/2023/01/07/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/01/07/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/two-sum/description/">1.两数之和</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li><p>暴力 for</p></li><li><p>查找时间为 <code>O(1)</code> 的 Hash，包括 Set 和 Map</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">twoSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> num = target - nums[i];</span><br><span class="line">    <span class="keyword">if</span>(map.<span class="title function_">has</span>(num)) &#123;</span><br><span class="line">      <span class="keyword">return</span> [map.<span class="title function_">get</span>(num), i];</span><br><span class="line">    &#125;</span><br><span class="line">    map.<span class="title function_">set</span>(nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25. K 个一组翻转链表 | 链表 | 递归 | 子问题分解</title>
      <link href="/2022/09/29/25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92-%E5%AD%90%E9%97%AE%E9%A2%98%E5%88%86%E8%A7%A3/"/>
      <url>/2022/09/29/25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92-%E5%AD%90%E9%97%AE%E9%A2%98%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>直接实现反转K个一组翻转链表可能非常困难，但是可以分成长度为K的子串，每一个字串分别反转并拼接，最后返回即可。</p><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>反转链表很容易实现，可以通过<strong>递归&#x2F;迭代</strong>的形式实现。<br>这里采用的是判断 递归 + 是否为null为basecase 实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span> || head.<span class="property">next</span> === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">const</span> prev = <span class="title function_">reverse</span>(head.<span class="property">next</span>);</span><br><span class="line">    head.<span class="property">next</span>.<span class="property">next</span> = head;</span><br><span class="line">    head.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转K个"><a href="#反转K个" class="headerlink" title="反转K个"></a>反转K个</h4><p>分析可以发现，整体的过程就可以分解成长度为 <code>K</code> 的部分字串，所以明显可以使用递归来实现。</p><ul><li>遍历当前的链表，如果<strong>长度不足 <code>k</code><strong>，则直接返回头节点，这里需要</strong>注意</strong>的是 <code>if</code> 判断条件需要放在p.next前还是后的问题</li><li>保留后驱节点以及设置满足反转的basecase，即记录 <code>successor</code> 和设置 <code>p.next = null</code></li><li>反转当前长度为 <code>k</code> 的字串，得到新的头节点</li><li>拼接 <code>当前的最新尾节点</code> 和 <strong><code>下一个</code></strong><code>最新的头节点</code></li><li>返回最新的头节点</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  理解题意：每隔K个就反转当前的短链表，不足K个则不反转</span></span><br><span class="line"><span class="comment">// 从理解提议中可以看出，每个K个就反转，不足K个不反转，可以使用子问题的方式，也就是可以使用递归</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverseKGroup</span>(<span class="params">head: ListNode | <span class="literal">null</span>, k: <span class="built_in">number</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; k; i++) &#123; <span class="comment">// 从1开始算</span></span><br><span class="line">        p = p.<span class="property">next</span>; <span class="comment">// 进行迭代</span></span><br><span class="line">        <span class="keyword">if</span> (p === <span class="literal">null</span>) <span class="keyword">return</span> head; <span class="comment">// 如果不足k个，直接返回当前的头节点，注意放在前面和放在后面的不同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下的过程表示需要反转当前的部分链表</span></span><br><span class="line">    <span class="keyword">let</span> successor = p.<span class="property">next</span>; <span class="comment">// 保留后驱节点</span></span><br><span class="line">    p.<span class="property">next</span> = <span class="literal">null</span>; <span class="comment">// 为了形成basecase，切断next指针，使其指向null</span></span><br><span class="line">    <span class="keyword">const</span> newHead = <span class="title function_">reverse</span>(head); <span class="comment">// 开始反转得到新头节点</span></span><br><span class="line">    head.<span class="property">next</span> = <span class="title function_">reverseKGroup</span>(successor, k); <span class="comment">// 最新的尾节点拼接下一个最新的头节点</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title class_">ListNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span> || head.<span class="property">next</span> === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">const</span> prev = <span class="title function_">reverse</span>(head.<span class="property">next</span>);</span><br><span class="line">    head.<span class="property">next</span>.<span class="property">next</span> = head;</span><br><span class="line">    head.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://blog.csdn.net/qq_45759413/article/details/127113946?spm=1001.2014.3001.5502">CSDN：25. K 个一组翻转链表 | 链表 | 递归 | 子问题分解_一抹阳光&amp;的博客</a></p><p><a href="https://juejin.cn/post/7148785599401426958">掘金：25. K 个一组翻转链表 | 链表 | 递归 | 子问题分解</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二. Web性能与安全 - 性能方向</title>
      <link href="/2022/09/08/%E4%BA%8C-Web%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8-%E6%80%A7%E8%83%BD%E6%96%B9%E5%90%91/"/>
      <url>/2022/09/08/%E4%BA%8C-Web%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8-%E6%80%A7%E8%83%BD%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="深入理解浏览器缓存机制"><a href="#深入理解浏览器缓存机制" class="headerlink" title="深入理解浏览器缓存机制"></a>深入理解浏览器缓存机制</h2><p><img src="/assets/image-20220907085640-8nz781x.png" alt="image"></p><p>缓存是提升网页性能最好的方式之一，开发者只需要控制几个字段就可以减少大量的数据传输和低效的网络请求。</p><p>目前几乎所有的<strong>缓存控制字段</strong>是来源于后端服务器的<strong>响应</strong>，这里不包括浏览器的存储如 <code>Storage</code>，<code>IndexedDB</code>。为什么前端工程师还需要学网络http部分？</p><p>答案是前端工程师才更了解业务的具体场景是什么，如图片加载缓存优化。前端不直接控制缓存字段，而是与后端沟通定义当前<strong>场景的缓存策略</strong>，只有了解了缓存有哪些策略才能够针对某一场景的缓存进行优化。</p><blockquote><p>由于之前一上来就是各种复杂的缓存组合策略，所以学而退，退而学。参考前辈的笔记，从主流的控制字段结合分析缓存字段的发展，相信会有入门理解的收获。</p></blockquote><p>一个数据请求过程可以分成发起网络请求，服务器处理，浏览器响应三个部分。浏览器缓存能够在第一、第三阶段，也就是发起网络请求、浏览器响应优化性能。比如第一阶段直接使用缓存<strong>不发起请求</strong>，第三阶段浏览器发起请求了但是请求资源未变化，不需要重新传送，<strong>减少响应数据</strong>。</p><p>学习缓存需要认识<strong>缓存位置</strong>，<strong>缓存策略</strong>以及实际场景<strong>如何应用缓存策略</strong>。</p><h2 id="1-缓存位置"><a href="#1-缓存位置" class="headerlink" title="1. 缓存位置"></a>1. 缓存位置</h2><p>从缓存位置上来说缓存分为四种，并各有优先级，按照优先级查找缓存，找到且符合要求即结束查找并返回，注意Chrome中，Memory Cache优先级是最高的</p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><h3 id="1-1-Service-Worker（可先不深入，但需要了解）"><a href="#1-1-Service-Worker（可先不深入，但需要了解）" class="headerlink" title="1.1 Service Worker（可先不深入，但需要了解）"></a>1.1 Service Worker（可先不深入，但需要了解）</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。 <strong>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的</strong> 。</p><p>Service Worker 检查资源是否存在其缓存中，并根据其编程的缓存策略决定是否返回资源。这个操作不会自动发生，需要在注册的 Service Worker 中定义 <code>fetch</code> 事件去拦截并处理网络请求，这样才能命中 Service Worker 缓存而不是网络或者 HTTP 缓存。</p><p>简单的理解：<strong>前端</strong>定义规则手动控制文件的缓存，利用<code>fetch</code>事件，在发送网络请求前拦截并检查本地是否缓存了数据，以决定是否发起网络请求。相信作为一名前端工程师会有本地存储 token 的经验，发起网络请求前检查本地的 token，如果 token 不存在可以直接返回，不发起请求，Service Worker就是类似的工作原理。</p><p>Service Worker 看起来也是一个缓存技术，为什么要使用 Service Worker？</p><p>答案：</p><ul><li><p>提高WebApp的离线缓存能力，缩小 WebApp 与 NativeApp 之间差距。在无网情况下发起一个网络请求，网页会一直加载，最后跳出网络未连接的提示，而原生的App即使是在无网络情况下如单机游戏，还是正常运行。</p></li><li><p>事件同步：即使关闭了当前 Web 页面也可以正常工作。如 Web 邮件客户端通知</p></li><li><p><a href="https://x5.tencent.com/product/service-worker.html#:~:text=Service%20Worker%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF,1%E3%80%81%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%EF%BC%9A%E5%8F%AF%E4%BB%A5%E5%B0%86H5%E5%BA%94%E7%94%A8%E4%B8%AD%E4%B8%8D%E5%8F%98%E5%8C%96%E7%9A%84%E8%B5%84%E6%BA%90%E6%88%96%E8%80%85%E5%BE%88%E5%B0%91%E5%8F%98%E5%8C%96%E7%9A%84%E8%B5%84%E6%BA%90%E9%95%BF%E4%B9%85%E7%9A%84%E5%AD%98%E5%82%A8%E5%9C%A8%E7%94%A8%E6%88%B7%E7%AB%AF%EF%BC%8C%E6%8F%90%E5%8D%87%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E3%80%81%E9%99%8D%E4%BD%8E%E6%B5%81%E9%87%8F%E6%B6%88%E8%80%97%E3%80%81%E9%99%8D%E4%BD%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E3%80%82%20%E5%A6%82%E4%B8%AD%E9%87%8D%E5%BA%A6%E7%9A%84H5%E6%B8%B8%E6%88%8F%E3%80%81%E6%A1%86%E6%9E%B6%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E7%9A%84web%E8%B5%84%E8%AE%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%81web%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AD%89">腾讯浏览服务-Service Worker (tencent.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/115243059">service worker 是什么？看这篇就够了 - 知乎 (zhihu.com)</a></p></li></ul><h3 id="1-2-Memory-Cache"><a href="#1-2-Memory-Cache" class="headerlink" title="1.2 Memory Cache"></a>1.2 Memory Cache</h3><p>Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。  <strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了</strong> 。</p><blockquote><p>既然内存缓存效率那么高，是不是可以将所有的缓存都使用内存来存储呢？</p></blockquote><blockquote><p>这是不可能的。首先从容量上看，计算机内存容量比硬盘小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。其次，内存在断电情况下不保存数据的，所以不可能将所有的数据都放在内存。</p></blockquote><p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存（Size字段）</p><p><img src="/assets/image-20220907185452-fa5jojc.png" alt="image"></p><blockquote><p>古老的浏览器解析一个网页的流程是串行的，网络请求下载，解析，网络请求下载另外一个文件，解析。现代的浏览器都是并行下载的，即一边解析，一边可能几个线程在下载不同的资源文件。</p></blockquote><p>内存缓存中有一块重要的缓存资源是 <code>preloader</code> 、<code>preload</code>相关指令（例如<code>&lt;link rel=&quot;prefetch&quot;&gt;</code>）下载的资源。总所周知 preloader 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js&#x2F;css 文件，一边网络请求下一个资源，并不一定只是一个网络请求，可能同时存在多个线程在下载资源。关于缓存字段，将在下文详细介绍。</p><p>需要注意的是：<strong>内存缓存在缓存资源时并不关心 HTTP 缓存头 Cache-Control 是什么值</strong>，<strong>同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type ， CORS 等其他特征做校验</strong> 。</p><p>简单总结：目前几乎所有的 <strong>HTTP缓存控制字段</strong> 都来源于后端服务的<strong>响应</strong>，在Chrome中，内存缓存的优先级是最高的。内存缓存不关心HTTP响应的缓存头字段，同时资源的匹配也并非只是对URL做匹配，还可能会对Content-TYpe，CORS等其他特征做校验。</p><h3 id="1-3-Disk-Cache"><a href="#1-3-Disk-Cache" class="headerlink" title="1.3 Disk Cache"></a>1.3 Disk Cache</h3><p>Disk Cache 是存储在硬盘上的缓存，虽然读取速度较慢，但是什么都能存储到磁盘中， <strong>比之 Memory Cache 胜在容量和存储时效性上</strong> ，能够长时间的保存缓存。</p><blockquote><p>在所有浏览器缓存中，<strong>Disk Cache 覆盖面基本是最大的</strong>。它会根据 HTTP Herder 中的<strong>缓存字段判</strong>断哪些资源需要缓存，哪些资源可以不请求<strong>直接使用</strong>，哪些资源已经过期需要<strong>重新请求</strong>。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p><p>例如：常见的JQuery压缩包，在Disk Cache缓存后，所有使用JQuery的站点都可以使用本地缓存的JQuery。</p></blockquote><p>绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p><p>那么浏览器什么时候会将资源缓存到硬盘中呢？关于这点，网上说法不一，不过以下观点比较靠得住：</p><ul><li>对于<strong>大文件</strong>来说，大概率是不存储在内存中的，反之优先</li><li>当前<strong>系统内存使用率高</strong>的话，文件优先存储进硬盘</li></ul><p>简单总结 Disk Cache</p><ul><li>容量大</li><li>时间长</li><li>跨站点</li><li>覆盖范围最广</li></ul><h3 id="1-4-Push-Cache（需要了解，但在Service-Worker之后）"><a href="#1-4-Push-Cache（需要了解，但在Service-Worker之后）" class="headerlink" title="1.4 Push Cache（需要了解，但在Service Worker之后）"></a>1.4 Push Cache（需要了解，但在Service Worker之后）</h3><p>Push Cache（推送缓存）是 HTTP&#x2F;2 中的内容，按照缓存的优先级，当以上三种缓存都没有命中时，它才会被使用。 <strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂</strong> ，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP&#x2F;2 在国内不够普及。这里推荐阅读<code>Jake Archibald</code>的 <a href="https://links.jianshu.com/go?to=https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">HTTP&#x2F;2 push is tougher than I thought</a> 这篇文章，文章中的几个结论：</p><ul><li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</li><li>可以推送 no-cache 和 no-store 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用同一个HTTP&#x2F;2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>你可以给其他域名推送资源</li></ul><h2 id="2-缓存过程分析（缓存策略）"><a href="#2-缓存过程分析（缓存策略）" class="headerlink" title="2. 缓存过程分析（缓存策略）"></a>2. 缓存过程分析（缓存策略）</h2><p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。那么为了性能上的考虑，大部分的接口都应该选择好缓存策略， <strong>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的</strong> 。</p><p>浏览器与服务器通信的方式为<strong>应答模式</strong>，即是：浏览器发起HTTP请求 – 服务器响应该请求， <strong>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢</strong> ？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存， <strong>即浏览器对资源缓存的处理是根据第一次请求资源时返回的响应头来确定的</strong> 。具体过程如下图：</p><p><img src="/assets/image-20220907235229-v01zwzm.png" alt="image" title="第一次缓存过程"></p><blockquote><p>无论是什么时候发起的请求，浏览器首先匹配浏览器缓存，如果没有缓存命中或者缓存过期才会发送网络请求请求最新资源。在资源响应后，浏览器会根据HTTP响应中的<strong>缓存字段</strong>来控制缓存方式（若无缓存字段，则为默认缓存方式，默认缓存方式在下文介绍）。</p></blockquote><p>由上图我们可以知道：</p><ul><li>浏览器每次发起请求，都先在浏览器缓存中<strong>查找</strong>该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识<strong>存入浏览器缓存</strong>中</li></ul><p>以上两点结论就是浏览器缓存机制的关键，<strong>浏览器查找和存入确保了每个请求的缓存存入与读取</strong>，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据<strong>是否需要向服务器重新发起HTTP请求</strong>将缓存过程分为两个部分，分别是强缓存和协商缓存。</p><h2 id="3-强缓存和协商缓存"><a href="#3-强缓存和协商缓存" class="headerlink" title="3. 强缓存和协商缓存"></a>3. 强缓存和协商缓存</h2><p>强缓存和协商缓存两个<strong>阶段</strong>并不容易理解，读者需要细心阅读并反复思考。</p><p>按照是否需要<strong>向服务器重新发起HTTP请求</strong>将缓存的过程分为两个部分，<strong>强缓存阶段和协商缓存阶段</strong>。<strong>Memory Cache 和 Disk Cache 都属于强缓存</strong>。现代浏览器缓存存储图像和网页等(主要在磁盘上)，而你的操作系统缓存文件可能大部分在内存缓存中。</p><p>注意：<strong>强缓存和协商缓存是一个阶段</strong>，而不是指具体的缓存位置或形式。</p><p>浏览器每次发送请求前都会检查自身缓存，称为<strong>强缓存</strong>阶段，具有不存在、存在两种情况</p><ul><li><p>缓存不存在，属于强缓存失效阶段，请求新资源</p></li><li><p>缓存存在，可以分成未过期、已过期两种情况</p><ul><li><p>缓存未过期，属于强缓存<strong>生效</strong>，那么<strong>结束</strong>并返回对应缓存</p></li><li><p>缓存已过期，属于强缓存<strong>失效</strong>，那么进入<strong>协商</strong>缓存阶段，可以分成生效，失效两种情况</p><ul><li>服务器资源未修改，返回 <strong>304</strong>，属于协商缓存生效</li><li>服务器资源已修改，返回 <strong>200</strong>，属于协商缓存失效</li></ul></li></ul></li></ul><p>从以上分析中可以得到结论</p><p>每一次网络请求都会进入强缓存阶段，当 <strong>缓存存在</strong> 且 <strong>缓存已过期</strong> 时才能进入协商缓存阶段。<strong>缓存不存在</strong>时发起的网络请求不属于协商缓存阶段，这一点和后续的协商缓存容易混淆，也请记住<strong>缓存不存在</strong>能表达的两种情况，第一次请求和请求后被删除。特殊的，当<strong>缓存存在</strong>时，强缓存中有一个字段 <code>Cache-Control: no-cache</code> 可以直接使强缓存失效并进入协商缓存，将在强缓存中详细介绍。</p><p>简单总结：浏览器发送请求前检查自身缓存，属于强缓存阶段；<strong>缓存存在</strong> 且 <strong>缓存已过期，需要重新发起网络请求</strong>则是协商缓存阶段。</p><h3 id="3-1-强缓存"><a href="#3-1-强缓存" class="headerlink" title="3.1 强缓存"></a>3.1 强缓存</h3><p>强缓存：<strong>不会向服务器重新发送请求，直接从缓存中读取资源</strong>，在 Chrome 控制台的 Network 选项中可以看到该请求返回 <strong>200</strong> 的状态码，并且 Size 显示from disk cache 或 from memory cache。</p><p>强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p><h4 id="3-1-1-Expires"><a href="#3-1-1-Expires" class="headerlink" title="3.1.1 Expires"></a>3.1.1 Expires</h4><p><strong>Expires：缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点</strong> 。也就是说，Expires &#x3D; max-age + 请求时间，需要和 Last-modified 结合使用。Expires 是 Web 服务器<strong>响应消息头字段</strong>，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p><strong>Expires 是 HTTP&#x2F;1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效</strong> 。<code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code> 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。如果修改当前的时间查过Expires给定的时间，那么浏览器就会重新发起请求，进入<strong>协商缓存阶段</strong>。</p><h4 id="3-1-2-Cache-Control"><a href="#3-1-2-Cache-Control" class="headerlink" title="3.1.2 Cache-Control"></a>3.1.2 Cache-Control</h4><p>在 HTTP&#x2F;1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当<code>Cache-Control:max-age=300</code>时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p><p><img src="/assets/image-20220908002252-w0l3req.png" alt="image" title="组合使用多种指令"></p><ul><li><p><strong>public</strong> ： <strong>所有内容都将被缓存（客户端和代理服务器都可缓存）</strong> 。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;–  proxy2 &lt;– Server，中间的 proxy 可以缓存资源，比如下次再请求同一资源 proxy1 直接把自己缓存的东西给 Browser 而不再向 proxy2 要。</p></li><li><p><strong>private</strong> ： <strong>所有内容只有客户端可以缓存</strong> ，Cache-Control 的默认取值。具体来说，表示中间节点不允许缓存，对于 Browser &lt;– proxy1 &lt;–  proxy2 &lt;– Server，proxy 会老老实实把 Server 返回的数据发送给 proxy1，自己不缓存任何数据。当下次 Browser 再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。</p></li><li><p><strong>no-cache</strong> ：<strong>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。</strong>表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。<strong>需要注意的是，no-cache 这个名字有一点误导。设置了 no-cache 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</strong></p></li><li><p><strong>no-store</strong> ：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。</p></li><li><p><strong>max-age</strong> ：max-age&#x3D;xxx (xxx is numeric) 表示缓存内容将在当前响应时间的xxx秒后失效，一般响应头中会包含 Date 字段。</p></li><li><p><strong>s-maxage</strong> （单位为s)：同 max-age 作用一样，只在代理服务器中生效（比如CDN缓存）。比如当 s-maxage&#x3D;60 时，在这 60 秒中，即使更新了 CDN 的内容，浏览器也不会进行请求。max-age 用于普通缓存，而 s-maxage 用于代理缓存。 <strong>s-maxage 的优先级高于 max-age</strong> 。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。</p></li><li><p><strong>max-stale</strong> ：能容忍的最大过期时间。max-stale 指令标示了客户端愿意接收一个已经过期了的响应。如果指定了 max-stale 的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何 age 的响应（age 表示响应由源站生成或确认的时间与当前时间的差值）。</p></li><li><p><strong>min-fresh</strong> ：能够容忍的最小新鲜度。min-fresh 标示了客户端不愿意接受新鲜度不多于当前时间加上 min-fresh 设定的时间之和的响应。简单来说不要太新的资源。</p></li></ul><p><img src="/assets/image-20220908002929-cfakxvf.png" alt="image" title="强缓存流程分析"></p><p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。</p><p>Cache-Control字段属性解读</p><ul><li>可被复用指的是资源能否被缓存，不能缓存的标识是 <code>no-store</code>。</li><li>资源在使用时是否保持一致指的是是否需要每次都检查资源有效性。<code>no-cache</code> 的设计很容易让人误解，<code>no-cache</code> 指的是每次使用缓存资源是否都需要向服务器验证是否过期，如果不过期则返回 <strong>304</strong> 和空响应体表示直接使用缓存，过期则重新返回 <strong>200</strong> 和最新资源。</li><li>在网络请求中，可能会经过代理服务器，<code>public, private</code> 控制是否允许代理服务器缓存资源，<code>public</code> 表示均允许缓存，<code>private</code> 表示仅有客户端才允许缓存。</li><li>权限设置完成后，便是指定缓存的时效。代理服务器缓存有属性 <code>s-maxage</code> 属性，客户端缓存有属性 <code>max-age</code> 和缓存字段 <code>Expires</code> 控制时效。Cache-Control字段的优先级高于Expires字段，Cache-Control字段中的属性 <code>s-maxage</code>优先级高于 <code>max-age</code>。注意区分属性的优先级和字段的优先级。</li><li>最大过期时间设置后，还可以设置允许的最大过期时间 <code>max-state</code> 和允许的最小新鲜时间 <code>min-fresh</code>。</li></ul><h4 id="3-1-3-Expires-和-Cache-Control"><a href="#3-1-3-Expires-和-Cache-Control" class="headerlink" title="3.1.3 Expires 和 Cache-Control"></a>3.1.3 Expires 和 Cache-Control</h4><p>其实这两者差别不大，区别就在于 Expires 是 HTTP1.0 的产物，Cache-Control是HTTP1.1 的产物，两者同时存在的话，Cache-Control 优先级高于 Expires；在某些不支持 HTTP1.1 的环境下，Expires 就会发挥用处。所以 Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p><p>强缓存判断缓存是否有效的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新。Expires、Cache-Control 字段依赖于本地时间 +  过期时间 + 允许最大过期时间。</p><blockquote><p>如果设置max-age&#x3D;60s，请求完成后的 60s 内服务端修改了资源，那么浏览器获得的资源是什么呢？浏览器在 60s 内不会重新请求资源，这就导致浏览器获得的资源不是最新的。</p></blockquote><p>强缓存的判断策略可能会导致加载文件不是服务器端最新的内容，是否还记得在 Cache-Control 中，具有一个属性 <code>no-cache</code>，表示跳过强缓存阶段，每次使用资源都需要发送请求和服务器确认是否为最新资源。可以认为<code>no-cache</code> 正是解决因为依赖于时间的判断没有极高靠性问题而出现的。</p><p>那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。</p><h3 id="3-2-协商缓存"><a href="#3-2-协商缓存" class="headerlink" title="3.2 协商缓存"></a>3.2 协商缓存</h3><p>协商缓存就是在 <strong>缓存存在</strong> 且 <strong>缓存已过期</strong> 的情况下，浏览器（重新）发送网络请求请求最新的资源的过程。特殊的，当<strong>缓存存在</strong>，强缓存中的一个属性 <code>Cache-Control:no-cache</code> 可以让强缓存失效并进入协商缓存。</p><p>协商缓存有两种情况</p><ul><li>服务器返回 <strong>304</strong> 和 Not Modified，协商缓存生效</li></ul><p><img src="/assets/image-20220908093254-l6lldq5.png" alt="image.png"></p><ul><li>服务器返回 <strong>200</strong> 和 最新资源，协商缓存失效</li></ul><p><img src="/assets/image-20220908113245-vjb4pbx.png" alt="image.png"></p><p><strong>条件：</strong>是否还记得进入协商缓存的要求？<strong>缓存存在</strong> 且 <strong>缓存已过期</strong> 是进入协商缓存的必要条件，特殊的，当<strong>缓存存在</strong>，强缓存中的一个属性 <code>Cache-Control:no-cache</code> 可以让强缓存失效并进入协商缓存。强缓存中通过 Expires 或 Cache-Control: max-age 判断缓存是否过期，那么在协商缓存中，如何确定是否协商生效呢？或者说服务器如何确定是否返回资源。</p><p>这个确定的方法很简单，协商缓存可以通过设置两种<strong>响应</strong> HTTP Header 实现，<strong>Last-Modified 和 ETag</strong> 。</p><h4 id="3-2-1-Last-Modified"><a href="#3-2-1-Last-Modified" class="headerlink" title="3.2.1 Last-Modified"></a>3.2.1 Last-Modified</h4><p>Last-Modified 字段是当前资源<strong>缓存不存在</strong>，请求成功后<strong>响应头</strong>中携带的参数字段，而后被浏览器缓存。Last-Modified 的值是这个资源在服务器上的<strong>最后修改时间</strong>，浏览器接收后缓存文件和 header 信息。</p><p>注意：缓存不存在能够表示两种情况：第一次请求、请求后被删除</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Fri, 22 Jul 2016 01:47:00 GMT</span><br></pre></td></tr></table></figure><p>浏览器下一次请求这个资源，浏览器检测到当前资源缓存中有 Last-Modified 这个 header 字段，于是在<strong>请求头</strong>中添加 If-Modified-Since 这个 header 字段，值就是 缓存的 header 信息中 Last-Modified 字段的值，服务器收到这个资源请求，会根据 If-Modified-Since 的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 <strong>304</strong> 和<strong>空的响应体</strong>，表示浏览器直接从缓存读取资源，此时表示<strong>协商缓存生效</strong>；如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回 <strong>200</strong> 和<strong>新的资源文件</strong>，此时表示<strong>协商缓存失效</strong>。返回 <strong>304</strong> 能够有效的降低数据的传输量，这也是为什么缓存能够提高性能的原因。</p><p><strong>简单总结：</strong>Last-Modified 和 If-Modified-Since 是配对的，Last-Modified 是缓存不存在时，发送网络请求且请求成功后携带的<strong>响应头</strong>的字段，而后被浏览器缓存，当浏览器再一次请求这个资源，浏览器检查缓存并发现 Last-Modified 字段，就会在<strong>请求头</strong>上添加 If-Modified-Since 字段，值就是 Last-Modified 的值。服务器收到请求后对比 if-Modified-Since 和 服务器中改资源的最后修改时间，如果相等返回 <strong>304</strong> 和空响应体，响应头中还会有 Last-Modified 字段，此时表示<strong>协商缓存生效</strong>，如果不相等则会返回 <strong>200</strong> 和最新资源，<strong>响应头</strong>中携带最新的最后修改时间即 Last-Modified 字段，此时表示协商缓存失效，浏览器缓存当前资源和 header 信息。</p><p><img src="/assets/image-20220908133821-ssuujgp.png" alt="image.png" title="协商缓存失效、生效"></p><p>Last-Modified 具有一些弊端</p><ul><li>如果<strong>本地</strong>打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified <strong>被修改</strong>，服务端不能命中缓存导致发送相同的资源</li><li>因为 Last-Modified 只能以秒计时，如果在<strong>不可感知的时间内</strong>修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li></ul><p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以 HTTP1.1 出现了 <code>ETag</code> 和 <code>If-None-Match</code>。</p><h4 id="3-2-2-ETag"><a href="#3-2-2-ETag" class="headerlink" title="3.2.2 ETag"></a>3.2.2 ETag</h4><p>ETag 和 Last-Modified 类似，是在<strong>缓存不存在</strong>时，浏览器发起请求，请求成功后<strong>响应头</strong>携带的字段，而后被浏览器缓存。与 Last-Modified 不同的是 ETag 的值是根据某一算法如哈希生成的文件唯一标识，<strong>只要资源有变化，ETag就会重新生成</strong> 。</p><p>浏览器在下一次加载该资源向服务器发送请求时，浏览器检查到当前资源的缓存具有 ETag，则会将缓存中的 ETag 值放到<strong>请求头</strong>中的 If-None-Match，服务器只需要比较客户端传来的 If-None-Match 和服务器上该资源的 ETag 是否一致，就能判断资源相对客户端是否被修改过。如果服务器发现 ETag 匹配不上，那么直接以常规 <strong>200</strong> 回包形式将新的资源（当然也包括了新的 ETag）发给客户端，此时表示<strong>协商缓存失效</strong>，浏览器缓存新的资源和 header 信息；如果 ETag 是一致的，则直接返回 <strong>304</strong> 和空响应体知会客户端直接使用本地缓存即可，此时响应头中还是携带有 ETag。</p><p><img src="/assets/image-20220908135926-h1v1twu.png" alt="image.png"></p><p>ETag 和 If-Node-Match 是配对的，与 Last-Modified 和 If-Modifed-Since 一样，但是 ETag 是使用的是文件的唯一标识，能够提升可靠性，但是因为需要计算文件的唯一标识，所以性能会比Last-Modified低。</p><h4 id="3-2-3-Last-Modified-和-ETag"><a href="#3-2-3-Last-Modified-和-ETag" class="headerlink" title="3.2.3 Last-Modified 和 ETag"></a>3.2.3 Last-Modified 和 ETag</h4><p>在<strong>缓存不存在</strong>时，浏览器发起网络请求请求资源，请求成功后，浏览器缓存资源文件和缓存 header 信息，在协商缓存阶段检查缓存的 header 信息，如果是 ETag 则给请求投添加 If-None-Match，如果是 Last-Modified，则给请求头添加 If-Modified-Since，服务器对字段做检查比较，决定协商缓存是否生效。注意：ETag 优先级高于 Last-Modified，也就是说会优先使用 ETag。</p><p>简单总结</p><ul><li>在精确度上，ETag 要优于 Last-Modified。</li></ul><p>Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么它们的Last-Modified 其实并没有体现出来修改，但是 ETag 每次都会改变确保了精度；<strong>如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致</strong>。</p><ul><li>在性能上，ETag 要逊于 Last-Modified，因为 Last-Modified 只需要记录时间，而 ETag 需要服务器通过算法来计算出一个 hash 值。</li><li>在优先级上，服务器校验优先考虑 ETag</li></ul><h2 id="4-缓存机制"><a href="#4-缓存机制" class="headerlink" title="4. 缓存机制"></a>4. 缓存机制</h2><p><strong>强缓存</strong>优先于<strong>协商缓存</strong>，若强制缓存 ( Expires 和 Cache-Control ) 生效则直接使用缓存，若不生效则进行协商缓存 (Last-Modified &#x2F; If-Modified-Since和Etag &#x2F; If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 <strong>200</strong>，重新返回资源和缓存标识，浏览器将缓存资源和 header 信息，此时表示<strong>协商缓存失效</strong>，若<strong>协商缓存生效</strong>则返回 <strong>304</strong> 和空响应体，表示继续使用缓存，此时响应头中仍然携带缓存控制字段， 此时表示协商缓存成功。</p><p>协商缓存只有在 <strong>缓存存在</strong> 且 <strong>缓存已过期</strong> 时才允许进入，特殊的，当缓存存在时，强制缓存（强缓存）的一个字段 <code>Cache-Control:no-cache</code> 可以强制缓存失效并进入协商缓存阶段，其原因就是 <code>Cache-Control:no-cache</code> 字段信息允许不检查强制缓存。</p><p><img src="/assets/image-20220908141753-3z6jz59.png" alt="image.png" title="缓存机制"></p><p>如果没有指定缓存策略，缓存的字段信息，那么浏览器会如何做呢？</p><p>对于这种情况，<strong>浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。</strong></p><h2 id="5-实际场景应用缓存策略"><a href="#5-实际场景应用缓存策略" class="headerlink" title="5. 实际场景应用缓存策略"></a>5. 实际场景应用缓存策略</h2><h3 id="5-1-频繁变动的资源"><a href="#5-1-频繁变动的资源" class="headerlink" title="5.1 频繁变动的资源"></a>5.1 频繁变动的资源</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br></pre></td></tr></table></figure><p>频繁变动的资源对时效性要求比较强，从直观上，可以不使用缓存字段，但是不使用缓存字段就意味着默认缓存策略即<strong>浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间</strong>，这不符合要求。</p><p>最理想的策略是：每当有该资源的请求时，就和服务器确认资源是否发生了变化，如果发生了变化则重新传送数据，如果没有发生变化则使用本地的缓存数据。</p><p>解析：按照理想策略，应该请服务器来鉴定资源有效性。每一个请求都会进入强缓存阶段，所以需要跳出强缓存阶段，接着才能请服务器鉴定。而使强缓存失效的方法有两种，资源不存在，资源已过期。可以设置<code>Cache-Control: max-age=0</code>，每一次请求都会发现资源过期，强缓存失效并进入协商缓存，携带 ETag 或 Last-Modified 并进行请求，服务器对比值决定协商缓存是否生效。之前也声明过，特殊的，在缓存存在时，强缓存的<code>Cache-Control: no-cache</code> 可以使强缓存失效并进入协商缓存，即跳过强缓存的检查（会进入强缓存阶段，但跳过对比检查）进入协商缓存，刚好符合频繁变动的缓存需求，所以这两种方式都可以，只不过设置过期时间方式浏览器会多做一步过期的检查。</p><h3 id="5-2-不常变化的资源"><a href="#5-2-不常变化的资源" class="headerlink" title="5.2 不常变化的资源"></a>5.2 不常变化的资源</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=31536000</span><br></pre></td></tr></table></figure><p>通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 <code>max-age=31536000</code> (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等<strong>动态字符</strong>，之后<strong>更改动态字符</strong>，从而达到<strong>更改引用 URL</strong> 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。</p><p>在线提供的类库 (如 <code>jquery-3.3.1.min.js</code>, <code>lodash.min.js</code> 等) 均采用这个模式。</p><h2 id="6-用户行为对缓存的影响"><a href="#6-用户行为对缓存的影响" class="headerlink" title="6. 用户行为对缓存的影响"></a>6. 用户行为对缓存的影响</h2><p>所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p><ul><li>打开网页，地址栏输入地址， 查找 Disk Cache 中是否有匹配。如有则使用，如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 Memory Cache 是可用的，会被优先使用(如果匹配的话)。其次才是 Disk Cache。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的<strong>请求头</strong>部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了 <code>Pragma: no-cache</code>),服务器直接返回 200 和最新内容。</li></ul><p>需要分清楚<strong>请求头</strong>中的 no-cache 和<strong>响应头</strong>中的 no-cache，两者的作用是不相同的。</p><p><strong>请求头</strong>的 no-cache 表示浏览器不想读缓存，并不是说没有缓存。一般在浏览器按 Ctrl+F5 强制刷新时，请求头里就有这个no-cache，也就是跳过强缓存和协商缓存阶段，直接请求服务器。（如果直接按F5的话，请求头是 max-age&#x3D;0，只跳过强缓存，但进行协商缓存）。</p><p><strong>响应头</strong>的 no-cache 表示跳过强缓存检查（会进入强缓存阶段，但不检查时间，使强缓存失效并接入协商缓存，max-age&#x3D;0 检查时间，使强缓存失效，再进入协商缓存）</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>缓存能够有效的减少网络请求数量或降低网络传送的数据量，主要用于页面的性能优化、降低数据流量成本等。</p><p>认识学习缓存需要从缓存的位置、缓存的策略和实际场景应用缓存策略三个方面入手。了解缓存位置可以知晓浏览器将缓存放在哪，各种不同的缓存位置有什么优势；了解基础缓存策略（强缓存、协商缓存可以看成是本地判断和远程判断）可以知晓缓存优先级需要控制在哪，是强缓存还是协商缓存。基础缓存策略配合缓存位置，就可以组合出针对不同场景地各种复杂的缓存方式。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.jianshu.com/p/54cc04190252">深入理解浏览器的缓存机制 - 简书 (jianshu.com)</a></li><li><a href="https://juejin.cn/post/6844903747357769742?utm_source=gold_browser_extension">一文读懂前端缓存 - 掘金 (juejin.cn)</a></li><li><a href="https://www.cnblogs.com/cxyqts/p/13093564.html">http缓存强制缓存和协商缓存？- 博客园 (cnblogs.com)</a></li><li><a href="https://juejin.cn/post/7031923575044964389">后端一次给你10万条数据，如何优雅展示，到底考察我什么? - 掘金 (juejin.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web性能与安全 </tag>
            
            <tag> 性能 </tag>
            
            <tag> 安全 </tag>
            
            <tag> Web </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三. 浏览器内部工作原理-解析方向（总）</title>
      <link href="/2022/09/06/%E4%B8%89-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E6%80%BB%EF%BC%89/"/>
      <url>/2022/09/06/%E4%B8%89-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E6%80%BB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为方便读者阅读，贴出以下参考链接，在此感谢前辈笔记。</p><p>浏览器解析过程分析：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>浏览器工作过程分析：<a href="https://zhuanlan.zhihu.com/p/96986818">万字详文：深入理解浏览器原理 - 知乎 (zhihu.com)</a></p><h2 id="1-树的构建流程"><a href="#1-树的构建流程" class="headerlink" title="1. 树的构建流程"></a>1. 树的构建流程</h2><p><img src="/assets/image-20220902091918-3jgz0jo.png" alt="image.png"></p><p>HTML 和 CSS 的页面解析是从上之下的，<strong>线程的</strong>。文档流从上往下，若先碰到了 CSS，那么开始解析，接着<strong>不被阻塞的</strong>继续向下解析 HTML，这样既符合并行解析，又符合文档流自上往下解析规则。浏览器先下载 HTML 文件开始解析，遇到 CSS 标签就开始下载 CSS 并解析，这个过程不会阻塞 DOM 的构建。最后 DOM 树和 CSS 规则树生成渲染树，HTML 解析完成。</p><p>注意几点：</p><ol><li>CSS 加载不会阻塞 DOM 树的<strong>解析</strong></li><li>CSS 加载会阻塞 DOM 树的<strong>渲染</strong>（不阻塞解析），即合并成渲染树的过程，因为样式可能会导致重排重绘</li><li>CSS 加载会阻塞后面 JS 语句的执行</li></ol><p>解析、渲染这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时还可能通过网络下载其余内容。</p><h3 id="1-1-HTML-Parser"><a href="#1-1-HTML-Parser" class="headerlink" title="1.1 HTML Parser"></a>1.1 HTML Parser</h3><h4 id="1-1-1-解析"><a href="#1-1-1-解析" class="headerlink" title="1.1.1 解析"></a>1.1.1 解析</h4><p>解析的目的是：将文档转换为具有一定意义的结构，编码时可以理解和使用的东西。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。</p><blockquote><p>解析的目的在于让目标更接近于需要使用的形式，或更具体的描述一些信息。如高级语言先转换为汇编等低级语言，最后再转换成机器码，又或者是家具的运输与组装，零件形式更接近于运输模式，成品形式更接近于使用模式，由成品拆分成零件就是使其更接近于运输模式，同样的道理将文档解析成另外一个格式会更适合某一个场景的使用。</p></blockquote><p>如解析“2＋3－1”这个表达式，可能返回这样一棵树。</p><p><img src="/assets/image-20220902121038-5xudoir.png" alt="image.png"></p><p>解析过程与翻译过程类似，需要具备两个条件，字典和语法规则。</p><p><strong>文法（Grammars）</strong>：解析基于文档依据的语法规则——文档的语言或格式。每种可被解析的格式必须具有由词汇及语法规则组成的特定的文法，称为上下文无关文法。简单来说就是由词汇表、语法规则组成的对某一个格式的限制，与当前文件内容无关。</p><blockquote><p>文法不等于语法规则，文法是词汇表和语法规则的结合，如语法规则定义为“<strong>的</strong>字后面跟着表示事物的名词，<strong>地</strong>字跟在动词后面，<strong>得</strong>字后面跟着形容词”，词汇表则有“谁，得，的，地，花，走，快”，文法规则就是词汇表和语法规则的结合，包含任何一个可能选择，如“谁的花，走得快，的，得，地”等。</p></blockquote><p>解析可以分成两个子过程：</p><ul><li>词法分析</li><li>语法分析</li></ul><p><strong>词法分析</strong>是将文档中的字词按照一定地规则（词汇表）分成符号，符号对应的便是词汇表（基本有效单元的集合）中的某一项。对于人类语言来说，它相当于我们字典中出现的所有单词。</p><p><strong>语法分析</strong>是根据语法规则匹配词法分析后的符号，生成特定状态的过程。</p><p>词法分析器（有时也叫分词器）负责将输入分解为合法的符号，语法分析器则根据语言的语法规则分析文档结构，从而构建解析树，词法分析器知道怎么跳过空白和换行之类的无关字符。</p><p><img src="/assets/image-20220902133652-u2je5s2.png" alt="image.png"></p><p>解析过程是<strong>迭代的</strong>，语法分析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后语法分析器分析下一个符号。如果没有匹配到规则，语法分析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</p><blockquote><p>词法分析器和语法分析器的工作是同步的，正如组装家具时，找到一个一个零件，根据说明书进行组装，如果没有找齐零件，是无法组装某一个个体的。</p></blockquote><h4 id="1-1-2-转换"><a href="#1-1-2-转换" class="headerlink" title="1.1.2 转换"></a>1.1.2 转换</h4><p>转换对工作人员来说是一个隐式的过程，正如在浏览器开发者控制台运行一些代码、打印日志信息一样，开发者可能感受不到转换到机器码的过程。但是编写的源代码并不是最终的目标，底层机器码才是机器识别、运行的格式。</p><p>很多时候，解析树并不是最终结果。解析一般在转换中使用——将输入文档转换为另一种格式。编译就是个例子，编译器在将一段源码编译为机器码的时候，先将源码解析为解析树，然后将该树转换为一个机器码文档。</p><p>简单来说<strong>转换</strong>过程在编译运行时就存在，将源代码转换为机器码，转换时是无感的。</p><p><img src="/assets/image-20220902140802-boi3thw.png" alt="image.png"></p><p>详细的例子可以看看：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>，如不熟悉抽象语法树的概念，可以看看：<a href="https://juejin.cn/post/6844904035271573511">手把手带你入门 AST 抽象语法树 - 掘金 (juejin.cn)</a>。</p><h4 id="1-1-3-深入"><a href="#1-1-3-深入" class="headerlink" title="1.1.3 深入"></a>1.1.3 深入</h4><p><strong>HTML解析器（HTML Parser）：</strong>HTML解析器的工作是将html标识解析为解析树。</p><p><strong>HTML文法定义（The HTML grammar definition）：</strong>W3C组织制定规范定义了HTML的词汇表和语法。</p><p><strong>非上下文无关文法（Not a context free grammar）：</strong>正如在解析简介中提到的，上下文无关文法的语法可以用类似BNF的格式来定义。</p><blockquote><p>HTML 有一个正式的格式定义—— DTD（Document Type Definition文档类型定义），但它并不是上下文无关文法，HTML 更接近于 XML，现在有很多可用的xml 解析器，html 有个 xml 的变体——xhtml，不同在于 html 更宽容，它允许忽略一些特定标签，有时可以省略开始或结束标签。总的来说，它是一种 soft 语法，不像 xml 呆板、固执。</p><p>显然，这个看起来很小的差异却带来了很大的不同。一方面，这是 html 流行的原因——它的宽容使 web 开发人员的工作更加轻松，但另一方面，这也使很难去写一个格式化的文法。所以，html 的解析并不简单，它既不能用传统的解析器解析，也不能用 xml 解析器解析。</p></blockquote><p><strong>HTML DTD</strong></p><p>html 适用 DTD 格式进行定义，这一格式是用于定义 SGML 家族的语言，包括了对所有允许元素及它们的属性和层次关系的定义。正如前面提到的，html DTD 并没有生成一种上下文无关文法。DTD 有一些变种，标准模式只遵守规范，而其他模式则包含了对浏览器过去所使用标签的支持，这么做是为了兼容以前内容。最新的标准 DTD 在<a href="http://www.w3.org/TR/html4/strict.dtd">http://www.w3.org/TR/html4/strict.dtd</a>。</p><p><strong>DOM</strong></p><p>解析输出的树也就是解析树，是由 DOM 元素及属性节点组成的。DOM 是文档对象模型的缩写，它是 html 文档的对象表示，作为 html 元素的外部接口供 JS 等调用。DOM 和标签基本是一一对应的关系。</p><p><strong>解析器类型（Types of parsers）</strong></p><p>有两种基本的解析器——自顶向下解析及自底向上解析。比较直观的解释是，自顶向下解析，查看语法的最高层结构并试着匹配其中一个；自底向上解析则从输入开始，逐步将其转换为语法规则，从底层规则开始直到匹配高层规则。</p><p>来看一下这两种解析器如何解析 “2+3-1” 的例子：<strong>自顶向下</strong>解析器从最高层规则开始——它先识别出“2+3”，将其视为一个表达式，然后识别出 “2+3-1” 为一个表达式（识别表达式的过程中匹配了其他规则，但出发点是最高层规则）。<strong>自底向上</strong>解析会扫描输入直到匹配了一条规则，然后用该规则取代匹配的输入，直到解析完所有输入。部分匹配的表达式被放置在解析堆栈中。</p><p>自顶向下与递归过程类似，从整体开始逐步检查子问题，而自底向上与递推过程类似，从子问题开始推向整体。</p><p><strong>自动化解析（Generating parsers automatically）</strong></p><p>解析器生成器这个工具可以自动生成解析器，只需要指定语言的文法——词汇表及语法规则，它就可以生成一个解析器。创建一个解析器需要对解析有深入的理解，而且手动的创建一个由较好性能的解析器并不容易，所以解析生成器很有用。Webkit使用两个知名的解析生成器——<strong>用于创建语法分析器的Flex</strong>及<strong>创建解析器的Bison</strong>（你可能接触过Lex和Yacc）。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p><p>稍微总结：HTML 解析器按照 HTML DTD 文法定义进行 HTML 解析，可以认为解析生成的 DOM 树与解析树一一映射，DOM 树就是解析树。</p><h4 id="1-1-4-解析算法"><a href="#1-1-4-解析算法" class="headerlink" title="1.1.4 解析算法"></a>1.1.4 解析算法</h4><p>HTML 不能被一般的自顶向下或自底向上的解析器所解析，不能使用正则解析技术，浏览器为 HTML 定制了专属的解析器，原因是：</p><ol><li>这门语言本身的宽容特性</li><li>浏览器对一些常见的非法html有容错机制</li><li>解析过程是往复的，通常源码不会在解析过程中发生改变，但在 HTML 中，脚本标签包含的 “document.write” 可能添加标签，这说明在解析过程中实际上修改了输入，所以不能使用正则解析技术</li></ol><p>HTML5 规范中描述了这个解析算法，算法包括两个阶段——符号化及构建树。</p><p>符号化是<strong>词法分析</strong>的过程，将输入解析为符号，HTML 的符号包括开始标签、结束标签、属性名及属性值。符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，以识别下一个符号，直到处理完所有输入。</p><p><strong>符号识别算法（The tokenization algorithm）</strong></p><p>算法输出 HTML 符号，该算法用状态机表示。每次读取输入流中的一个或多个字符，并根据这些字符转移到下一个状态，当前的符号状态及构建树状态共同影响结果，这意味着，读取同样的字符，可能因为当前状态的不同，得到不同的结果以进入下一个正确的状态。</p><p>这个算法很复杂，这里用一个简单的例子来解释这个原理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello world</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>初始状态为“Data State”，当遇到“&lt;”字符，状态变为“Tag open state”，读取一个a－z的字符将产生一个开始标签符号，状态相应变为“Tag name state”，一直保持这个状态直到读取到“&gt;”，每个字符都附加到这个符号名上，例子中创建的是一个html符号。</p><p>当读取到“&gt;”，当前的符号就完成了，此时状态回到“Data state”，“\body&gt;”重复这一处理过程。到这里，html和body标签都识别出来了。现在，回到“Data state”，读取“Hello world”中的字符“H”将创建并识别出一个字符符号，这里会<strong>为“Hello world”中的每个字符生成一个字符符号</strong>。</p><p>这样直到遇到“&lt;&#x2F;body&gt;”中的“&lt;”。现在，又回到了“Tag open state”，读取下一个字符“/”将创建一个闭合标签符号，并且状态转移到“Tag name state”，还是保持这一状态，直到遇到“&gt;”。然后，产生一个新的标签符号并回到“Data state”。后面的“&lt;&#x2F;html&gt;”将和“&lt;&#x2F;body&gt;”一样处理。</p><p><img src="/assets/image-20220903152441-lnzo21q.png" alt="image.png"></p><p><strong>简单总结：</strong>因为 HTML 符号包括开始标签、结束标签、属性名及属性值，所以解析每一个符号都需要三个状态来决定。状态机+符号化+树构建器。<strong>符号并不仅仅只是一个字符</strong>，可以是标签符号包括标签名、属性等，除标签符号外，为每一个内容字符创建一个字符符号（Data State）。</p><p><strong>树的构建算法（Tree construction algorithm）</strong></p><p>在树的构建阶段，将<strong>修改</strong>以Document为根的DOM树，将元素附加到树上。每个由符号识别器识别生成的节点将会被树构造器进行处理，规范中定义了每个符号相对应的Dom元素，<strong>对应的Dom元素将会被创建</strong>。这些元素除了会被添加到Dom树上，还将被添加到开放元素堆栈中。这个堆栈用来纠正嵌套的未匹配和未闭合标签，这个算法也是用状态机来描述，所有的状态采用插入模式。</p><p>首先是“initial mode”，接收到html符号后将转换为“before html”模式，在这个模式中对这个符号进行再处理。此时，创建了一个HTMLHtmlElement元素，并将其附加到根Document对象上。</p><p>状态此时变为“before head”，接收到body符号时，即使这里没有head符号，也将自动创建一个HTMLHeadElement元素并附加到树上。</p><p>现在，转到“in head”模式，然后是“after head”。到这里，body符号会被再次处理，将创建一个HTMLBodyElement并插入到树中，同时，转移到“in body”模式。</p><p>然后，接收到字符串“Hello world”的字符符号，第一个字符将导致创建并插入一个text节点，其他字符将附加到该节点。</p><p>接收到body结束符号时，转移到“after body”模式，接着接收到html结束符号，这个符号意味着转移到了“after after body”模式，当接收到文件结束符时，整个解析过程结束。</p><p><img src="/assets/image-20220903152422-pm7uawo.png" alt="image.png"></p><p><strong>简单总结：</strong>树构建器根据符号创建对应的DOM元素，附加到以Document为根的DOM树上，并对一些常见的 HTML 错误进行处理。</p><h4 id="1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）"><a href="#1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）" class="headerlink" title="1.1.5 解析结束时的处理（Action when the parsing is finished）"></a>1.1.5 解析结束时的处理（Action when the parsing is finished）</h4><p>在这个阶段，浏览器将文档标记为可交互的，并开始解析处于延时模式中的脚本——这些脚本在文档解析后执行。文档状态将被设置为完成，同时触发一个 <strong>load</strong> 事件。</p><p>HTML5 规范中有符号化及构建树的完整算法：<a href="http://www.w3.org/TR/html5/syntax.html#html-parser">链接</a>。</p><h4 id="1-1-6-浏览器容错（Browsers-error-tolerance）"><a href="#1-1-6-浏览器容错（Browsers-error-tolerance）" class="headerlink" title="1.1.6 浏览器容错（Browsers error tolerance）"></a>1.1.6 浏览器容错（Browsers error tolerance）</h4><p>详细可查看原文：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><h3 id="1-2-CSS-Parser"><a href="#1-2-CSS-Parser" class="headerlink" title="1.2 CSS Parser"></a>1.2 CSS Parser</h3><p>CSS 的加载并不会阻塞 DOM 的解析，但是会阻塞 DOM 的渲染。因为加载 CSS 时，可能会修改当前解析位置以后的 DOM 节点的样式，如果 CSS 加载不阻塞 DOM 树渲染，那么当 CSS 加载完之后，DOM 树可能又得重新重排 layout（回流reflow）或者重绘了，这就造成了一些没有必要的损耗。</p><p>不同于HTML，CSS属于上下文无关文法，可以用前面所描述的解析器来解析。CSS规范定义了CSS的词法及语法文法。可以参考词汇表和语法规则：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>。</p><p>每个符号都由正则表达式定义了词法文法（词汇表）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comment<span class="comment">///*[^*]*/*+([^/*][^*]*/*+)*//</span></span><br><span class="line">num[<span class="number">0</span>-<span class="number">9</span>]+|[<span class="number">0</span>-<span class="number">9</span>]*<span class="string">&quot;.&quot;</span>[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">nonascii[<span class="regexp">/200-/</span><span class="number">377</span>]</span><br><span class="line">nmstart[_a-z]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">nmchar[_a-z0-<span class="number">9</span>-]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">name&#123;nmchar&#125;+</span><br><span class="line">ident&#123;nmstart&#125;&#123;nmchar&#125;*</span><br></pre></td></tr></table></figure><p>“ident”是识别器的缩写，相当于一个class名，“name”是一个元素id（用“＃”引用）。</p><p>语法用BNF进行描述：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">: selector [ <span class="string">&#x27;,&#x27;</span> S* selector ]*</span><br><span class="line"><span class="string">&#x27;&#123;&#x27;</span> S* declaration [ <span class="string">&#x27;;&#x27;</span> S* declaration ]* <span class="string">&#x27;&#125;&#x27;</span> S*</span><br><span class="line">;</span><br><span class="line">selector</span><br><span class="line">: simple_selector [ combinator selector | S+ [ combinator selector ] ]</span><br><span class="line">;</span><br><span class="line"><span class="keyword">class</span></span><br><span class="line">: <span class="string">&#x27;.&#x27;</span> <span class="variable constant_">IDENT</span></span><br><span class="line">;</span><br><span class="line">element_name</span><br><span class="line">: <span class="variable constant_">IDENT</span> | <span class="string">&#x27;*&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>一个规则集合具有一个或是可选个数的多个选择器，这些选择器以逗号和空格（S表示空格）进行分隔。每个规则集合包含大括号及大括号中的一条或多条以分号隔开的声明。声明和选择器在后面进行定义。</p><h4 id="1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）"><a href="#1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）" class="headerlink" title="1.2.1 Webkit CSS解析器（Webkit CSS parser）"></a>1.2.1 Webkit CSS解析器（Webkit CSS parser）</h4><p>Webkit使用Flex和Bison解析生成器从CSS语法文件中自动生成解析器。回忆一下解析器的介绍，Bison创建一个自底向上的解析器，Firefox使用自顶向下解析器。它们都是将每个css文件解析为样式表对象，每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。</p><blockquote><p>用于创建语法分析器的Flex及创建解析器的Bison。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p></blockquote><p><img src="/assets/image-20220903160338-wjh6j4x.png" alt="image.png"></p><p>注意：WebKit使用的是自底向上的解析器</p><blockquote><p>处理脚本及样式表的顺序（The order of processing scripts and style sheets）</p><p>脚本：web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。HTML5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。</p><p>async是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行；而Defer是在JS加载完成后，整个文档解析完成后执行。 Defer更像是将&lt;script&gt;标签放在&lt;&#x2F;body&gt;之后的效果，但是它由于是异步加载JS文件，所以可以节省时间。简单来说就是async和defer都是开启新线程（http线程）请求JS文件，和解析DOM并行不冲突，async在请求完成后就开始执行JS文件，而defer则是在整个DOM解析完成后再执行JS文件。</p><p>预解析（Speculative parsing）</p><p>Webkit和Firefox都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变Dom树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p></blockquote><p>StyleSheets样式表采用另一种模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。</p><p><strong>简单总结：</strong>WebKit用Flex生成CSS语法规则，Bison生成CSS解析器。样式表不阻塞DOM解析，但是阻塞DOM渲染，FireFox在样式文件未加载完成前阻塞JS脚本，目的是防止样式文件未加载完成而JS脚本需要获取样式文件信息的错误，Chrome只阻塞那些访问未加载完成的样式文件的JS脚本，样式加载完成即不堵塞。</p><h3 id="1-3-Render-Tree"><a href="#1-3-Render-Tree" class="headerlink" title="1.3 Render Tree"></a>1.3 Render Tree</h3><h4 id="1-3-1-渲染树的定义"><a href="#1-3-1-渲染树的定义" class="headerlink" title="1.3.1 渲染树的定义"></a>1.3.1 渲染树的定义</h4><p>当Dom树构建完成时，浏览器开始构建另一棵树——渲染树。渲染树由元素显示序列中的可见元素组成，它是文档的可视化表示，构建这棵树是为了以正确的顺序绘制文档内容。</p><p>Firefox将渲染树中的元素称为frames，WebKit则用renderer或渲染对象来描述这些元素.一个渲染对象知道怎么布局及绘制自己及它的 children？</p><p>RenderObject是Webkit的渲染对象基类，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RenderObject</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">layout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(PaintInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> rect <span class="title">repaintRect</span><span class="params">()</span></span>;</span><br><span class="line">    Node* node;<span class="comment">//the DOM node</span></span><br><span class="line">    RenderStyle* style;<span class="comment">// the computed style</span></span><br><span class="line">    RenderLayer* containgLayer; <span class="comment">//the containing z-index layer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个渲染节点对象用一个和该节点 CSS 盒模型相对应的矩形区域来表示，正如 CSS2 所描述的那样，它包含诸如宽、高和位置之类的几何信息。盒模型的类型受该节点相关的 display 样式属性的影响（参考样式计算章节）。下面的 WebKit 代码说明了如何根据 display 属性决定某个节点创建何种类型的渲染对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RenderObject* <span class="title">RenderObject::createObject</span><span class="params">(Node* node, RenderStyle* style)</span> </span>&#123;</span><br><span class="line">    Document* doc = node-&gt;<span class="built_in">document</span>();</span><br><span class="line">    RenderArena* arena = doc-&gt;<span class="built_in">renderArena</span>();</span><br><span class="line">    ...</span><br><span class="line">    RenderObject* o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (style-&gt;<span class="built_in">display</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> NONE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderInline</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE_BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LIST_ITEM:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderListItem</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的类型也需要考虑，例如，表单控件和表格带有特殊的框架。</p><p>在Webkit中，如果一个元素想创建一个特殊的渲染对象，它需要重写“createRenderer”方法，使渲染对象指向不包含几何信息的样式对象。</p><p><strong>简单总结：</strong>渲染树是可视节点的集合，即在页面真实渲染的元素集合，底层使用c++进行渲染，通过c++定义不同的对象实现不同类型节点的渲染</p><h4 id="1-3-2-渲染树和DOM树的关系"><a href="#1-3-2-渲染树和DOM树的关系" class="headerlink" title="1.3.2 渲染树和DOM树的关系"></a>1.3.2 渲染树和DOM树的关系</h4><p>渲染对象和Dom元素相对应，但这种对应关系不是一对一的，不可见的Dom元素不会被插入渲染树，如head元素，display属性为none的元素（渲染树中存在 visibility 属性为 hidden 或着 opacity 属性为0的元素）。</p><p>还有一些Dom元素对应几个可见对象，它们一般是具有<strong>复杂结构</strong>的元素，无法用一个矩形来描述。例如，select元素有三个渲染对象——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而<strong>换行</strong>时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的 HTML结构，根据 CSS 规范，<strong>一个行内元素只能仅包含行内元素或仅包含块状元素，存在混合内容时，将会创建匿名的块状渲染对象包裹行内元素</strong>。</p><p><img src="/assets/image-20220905163521-nfbbt1n.png" alt="image.png"></p><h4 id="1-3-3-创建树的流程（The-flow-of-constructing-the-tree）"><a href="#1-3-3-创建树的流程（The-flow-of-constructing-the-tree）" class="headerlink" title="1.3.3 创建树的流程（The flow of constructing the tree）"></a>1.3.3 创建树的流程（The flow of constructing the tree）</h4><p>Firefox中，表述为一个监听Dom更新的监听器，将frame的创建委派给Frame Constructor，这个构建器计算样式（参看样式计算）并创建一个frame。</p><p>Webkit中，计算样式并生成渲染对象的过程称为 attachment，每个Dom节点有一个attach方法，attachment的过程是<strong>同步</strong>的，调用新节点的 attach 方法将节点插入到Dom树中。处理 html 和 body 标签将构建渲染树的根，这个<strong>根渲染对象</strong>对应被 css 规范称为 containing block 的元素——<strong>包含</strong>了其他所有块元素的顶级块元素。它的大小就是 <strong>viewport</strong>——浏览器窗口的显示区域，Firefox称它为 viewPortFrame，webkit称为 RenderView，这个就是文档 document 所指向的渲染对象，树中其他的部分都将作为一个插入的Dom节点被创建。</p><p><strong>简单总结：</strong>不同的内核对于合并的过程有不同的称呼，WebKit中使用attachment，构建渲染树会扫描DOM树和CSSOM树，扫描DOM树发现HTML、BODY元素时，就会创建一个根渲染对象，称为<strong>containing block</strong>，大小就是viewport。</p><h4 id="1-3-4-样式计算（Style-Computation）"><a href="#1-3-4-样式计算（Style-Computation）" class="headerlink" title="1.3.4 样式计算（Style Computation）"></a>1.3.4 样式计算（Style Computation）</h4><p>创建渲染树需要计算出每个渲染对象的可视属性，这可以通过计算每个元素的样式属性得到。</p><p>样式包括各种来源的<strong>样式表</strong>，<strong>行内样式元素</strong>及html中的<strong>可视化属性</strong>（例如bgcolor），可视化属性转化为css样式属性。</p><p>样式表的来源包括浏览器默认样式表、页面作者以及用户提供的样式表（有些样式是浏览器用户提供的（浏览器允许用户定义喜欢的样式，例如，在Firefox中可以通过在Firefox Profile目录下放置样式表实现））。</p><p>计算样式的一些困难：</p><ol><li>样式数据是非常大的结构，保存大量的样式属性会带来内存问题。</li><li>如果不进行优化，找到每个元素匹配的规则会导致性能问题，为每个元素查找匹配的规则都需要遍历整个规则表，这个过程有很大的工作量。选择符可能有复杂的结构，匹配过程如果沿着一条开始看似正确，后来却被证明是无用的路径，则必须去尝试另一条路径。例如，复杂选择符 <code>div div div div｛…｝</code> 这意味着规则应用到三个div的后代div元素，选择树某一条特定的路径去检查，这可能需要遍历节点树，最后却发现它只是两个div的后代，并不使用该规则，然后则需要沿着另一条路径去尝试</li><li>应用规则涉及非常复杂的级联，它们定义了规则的层次</li></ol><p><strong>浏览器如何处理这些问题？</strong></p><p>共享样式数据（Sharing style data）</p><p>WebKit节点引用样式对象（渲染样式），某些情况下，这些对象可以被节点间共享，这些节点需要是兄弟或是表兄弟节点，并且：</p><ol><li>这些元素必须处于相同的鼠标状态（比如不能一个处于hover，而另一个不是）</li><li>不能有元素具有id</li><li>标签名必须匹配</li><li>class属性必须匹配</li><li>对应的属性必须相同</li><li>链接状态必须匹配</li><li>焦点状态必须匹配</li><li>不能有元素被属性选择器影响</li><li>元素不能有行内样式属性</li><li>不能有生效的兄弟选择器，webcore在任何兄弟选择器相遇时只是简单的抛出一个全局转换，并且在它们显示时使整个文档的样式共享失效，这些包括＋选择器和类似:first-child和:last-child这样的选择器。</li></ol><p>Firefox规则树（Firefox rule tree）</p><p>Firefox用两个树用来简化样式计算－规则树和样式上下文树，WebKit也有样式对象，但它们并没有存储在类似样式上下文树这样的树中，只是由Dom节点指向其相关的样式。</p><p><img src="/assets/image-20220905204116-occzqvw.png" alt="image.png" title="Firefox样式上下文树"></p><p>具体细节可以阅读原文：<a href="https://kb.cnblogs.com/page/129756/#chapter4">浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>Webkit中，并没有规则树，匹配的声明会被遍历四次，先是应用非important的高优先级属性（之所以先应用这些属性，是因为其他的依赖于它们－比如display），其次是高优先级important的，接着是一般优先级非important的，最后是一般优先级important的规则。这样，出现多次的属性将被按照正确的级联顺序进行处理，最后一个生效。</p><h3 id="1-4-Layout"><a href="#1-4-Layout" class="headerlink" title="1.4 Layout"></a>1.4 Layout</h3><p>当渲染对象被创建并添加到树中，它们仅具有对应的布局规则，并没有实际的位置和大小，计算这些值的过程称为 layout 或 reflow。</p><p>Html使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中<strong>从右向左</strong>、<strong>自上而下</strong>的进行。也存在一些例外，比如 html tables。</p><p>坐标系统相对于根frame，使用 top 和 left 坐标。布局是一个<strong>递归</strong>的过程，由根渲染对象开始，它对应 html 文档document元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。根渲染对象的位置是 0,0，它的大小是viewport－浏览器窗口的可见部分。所有的渲染对象都有一个 layout 或 reflow 方法，每个渲染对象调用<strong>需要布局</strong>的 children 的 layout 方法。</p><p><strong>简单总结：</strong>通过父元素掉调用需要布局的 children 的 layout 方法，如何明确元素需要布局，则需要使用到 Dirty bit 系统</p><h4 id="1-4-1-Dirty-bit系统"><a href="#1-4-1-Dirty-bit系统" class="headerlink" title="1.4.1 Dirty bit系统"></a>1.4.1 Dirty bit系统</h4><p>为了不因为每个小变化都<strong>全部重新布局</strong>，浏览器使用一个 dirty bit 系统，一个渲染对象发生了<strong>变化</strong>或是被<strong>添加</strong>了，就标记<strong>它及它的children</strong>为dirty——需要layout。</p><p>dirty bit 设置元素存在两个标识——dirty及children are dirty，children are dirty标识说明即使这个渲染对象本身的属性没变化，它也至少有一个child需要layout。</p><h4 id="1-4-2-全局和增量layout"><a href="#1-4-2-全局和增量layout" class="headerlink" title="1.4.2 全局和增量layout"></a>1.4.2 全局和增量layout</h4><p>当layout在整棵渲染树触发时，称为全局layout，这可能在下面这些情况下发生：</p><ol><li>一个全局的样式改变影响所有的渲染对象，比如字号的改变。</li><li>窗口resize。</li></ol><p>layout也可以是增量的，这样只有标志为dirty的渲染对象会重新布局（也将导致一些额外的布局）。增量layout会在渲染对象dirty时<strong>异步触发</strong>，例如，当网络接收到新的内容并添加到DOM树后，新的渲染对象会添加到渲染树中，即在初次渲染时，是一个增量layout的过程。</p><p><img src="/assets/image-20220905210504-r5cgwfg.png" alt="image.png" title="增量layout过程"></p><p><strong>异步和同步layout</strong></p><p><strong>增量layout的过程是异步的</strong>，Firefox为增量 layout 生成了 reflow 队列，以及一个调度执行这些批处理命令。WebKit也有一个计时器用来执行增量layout－遍历树，为dirty状态的渲染对象重新布局。另外，当脚本请求样式信息时，例如“offsetHeight”，会同步的触发增量布局。</p><p>全局的layout一般都是同步触发。有些时候，layout会被作为一个初始layout之后的回调，比如滑动条的滑动。</p><p><strong>优化</strong></p><p>当一个layout因为resize或是渲染位置改变（并不是大小改变）而触发时，渲染对象的大小将会从缓存中读取，而不会重新计算。</p><p>一般情况下，如果只有子树发生改变，则layout并不从根开始。这种情况发生在，变化发生在元素自身并且不影响它周围元素，例如，将文本插入文本域（否则，每次击键都将触发从根开始的重排）。</p><h4 id="1-4-3-layout过程"><a href="#1-4-3-layout过程" class="headerlink" title="1.4.3 layout过程"></a>1.4.3 layout过程</h4><p>layout一般有下面这几个部分：</p><ol><li><p>parent渲染对象决定它的宽度</p></li><li><p>parent渲染对象读取chilidren，并：</p><ul><li>放置child渲染对象（设置它的x和y）</li><li>在需要时（它们当前为dirty或是处于全局layout或者其他原因）调用child渲染对象的layout，这将计算child的高度</li><li>parent渲染对象使用child渲染对象的累积高度，以及margin和padding的高度来设置自己的高度－这将被parent渲染对象的parent使用</li><li>将dirty标识设置为false</li></ul></li></ol><p>Firefox使用一个“state”对象（nsHTMLReflowState）做为参数去布局（firefox称为reflow），state包含parent的宽度及其他内容。</p><p>Firefox布局的输出是一个“metrics”对象（nsHTMLReflowMetrics）。它包括渲染对象计算出的高度。</p><p><strong>宽度计算</strong></p><p>渲染对象的宽度使用容器的宽度、渲染对象样式中的宽度及margin、border进行计算。例如，下面这个div的宽度：</p><p>　　<kbd><div /></kbd></p><p>webkit中宽度的计算过程是（RenderBox类的 <strong>calcWidth</strong> 方法）：</p><ul><li>容器的宽度是容器的<strong>可用宽度和0</strong>中的最大值，这里的可用宽度为：contentWidth&#x3D;clientWidth()-paddingLeft()-paddingRight()，clientWidth和clientHeight代表一个对象内部的不包括border和滑动条的大小</li><li>元素的宽度指样式属性width的值，它可以通过计算容器的百分比得到一个绝对值</li><li>加上水平方向上的border和padding</li></ul><p>到这里是最佳宽度的计算过程，现在计算宽度的最大值和最小值，如果最佳宽度大于最大宽度则使用最大宽度，如果小于最小宽度则使用最小宽度。最后缓存这个值，当需要layout但宽度未改变时使用。</p><p><strong>Line breaking</strong></p><p>当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的parent它需要折行，parent将创建额外的渲染对象并调用它们的layout。</p><h3 id="1-5-绘制（Painting）"><a href="#1-5-绘制（Painting）" class="headerlink" title="1.5 绘制（Painting）"></a>1.5 绘制（Painting）</h3><p>　　绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件，这在UI的章节有更多的介绍。</p><h4 id="1-5-1-全局和增量"><a href="#1-5-1-全局和增量" class="headerlink" title="1.5.1 全局和增量"></a>1.5.1 全局和增量</h4><p>和布局一样，绘制也可以是<strong>全局的</strong>——绘制完整的树，或<strong>增量的</strong>。在增量的绘制过程中，一些渲染对象以不影响整棵树的方式改变，改变的渲染对象使其在屏幕上的矩形区域失效，这将导致操作系统将其看作dirty区域，并产生一个paint事件，操作系统很巧妙的处理这个过程，并将<strong>多个区域合并为一个</strong>，提高性能。Chrome中，这个过程更复杂些，因为渲染对象在不同的进程中，而不是在主进程中。Chrome在一定程度上模拟操作系统的行为，表现为监听事件并派发消息给渲染根，在树中查找到相关的渲染对象，重绘这个对象（往往还包括它的children）。</p><h4 id="1-5-2-绘制顺序"><a href="#1-5-2-绘制顺序" class="headerlink" title="1.5.2 绘制顺序"></a>1.5.2 绘制顺序</h4><p>css2定义了绘制过程的顺序——<a href="http://www.w3.org/TR/CSS21/zindex.html">http://www.w3.org/TR/CSS21/zindex.html</a>。这个就是元素压入堆栈的顺序，这个顺序影响着绘制，<strong>堆栈从后向前进行绘制</strong>。</p><p>一个块渲染对象的堆栈顺序是：</p><ol><li>背景色</li><li>背景图</li><li>border</li><li>children</li><li>outline</li></ol><h4 id="1-5-3-Firefox显示列表"><a href="#1-5-3-Firefox显示列表" class="headerlink" title="1.5.3 Firefox显示列表"></a>1.5.3 Firefox显示列表</h4><p>Firefox读取渲染树并为绘制的矩形创建一个<strong>显示列表</strong>，该列表以<strong>正确的绘制顺序</strong>包含这个矩形<strong>相关的渲染对象</strong>（背景、图片、样式属性等以正确的顺序排序）。用这样的方法，可以使重绘时只需查找一次树，而不需要多次查找——绘制所有的背景、所有的图片、所有的border等等。</p><p>Firefox优化了这个过程，它不添加会被隐藏的元素，比如元素完全在其他不透明元素下面。</p><h4 id="1-5-4-WebKit矩形存储"><a href="#1-5-4-WebKit矩形存储" class="headerlink" title="1.5.4 WebKit矩形存储"></a>1.5.4 WebKit矩形存储</h4><p>重绘前，WebKit将旧的矩形保存为位图，然后<strong>只绘制新旧矩形的差集</strong>。</p><h4 id="1-5-5-动态变化"><a href="#1-5-5-动态变化" class="headerlink" title="1.5.5 动态变化"></a>1.5.5 动态变化</h4><p>浏览器总是试着以<strong>最小的动作响应一个变化</strong>，所以一个元素颜色的变化将只导致该元素的重绘，元素位置的变化将大致元素的布局和重绘，添加一个Dom节点，也会导致这个元素的布局和重绘。一些主要的变化，比如增加html元素的字号，将会导致<strong>缓存失效</strong>，从而引起整体的布局和重绘。</p><h3 id="1-6-渲染引擎的线程"><a href="#1-6-渲染引擎的线程" class="headerlink" title="1.6 渲染引擎的线程"></a>1.6 渲染引擎的线程</h3><p>渲染引擎是<strong>单线程</strong>的，除了网络操作以外，几乎所有的事情都在单一的线程中处理，在Firefox和Safari中，这是浏览器的<strong>主线程</strong>，Chrome中这是tab的主线程（Chrome一个Tab一个进程，一个进程中含有一个主线程，负责大部分的代码执行）。</p><p>网络操作由几个并行线程执行，并行连接的个数是受限的（通常是2－6个）。</p><h3 id="1-7-事件循环"><a href="#1-7-事件循环" class="headerlink" title="1.7 事件循环"></a>1.7 事件循环</h3><p>浏览器主线程是一个事件循环，它被设计为无限循环以保持执行过程的可用，等待事件（例如layout和paint事件）并执行它们，注意并不是无限制的轮询，而是一个带有阻塞的轮询。下面是Firefox的主要事件循环代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mExiting)</span><br><span class="line">    <span class="built_in">NS_ProcessNextEvent</span>(thread);</span><br></pre></td></tr></table></figure><h3 id="1-8-CSS2可视模型（CSS2-visual-module）"><a href="#1-8-CSS2可视模型（CSS2-visual-module）" class="headerlink" title="1.8 CSS2可视模型（CSS2 visual module）"></a>1.8 CSS2可视模型（CSS2 visual module）</h3><h4 id="1-8-1-画布The-Canvas"><a href="#1-8-1-画布The-Canvas" class="headerlink" title="1.8.1 画布The Canvas"></a>1.8.1 画布The Canvas</h4><p>根据CSS2规范，术语canvas用来描述<strong>格式化的结构所渲染的空间</strong>——浏览器绘制内容的地方。画布对每个维度空间都是无限大的，但浏览器基于viewport的大小选择了一个初始宽度。根据<a href="http://www.w3.org/TR/CSS2/zindex.html">http://www.w3.org/TR/CSS2/zindex.html</a>的定义，画布如果是包含在其他画布内则是透明的，否则浏览器会指定一个颜色。</p><h4 id="1-8-2-CSS盒模型"><a href="#1-8-2-CSS盒模型" class="headerlink" title="1.8.2 CSS盒模型"></a>1.8.2 CSS盒模型</h4><p>CSS盒模型描述了矩形盒，这些矩形盒是为文档树中的元素生成的，并根据可视的格式化模型进行布局。每个box包括内容区域（如图片、文本等）及可选的四周padding、border和margin区域。</p><p><img src="/assets/image-20220905213040-ukvs7qo.png" alt="image.png" title="CSS盒子模型"></p><p>每个节点生成0－n个这样的box。所有的元素都有一个display属性，用来决定它们生成box的类型，例如：</p><ul><li>block －生成块状box</li><li>inline －生成一个或多个行内box</li><li>none －不生成box</li></ul><p>默认的是inline，但浏览器样式表设置了其他默认值，例如，div元素默认为block。可以访问<a href="http://www.w3.org/TR/CSS2/sample.html">http://www.w3.org/TR/CSS2/sample.html</a>查看更多的默认样式表示例。</p><h4 id="1-8-3-定位策略Position-scheme"><a href="#1-8-3-定位策略Position-scheme" class="headerlink" title="1.8.3 定位策略Position scheme"></a>1.8.3 定位策略Position scheme</h4><p>这里有三种策略：</p><ol><li>normal －对象根据它在文档的中位置定位，这意味着它在渲染树和在Dom树中位置一致，并根据它的盒模型和大小进行布局。</li><li>float －对象先像普通流一样布局，然后尽可能的向左或是向右移动。</li><li>absolute －对象在渲染树中的位置和Dom树中<strong>位置无关</strong>。</li></ol><p><strong>static 和 relative 是normal， float属于float，absolute和fixed属于absolute。</strong></p><p>在static定位中，不定义位置而使用默认的位置。其他策略中，作者指定位置——top、bottom、left、right。</p><h4 id="1-8-4-Box布局"><a href="#1-8-4-Box布局" class="headerlink" title="1.8.4 Box布局"></a>1.8.4 Box布局</h4><p>Box布局的方式由这几项决定：box的类型、box的大小、定位策略及扩展信息（比如图片大小和屏幕尺寸）。</p><p><strong>Box类型</strong></p><ul><li>Block box：构成一个块，即在浏览器窗口上有自己的矩形</li><li>Inline box：并没有自己的块状区域，但包含在一个块状区域内</li></ul><p>区分</p><ul><li>block一个挨着一个垂直格式化，inline则在水平方向上格式化。</li></ul><p><img src="/assets/image-20220905214925-cfzraou.png" alt="image.png"></p><ul><li>Inline盒模型放置在行内或是line box中，每行至少和最高的box一样高，当box以baseline对齐时——即一个元素的底部和另一个box上除底部以外的某点对齐，行高可以比最高的box高。当容器宽度不够时，行内元素将被放到多行中，这在一个p元素中经常发生。</li></ul><p><img src="/assets/image-20220905215128-dc6mo20.png" alt="image.png"></p><h4 id="1-8-5-定位Position"><a href="#1-8-5-定位Position" class="headerlink" title="1.8.5 定位Position"></a>1.8.5 定位Position</h4><p><strong>Relative</strong></p><p>相对定位——先按照一般的定位，然后按所要求的差值移动。</p><p><img src="/assets/image-20220905215245-d8kp87q.png" alt="image.png"></p><p><strong>Floats</strong></p><p>一个浮动的box移动到一行的最左边或是最右边，其余的box围绕在它周围。下面这段html：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;img src=<span class="string">&quot;images/image.gif&quot;</span> width=<span class="string">&quot;100&quot;</span> height=<span class="string">&quot;100&quot;</span>&gt;Lorem ipsum dolor sit amet, consectetuer...</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215332-ibisnl2.png" alt="image.png"></p><p><strong>Absolute和Fixed</strong></p><p>这种情况下的布局完全<strong>不顾普通的文档流</strong>，<strong>元素不属于文档流的一部分</strong>，大小取决于容器。Fixed时，容器为viewport（可视区域）。</p><p><img src="/assets/image-20220905215416-ftp14sx.png" alt="image.png"></p><p><strong>Layered representation</strong></p><p>这个由CSS属性中的<strong>z-index</strong>指定，表示盒模型的第三个大小，即在<strong>z轴上的位置</strong>。Box分发到堆栈中（称为堆栈上下文），每个堆栈中<strong>靠后的元素将被较早绘制</strong>，栈顶靠前的元素离用户最近，当发生交叠时，将隐藏靠后的元素。<strong>堆栈根据z-index属性排序</strong>，拥有z-index属性的box形成了一个局部堆栈，viewport有外部堆栈</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">STYLE</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215620-7cst2bt.png" alt="image.png"></p><p>虽然绿色div排在红色div后面，可能在正常流中也已经被绘制在后面，但z-index有更高优先级，所以在根box的堆栈中更靠前。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> 浏览器内部工作原理-解析方向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三. 浏览器内部工作原理-解析方向（二）</title>
      <link href="/2022/09/06/%E4%B8%89-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/09/06/%E4%B8%89-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="三-浏览器内部工作原理-解析方向（二）"><a href="#三-浏览器内部工作原理-解析方向（二）" class="headerlink" title="三. 浏览器内部工作原理-解析方向（二）"></a>三. 浏览器内部工作原理-解析方向（二）</h1><h2 id="树的构建流程"><a href="#树的构建流程" class="headerlink" title="树的构建流程"></a>树的构建流程</h2><h3 id="1-3-Render-Tree"><a href="#1-3-Render-Tree" class="headerlink" title="1.3 Render Tree"></a>1.3 Render Tree</h3><h4 id="1-3-1-渲染树的定义"><a href="#1-3-1-渲染树的定义" class="headerlink" title="1.3.1 渲染树的定义"></a>1.3.1 渲染树的定义</h4><p>当Dom树构建完成时，浏览器开始构建另一棵树——渲染树。渲染树由元素显示序列中的可见元素组成，它是文档的可视化表示，构建这棵树是为了以正确的顺序绘制文档内容。</p><p>Firefox将渲染树中的元素称为frames，WebKit则用renderer或渲染对象来描述这些元素.一个渲染对象知道怎么布局及绘制自己及它的 children？</p><p>RenderObject是Webkit的渲染对象基类，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RenderObject</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">layout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(PaintInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> rect <span class="title">repaintRect</span><span class="params">()</span></span>;</span><br><span class="line">    Node* node;<span class="comment">//the DOM node</span></span><br><span class="line">    RenderStyle* style;<span class="comment">// the computed style</span></span><br><span class="line">    RenderLayer* containgLayer; <span class="comment">//the containing z-index layer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个渲染节点对象用一个和该节点 CSS 盒模型相对应的矩形区域来表示，正如 CSS2 所描述的那样，它包含诸如宽、高和位置之类的几何信息。盒模型的类型受该节点相关的 display 样式属性的影响（参考样式计算章节）。下面的 WebKit 代码说明了如何根据 display 属性决定某个节点创建何种类型的渲染对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RenderObject* <span class="title">RenderObject::createObject</span><span class="params">(Node* node, RenderStyle* style)</span> </span>&#123;</span><br><span class="line">    Document* doc = node-&gt;<span class="built_in">document</span>();</span><br><span class="line">    RenderArena* arena = doc-&gt;<span class="built_in">renderArena</span>();</span><br><span class="line">    ...</span><br><span class="line">    RenderObject* o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (style-&gt;<span class="built_in">display</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> NONE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderInline</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INLINE_BLOCK:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderBlock</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LIST_ITEM:</span><br><span class="line">        o = <span class="built_in">new</span> (arena) <span class="built_in">RenderListItem</span>(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的类型也需要考虑，例如，表单控件和表格带有特殊的框架。</p><p>在Webkit中，如果一个元素想创建一个特殊的渲染对象，它需要重写“createRenderer”方法，使渲染对象指向不包含几何信息的样式对象。</p><p><strong>简单总结：</strong>渲染树是可视节点的集合，即在页面真实渲染的元素集合，底层使用c++进行渲染，通过c++定义不同的对象实现不同类型节点的渲染</p><h4 id="1-3-2-渲染树和DOM树的关系"><a href="#1-3-2-渲染树和DOM树的关系" class="headerlink" title="1.3.2 渲染树和DOM树的关系"></a>1.3.2 渲染树和DOM树的关系</h4><p>渲染对象和Dom元素相对应，但这种对应关系不是一对一的，不可见的Dom元素不会被插入渲染树，如head元素，display属性为none的元素（渲染树中存在 visibility 属性为 hidden 或着 opacity 属性为0的元素）。</p><p>还有一些Dom元素对应几个可见对象，它们一般是具有<strong>复杂结构</strong>的元素，无法用一个矩形来描述。例如，select元素有三个渲染对象——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而<strong>换行</strong>时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的 HTML结构，根据 CSS 规范，<strong>一个行内元素只能仅包含行内元素或仅包含块状元素，存在混合内容时，将会创建匿名的块状渲染对象包裹行内元素</strong>。</p><p><img src="/assets/image-20220905163521-nfbbt1n.png" alt="image.png"></p><h4 id="1-3-3-创建树的流程（The-flow-of-constructing-the-tree）"><a href="#1-3-3-创建树的流程（The-flow-of-constructing-the-tree）" class="headerlink" title="1.3.3 创建树的流程（The flow of constructing the tree）"></a>1.3.3 创建树的流程（The flow of constructing the tree）</h4><p>Firefox中，表述为一个监听Dom更新的监听器，将frame的创建委派给Frame Constructor，这个构建器计算样式（参看样式计算）并创建一个frame。</p><p>Webkit中，计算样式并生成渲染对象的过程称为 attachment，每个Dom节点有一个attach方法，attachment的过程是<strong>同步</strong>的，调用新节点的 attach 方法将节点插入到Dom树中。处理 html 和 body 标签将构建渲染树的根，这个<strong>根渲染对象</strong>对应被 css 规范称为 containing block 的元素——<strong>包含</strong>了其他所有块元素的顶级块元素。它的大小就是 <strong>viewport</strong>——浏览器窗口的显示区域，Firefox称它为 viewPortFrame，webkit称为 RenderView，这个就是文档 document 所指向的渲染对象，树中其他的部分都将作为一个插入的Dom节点被创建。</p><p><strong>简单总结：</strong>不同的内核对于合并的过程有不同的称呼，WebKit中使用attachment，构建渲染树会扫描DOM树和CSSOM树，扫描DOM树发现HTML、BODY元素时，就会创建一个根渲染对象，称为<strong>containing block</strong>，大小就是viewport。</p><h4 id="1-3-4-样式计算（Style-Computation）"><a href="#1-3-4-样式计算（Style-Computation）" class="headerlink" title="1.3.4 样式计算（Style Computation）"></a>1.3.4 样式计算（Style Computation）</h4><p>创建渲染树需要计算出每个渲染对象的可视属性，这可以通过计算每个元素的样式属性得到。</p><p>样式包括各种来源的<strong>样式表</strong>，<strong>行内样式元素</strong>及html中的<strong>可视化属性</strong>（例如bgcolor），可视化属性转化为css样式属性。</p><p>样式表的来源包括浏览器默认样式表、页面作者以及用户提供的样式表（有些样式是浏览器用户提供的（浏览器允许用户定义喜欢的样式，例如，在Firefox中可以通过在Firefox Profile目录下放置样式表实现））。</p><p>计算样式的一些困难：</p><ol><li>样式数据是非常大的结构，保存大量的样式属性会带来内存问题。</li><li>如果不进行优化，找到每个元素匹配的规则会导致性能问题，为每个元素查找匹配的规则都需要遍历整个规则表，这个过程有很大的工作量。选择符可能有复杂的结构，匹配过程如果沿着一条开始看似正确，后来却被证明是无用的路径，则必须去尝试另一条路径。例如，复杂选择符 <code>div div div div｛…｝</code> 这意味着规则应用到三个div的后代div元素，选择树某一条特定的路径去检查，这可能需要遍历节点树，最后却发现它只是两个div的后代，并不使用该规则，然后则需要沿着另一条路径去尝试</li><li>应用规则涉及非常复杂的级联，它们定义了规则的层次</li></ol><p><strong>浏览器如何处理这些问题？</strong></p><p>共享样式数据（Sharing style data）</p><p>WebKit节点引用样式对象（渲染样式），某些情况下，这些对象可以被节点间共享，这些节点需要是兄弟或是表兄弟节点，并且：</p><ol><li>这些元素必须处于相同的鼠标状态（比如不能一个处于hover，而另一个不是）</li><li>不能有元素具有id</li><li>标签名必须匹配</li><li>class属性必须匹配</li><li>对应的属性必须相同</li><li>链接状态必须匹配</li><li>焦点状态必须匹配</li><li>不能有元素被属性选择器影响</li><li>元素不能有行内样式属性</li><li>不能有生效的兄弟选择器，webcore在任何兄弟选择器相遇时只是简单的抛出一个全局转换，并且在它们显示时使整个文档的样式共享失效，这些包括＋选择器和类似:first-child和:last-child这样的选择器。</li></ol><p>Firefox规则树（Firefox rule tree）</p><p>Firefox用两个树用来简化样式计算－规则树和样式上下文树，WebKit也有样式对象，但它们并没有存储在类似样式上下文树这样的树中，只是由Dom节点指向其相关的样式。</p><p><img src="/assets/image-20220905204116-occzqvw.png" alt="image.png" title="Firefox样式上下文树"></p><p>具体细节可以阅读原文：<a href="https://kb.cnblogs.com/page/129756/#chapter4">浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>Webkit中，并没有规则树，匹配的声明会被遍历四次，先是应用非important的高优先级属性（之所以先应用这些属性，是因为其他的依赖于它们－比如display），其次是高优先级important的，接着是一般优先级非important的，最后是一般优先级important的规则。这样，出现多次的属性将被按照正确的级联顺序进行处理，最后一个生效。</p><h3 id="1-4-Layout"><a href="#1-4-Layout" class="headerlink" title="1.4 Layout"></a>1.4 Layout</h3><p>当渲染对象被创建并添加到树中，它们仅具有对应的布局规则，并没有实际的位置和大小，计算这些值的过程称为 layout 或 reflow。</p><p>Html使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中<strong>从右向左</strong>、<strong>自上而下</strong>的进行。也存在一些例外，比如 html tables。</p><p>坐标系统相对于根frame，使用 top 和 left 坐标。布局是一个<strong>递归</strong>的过程，由根渲染对象开始，它对应 html 文档document元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。根渲染对象的位置是 0,0，它的大小是viewport－浏览器窗口的可见部分。所有的渲染对象都有一个 layout 或 reflow 方法，每个渲染对象调用<strong>需要布局</strong>的 children 的 layout 方法。</p><p><strong>简单总结：</strong>通过父元素掉调用需要布局的 children 的 layout 方法，如何明确元素需要布局，则需要使用到 Dirty bit 系统</p><h4 id="1-4-1-Dirty-bit系统"><a href="#1-4-1-Dirty-bit系统" class="headerlink" title="1.4.1 Dirty bit系统"></a>1.4.1 Dirty bit系统</h4><p>为了不因为每个小变化都<strong>全部重新布局</strong>，浏览器使用一个 dirty bit 系统，一个渲染对象发生了<strong>变化</strong>或是被<strong>添加</strong>了，就标记<strong>它及它的children</strong>为dirty——需要layout。</p><p>dirty bit 设置元素存在两个标识——dirty及children are dirty，children are dirty标识说明即使这个渲染对象本身的属性没变化，它也至少有一个child需要layout。</p><h4 id="1-4-2-全局和增量layout"><a href="#1-4-2-全局和增量layout" class="headerlink" title="1.4.2 全局和增量layout"></a>1.4.2 全局和增量layout</h4><p>当layout在整棵渲染树触发时，称为全局layout，这可能在下面这些情况下发生：</p><ol><li>一个全局的样式改变影响所有的渲染对象，比如字号的改变。</li><li>窗口resize。</li></ol><p>layout也可以是增量的，这样只有标志为dirty的渲染对象会重新布局（也将导致一些额外的布局）。增量layout会在渲染对象dirty时<strong>异步触发</strong>，例如，当网络接收到新的内容并添加到DOM树后，新的渲染对象会添加到渲染树中，即在初次渲染时，是一个增量layout的过程。</p><p><img src="/assets/image-20220905210504-r5cgwfg.png" alt="image.png" title="增量layout过程"></p><p><strong>异步和同步layout</strong></p><p><strong>增量layout的过程是异步的</strong>，Firefox为增量 layout 生成了 reflow 队列，以及一个调度执行这些批处理命令。WebKit也有一个计时器用来执行增量layout－遍历树，为dirty状态的渲染对象重新布局。另外，当脚本请求样式信息时，例如“offsetHeight”，会同步的触发增量布局。</p><p>全局的layout一般都是同步触发。有些时候，layout会被作为一个初始layout之后的回调，比如滑动条的滑动。</p><p><strong>优化</strong></p><p>当一个layout因为resize或是渲染位置改变（并不是大小改变）而触发时，渲染对象的大小将会从缓存中读取，而不会重新计算。</p><p>一般情况下，如果只有子树发生改变，则layout并不从根开始。这种情况发生在，变化发生在元素自身并且不影响它周围元素，例如，将文本插入文本域（否则，每次击键都将触发从根开始的重排）。</p><h4 id="1-4-3-layout过程"><a href="#1-4-3-layout过程" class="headerlink" title="1.4.3 layout过程"></a>1.4.3 layout过程</h4><p>layout一般有下面这几个部分：</p><ol><li><p>parent渲染对象决定它的宽度</p></li><li><p>parent渲染对象读取chilidren，并：</p><ul><li>放置child渲染对象（设置它的x和y）</li><li>在需要时（它们当前为dirty或是处于全局layout或者其他原因）调用child渲染对象的layout，这将计算child的高度</li><li>parent渲染对象使用child渲染对象的累积高度，以及margin和padding的高度来设置自己的高度－这将被parent渲染对象的parent使用</li><li>将dirty标识设置为false</li></ul></li></ol><p>Firefox使用一个“state”对象（nsHTMLReflowState）做为参数去布局（firefox称为reflow），state包含parent的宽度及其他内容。</p><p>Firefox布局的输出是一个“metrics”对象（nsHTMLReflowMetrics）。它包括渲染对象计算出的高度。</p><p><strong>宽度计算</strong></p><p>渲染对象的宽度使用容器的宽度、渲染对象样式中的宽度及margin、border进行计算。例如，下面这个div的宽度：</p><p>　　<kbd><div /></kbd></p><p>webkit中宽度的计算过程是（RenderBox类的 <strong>calcWidth</strong> 方法）：</p><ul><li>容器的宽度是容器的<strong>可用宽度和0</strong>中的最大值，这里的可用宽度为：contentWidth&#x3D;clientWidth()-paddingLeft()-paddingRight()，clientWidth和clientHeight代表一个对象内部的不包括border和滑动条的大小</li><li>元素的宽度指样式属性width的值，它可以通过计算容器的百分比得到一个绝对值</li><li>加上水平方向上的border和padding</li></ul><p>到这里是最佳宽度的计算过程，现在计算宽度的最大值和最小值，如果最佳宽度大于最大宽度则使用最大宽度，如果小于最小宽度则使用最小宽度。最后缓存这个值，当需要layout但宽度未改变时使用。</p><p><strong>Line breaking</strong></p><p>当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的parent它需要折行，parent将创建额外的渲染对象并调用它们的layout。</p><h3 id="1-5-绘制（Painting）"><a href="#1-5-绘制（Painting）" class="headerlink" title="1.5 绘制（Painting）"></a>1.5 绘制（Painting）</h3><p>　　绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件，这在UI的章节有更多的介绍。</p><h4 id="1-5-1-全局和增量"><a href="#1-5-1-全局和增量" class="headerlink" title="1.5.1 全局和增量"></a>1.5.1 全局和增量</h4><p>和布局一样，绘制也可以是<strong>全局的</strong>——绘制完整的树，或<strong>增量的</strong>。在增量的绘制过程中，一些渲染对象以不影响整棵树的方式改变，改变的渲染对象使其在屏幕上的矩形区域失效，这将导致操作系统将其看作dirty区域，并产生一个paint事件，操作系统很巧妙的处理这个过程，并将<strong>多个区域合并为一个</strong>，提高性能。Chrome中，这个过程更复杂些，因为渲染对象在不同的进程中，而不是在主进程中。Chrome在一定程度上模拟操作系统的行为，表现为监听事件并派发消息给渲染根，在树中查找到相关的渲染对象，重绘这个对象（往往还包括它的children）。</p><h4 id="1-5-2-绘制顺序"><a href="#1-5-2-绘制顺序" class="headerlink" title="1.5.2 绘制顺序"></a>1.5.2 绘制顺序</h4><p>css2定义了绘制过程的顺序——<a href="http://www.w3.org/TR/CSS21/zindex.html">http://www.w3.org/TR/CSS21/zindex.html</a>。这个就是元素压入堆栈的顺序，这个顺序影响着绘制，<strong>堆栈从后向前进行绘制</strong>。</p><p>一个块渲染对象的堆栈顺序是：</p><ol><li>背景色</li><li>背景图</li><li>border</li><li>children</li><li>outline</li></ol><h4 id="1-5-3-Firefox显示列表"><a href="#1-5-3-Firefox显示列表" class="headerlink" title="1.5.3 Firefox显示列表"></a>1.5.3 Firefox显示列表</h4><p>Firefox读取渲染树并为绘制的矩形创建一个<strong>显示列表</strong>，该列表以<strong>正确的绘制顺序</strong>包含这个矩形<strong>相关的渲染对象</strong>（背景、图片、样式属性等以正确的顺序排序）。用这样的方法，可以使重绘时只需查找一次树，而不需要多次查找——绘制所有的背景、所有的图片、所有的border等等。</p><p>Firefox优化了这个过程，它不添加会被隐藏的元素，比如元素完全在其他不透明元素下面。</p><h4 id="1-5-4-WebKit矩形存储"><a href="#1-5-4-WebKit矩形存储" class="headerlink" title="1.5.4 WebKit矩形存储"></a>1.5.4 WebKit矩形存储</h4><p>重绘前，WebKit将旧的矩形保存为位图，然后<strong>只绘制新旧矩形的差集</strong>。</p><h4 id="1-5-5-动态变化"><a href="#1-5-5-动态变化" class="headerlink" title="1.5.5 动态变化"></a>1.5.5 动态变化</h4><p>浏览器总是试着以<strong>最小的动作响应一个变化</strong>，所以一个元素颜色的变化将只导致该元素的重绘，元素位置的变化将大致元素的布局和重绘，添加一个Dom节点，也会导致这个元素的布局和重绘。一些主要的变化，比如增加html元素的字号，将会导致<strong>缓存失效</strong>，从而引起整体的布局和重绘。</p><h3 id="1-6-渲染引擎的线程"><a href="#1-6-渲染引擎的线程" class="headerlink" title="1.6 渲染引擎的线程"></a>1.6 渲染引擎的线程</h3><p>渲染引擎是<strong>单线程</strong>的，除了网络操作以外，几乎所有的事情都在单一的线程中处理，在Firefox和Safari中，这是浏览器的<strong>主线程</strong>，Chrome中这是tab的主线程（Chrome一个Tab一个进程，一个进程中含有一个主线程，负责大部分的代码执行）。</p><p>网络操作由几个并行线程执行，并行连接的个数是受限的（通常是2－6个）。</p><h3 id="1-7-事件循环"><a href="#1-7-事件循环" class="headerlink" title="1.7 事件循环"></a>1.7 事件循环</h3><p>浏览器主线程是一个事件循环，它被设计为无限循环以保持执行过程的可用，等待事件（例如layout和paint事件）并执行它们，注意并不是无限制的轮询，而是一个带有阻塞的轮询。下面是Firefox的主要事件循环代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mExiting)</span><br><span class="line">    <span class="built_in">NS_ProcessNextEvent</span>(thread);</span><br></pre></td></tr></table></figure><h3 id="1-8-CSS2可视模型（CSS2-visual-module）"><a href="#1-8-CSS2可视模型（CSS2-visual-module）" class="headerlink" title="1.8 CSS2可视模型（CSS2 visual module）"></a>1.8 CSS2可视模型（CSS2 visual module）</h3><h4 id="1-8-1-画布The-Canvas"><a href="#1-8-1-画布The-Canvas" class="headerlink" title="1.8.1 画布The Canvas"></a>1.8.1 画布The Canvas</h4><p>根据CSS2规范，术语canvas用来描述<strong>格式化的结构所渲染的空间</strong>——浏览器绘制内容的地方。画布对每个维度空间都是无限大的，但浏览器基于viewport的大小选择了一个初始宽度。根据<a href="http://www.w3.org/TR/CSS2/zindex.html">http://www.w3.org/TR/CSS2/zindex.html</a>的定义，画布如果是包含在其他画布内则是透明的，否则浏览器会指定一个颜色。</p><h4 id="1-8-2-CSS盒模型"><a href="#1-8-2-CSS盒模型" class="headerlink" title="1.8.2 CSS盒模型"></a>1.8.2 CSS盒模型</h4><p>CSS盒模型描述了矩形盒，这些矩形盒是为文档树中的元素生成的，并根据可视的格式化模型进行布局。每个box包括内容区域（如图片、文本等）及可选的四周padding、border和margin区域。</p><p><img src="/assets/image-20220905213040-ukvs7qo.png" alt="image.png" title="CSS盒子模型"></p><p>每个节点生成0－n个这样的box。所有的元素都有一个display属性，用来决定它们生成box的类型，例如：</p><ul><li>block －生成块状box</li><li>inline －生成一个或多个行内box</li><li>none －不生成box</li></ul><p>默认的是inline，但浏览器样式表设置了其他默认值，例如，div元素默认为block。可以访问<a href="http://www.w3.org/TR/CSS2/sample.html">http://www.w3.org/TR/CSS2/sample.html</a>查看更多的默认样式表示例。</p><h4 id="1-8-3-定位策略Position-scheme"><a href="#1-8-3-定位策略Position-scheme" class="headerlink" title="1.8.3 定位策略Position scheme"></a>1.8.3 定位策略Position scheme</h4><p>这里有三种策略：</p><ol><li>normal －对象根据它在文档的中位置定位，这意味着它在渲染树和在Dom树中位置一致，并根据它的盒模型和大小进行布局。</li><li>float －对象先像普通流一样布局，然后尽可能的向左或是向右移动。</li><li>absolute －对象在渲染树中的位置和Dom树中<strong>位置无关</strong>。</li></ol><p><strong>static 和 relative 是normal， float属于float，absolute和fixed属于absolute。</strong></p><p>在static定位中，不定义位置而使用默认的位置。其他策略中，作者指定位置——top、bottom、left、right。</p><h4 id="1-8-4-Box布局"><a href="#1-8-4-Box布局" class="headerlink" title="1.8.4 Box布局"></a>1.8.4 Box布局</h4><p>Box布局的方式由这几项决定：box的类型、box的大小、定位策略及扩展信息（比如图片大小和屏幕尺寸）。</p><p><strong>Box类型</strong></p><ul><li>Block box：构成一个块，即在浏览器窗口上有自己的矩形</li><li>Inline box：并没有自己的块状区域，但包含在一个块状区域内</li></ul><p>区分</p><ul><li>block一个挨着一个垂直格式化，inline则在水平方向上格式化。</li></ul><p><img src="/assets/image-20220905214925-cfzraou.png" alt="image.png"></p><ul><li>Inline盒模型放置在行内或是line box中，每行至少和最高的box一样高，当box以baseline对齐时——即一个元素的底部和另一个box上除底部以外的某点对齐，行高可以比最高的box高。当容器宽度不够时，行内元素将被放到多行中，这在一个p元素中经常发生。</li></ul><p><img src="/assets/image-20220905215128-dc6mo20.png" alt="image.png"></p><h4 id="1-8-5-定位Position"><a href="#1-8-5-定位Position" class="headerlink" title="1.8.5 定位Position"></a>1.8.5 定位Position</h4><p><strong>Relative</strong></p><p>相对定位——先按照一般的定位，然后按所要求的差值移动。</p><p><img src="/assets/image-20220905215245-d8kp87q.png" alt="image.png"></p><p><strong>Floats</strong></p><p>一个浮动的box移动到一行的最左边或是最右边，其余的box围绕在它周围。下面这段html：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;img src=<span class="string">&quot;images/image.gif&quot;</span> width=<span class="string">&quot;100&quot;</span> height=<span class="string">&quot;100&quot;</span>&gt;Lorem ipsum dolor sit amet, consectetuer...</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215332-ibisnl2.png" alt="image.png"></p><p><strong>Absolute和Fixed</strong></p><p>这种情况下的布局完全<strong>不顾普通的文档流</strong>，<strong>元素不属于文档流的一部分</strong>，大小取决于容器。Fixed时，容器为viewport（可视区域）。</p><p><img src="/assets/image-20220905215416-ftp14sx.png" alt="image.png"></p><p><strong>Layered representation</strong></p><p>这个由CSS属性中的<strong>z-index</strong>指定，表示盒模型的第三个大小，即在<strong>z轴上的位置</strong>。Box分发到堆栈中（称为堆栈上下文），每个堆栈中<strong>靠后的元素将被较早绘制</strong>，栈顶靠前的元素离用户最近，当发生交叠时，将隐藏靠后的元素。<strong>堆栈根据z-index属性排序</strong>，拥有z-index属性的box形成了一个局部堆栈，viewport有外部堆栈</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">STYLE</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">2in</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20220905215620-7cst2bt.png" alt="image.png"></p><p>虽然绿色div排在红色div后面，可能在正常流中也已经被绘制在后面，但z-index有更高优先级，所以在根box的堆栈中更靠前。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> 浏览器内部工作原理-解析方向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三. 浏览器内部工作原理-解析方向（一）</title>
      <link href="/2022/09/06/%E4%B8%89-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/09/06/%E4%B8%89-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="三-浏览器内部工作原理-解析方向（一）"><a href="#三-浏览器内部工作原理-解析方向（一）" class="headerlink" title="三. 浏览器内部工作原理-解析方向（一）"></a>三. 浏览器内部工作原理-解析方向（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为方便读者阅读，贴出以下参考链接，在此感谢前辈笔记。</p><p>浏览器解析过程分析：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>浏览器工作过程分析：<a href="https://zhuanlan.zhihu.com/p/96986818">万字详文：深入理解浏览器原理 - 知乎 (zhihu.com)</a></p><h2 id="树的构建流程"><a href="#树的构建流程" class="headerlink" title="树的构建流程"></a>树的构建流程</h2><p><img src="/assets/image-20220902091918-3jgz0jo.png" alt="image.png"></p><p>HTML 和 CSS 的页面解析是从上之下的，<strong>线程的</strong>。文档流从上往下，若先碰到了 CSS，那么开始解析，接着<strong>不被阻塞的</strong>继续向下解析 HTML，这样既符合并行解析，又符合文档流自上往下解析规则。浏览器先下载 HTML 文件开始解析，遇到 CSS 标签就开始下载 CSS 并解析，这个过程不会阻塞 DOM 的构建。最后 DOM 树和 CSS 规则树生成渲染树，HTML 解析完成。</p><p>注意几点：</p><ol><li>CSS 加载不会阻塞 DOM 树的<strong>解析</strong></li><li>CSS 加载会阻塞 DOM 树的<strong>渲染</strong>（不阻塞解析），即合并成渲染树的过程，因为样式可能会导致重排重绘</li><li>CSS 加载会阻塞后面 JS 语句的执行</li></ol><p>解析、渲染这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时还可能通过网络下载其余内容。</p><h3 id="1-1-HTML-Parser"><a href="#1-1-HTML-Parser" class="headerlink" title="1.1 HTML Parser"></a>1.1 HTML Parser</h3><h4 id="1-1-1-解析"><a href="#1-1-1-解析" class="headerlink" title="1.1.1 解析"></a>1.1.1 解析</h4><p>解析的目的是：将文档转换为具有一定意义的结构，编码时可以理解和使用的东西。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。</p><blockquote><p>解析的目的在于让目标更接近于需要使用的形式，或更具体的描述一些信息。如高级语言先转换为汇编等低级语言，最后再转换成机器码，又或者是家具的运输与组装，零件形式更接近于运输模式，成品形式更接近于使用模式，由成品拆分成零件就是使其更接近于运输模式，同样的道理将文档解析成另外一个格式会更适合某一个场景的使用。</p></blockquote><p>如解析“2＋3－1”这个表达式，可能返回这样一棵树。</p><p><img src="/assets/image-20220902121038-5xudoir.png" alt="image.png"></p><p>解析过程与翻译过程类似，需要具备两个条件，字典和语法规则。</p><p><strong>文法（Grammars）</strong>：解析基于文档依据的语法规则——文档的语言或格式。每种可被解析的格式必须具有由词汇及语法规则组成的特定的文法，称为上下文无关文法。简单来说就是由词汇表、语法规则组成的对某一个格式的限制，与当前文件内容无关。</p><blockquote><p>文法不等于语法规则，文法是词汇表和语法规则的结合，如语法规则定义为“<strong>的</strong>字后面跟着表示事物的名词，<strong>地</strong>字跟在动词后面，<strong>得</strong>字后面跟着形容词”，词汇表则有“谁，得，的，地，花，走，快”，文法规则就是词汇表和语法规则的结合，包含任何一个可能选择，如“谁的花，走得快，的，得，地”等。</p></blockquote><p>解析可以分成两个子过程：</p><ul><li>词法分析</li><li>语法分析</li></ul><p><strong>词法分析</strong>是将文档中的字词按照一定地规则（词汇表）分成符号，符号对应的便是词汇表（基本有效单元的集合）中的某一项。对于人类语言来说，它相当于我们字典中出现的所有单词。</p><p><strong>语法分析</strong>是根据语法规则匹配词法分析后的符号，生成特定状态的过程。</p><p>词法分析器（有时也叫分词器）负责将输入分解为合法的符号，语法分析器则根据语言的语法规则分析文档结构，从而构建解析树，词法分析器知道怎么跳过空白和换行之类的无关字符。</p><p><img src="/assets/image-20220902133652-u2je5s2.png" alt="image.png"></p><p>解析过程是<strong>迭代的</strong>，语法分析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后语法分析器分析下一个符号。如果没有匹配到规则，语法分析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</p><blockquote><p>词法分析器和语法分析器的工作是同步的，正如组装家具时，找到一个一个零件，根据说明书进行组装，如果没有找齐零件，是无法组装某一个个体的。</p></blockquote><h4 id="1-1-2-转换"><a href="#1-1-2-转换" class="headerlink" title="1.1.2 转换"></a>1.1.2 转换</h4><p>转换对工作人员来说是一个隐式的过程，正如在浏览器开发者控制台运行一些代码、打印日志信息一样，开发者可能感受不到转换到机器码的过程。但是编写的源代码并不是最终的目标，底层机器码才是机器识别、运行的格式。</p><p>很多时候，解析树并不是最终结果。解析一般在转换中使用——将输入文档转换为另一种格式。编译就是个例子，编译器在将一段源码编译为机器码的时候，先将源码解析为解析树，然后将该树转换为一个机器码文档。</p><p>简单来说<strong>转换</strong>过程在编译运行时就存在，将源代码转换为机器码，转换时是无感的。</p><p><img src="/assets/image-20220902140802-boi3thw.png" alt="image.png"></p><p>详细的例子可以看看：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>，如不熟悉抽象语法树的概念，可以看看：<a href="https://juejin.cn/post/6844904035271573511">手把手带你入门 AST 抽象语法树 - 掘金 (juejin.cn)</a>。</p><h4 id="1-1-3-深入"><a href="#1-1-3-深入" class="headerlink" title="1.1.3 深入"></a>1.1.3 深入</h4><p><strong>HTML解析器（HTML Parser）：</strong>HTML解析器的工作是将html标识解析为解析树。</p><p><strong>HTML文法定义（The HTML grammar definition）：</strong>W3C组织制定规范定义了HTML的词汇表和语法。</p><p><strong>非上下文无关文法（Not a context free grammar）：</strong>正如在解析简介中提到的，上下文无关文法的语法可以用类似BNF的格式来定义。</p><blockquote><p>HTML 有一个正式的格式定义—— DTD（Document Type Definition文档类型定义），但它并不是上下文无关文法，HTML 更接近于 XML，现在有很多可用的xml 解析器，html 有个 xml 的变体——xhtml，不同在于 html 更宽容，它允许忽略一些特定标签，有时可以省略开始或结束标签。总的来说，它是一种 soft 语法，不像 xml 呆板、固执。</p><p>显然，这个看起来很小的差异却带来了很大的不同。一方面，这是 html 流行的原因——它的宽容使 web 开发人员的工作更加轻松，但另一方面，这也使很难去写一个格式化的文法。所以，html 的解析并不简单，它既不能用传统的解析器解析，也不能用 xml 解析器解析。</p></blockquote><p><strong>HTML DTD</strong></p><p>html 适用 DTD 格式进行定义，这一格式是用于定义 SGML 家族的语言，包括了对所有允许元素及它们的属性和层次关系的定义。正如前面提到的，html DTD 并没有生成一种上下文无关文法。DTD 有一些变种，标准模式只遵守规范，而其他模式则包含了对浏览器过去所使用标签的支持，这么做是为了兼容以前内容。最新的标准 DTD 在<a href="http://www.w3.org/TR/html4/strict.dtd">http://www.w3.org/TR/html4/strict.dtd</a>。</p><p><strong>DOM</strong></p><p>解析输出的树也就是解析树，是由 DOM 元素及属性节点组成的。DOM 是文档对象模型的缩写，它是 html 文档的对象表示，作为 html 元素的外部接口供 JS 等调用。DOM 和标签基本是一一对应的关系。</p><p><strong>解析器类型（Types of parsers）</strong></p><p>有两种基本的解析器——自顶向下解析及自底向上解析。比较直观的解释是，自顶向下解析，查看语法的最高层结构并试着匹配其中一个；自底向上解析则从输入开始，逐步将其转换为语法规则，从底层规则开始直到匹配高层规则。</p><p>来看一下这两种解析器如何解析 “2+3-1” 的例子：<strong>自顶向下</strong>解析器从最高层规则开始——它先识别出“2+3”，将其视为一个表达式，然后识别出 “2+3-1” 为一个表达式（识别表达式的过程中匹配了其他规则，但出发点是最高层规则）。<strong>自底向上</strong>解析会扫描输入直到匹配了一条规则，然后用该规则取代匹配的输入，直到解析完所有输入。部分匹配的表达式被放置在解析堆栈中。</p><p>自顶向下与递归过程类似，从整体开始逐步检查子问题，而自底向上与递推过程类似，从子问题开始推向整体。</p><p><strong>自动化解析（Generating parsers automatically）</strong></p><p>解析器生成器这个工具可以自动生成解析器，只需要指定语言的文法——词汇表及语法规则，它就可以生成一个解析器。创建一个解析器需要对解析有深入的理解，而且手动的创建一个由较好性能的解析器并不容易，所以解析生成器很有用。Webkit使用两个知名的解析生成器——<strong>用于创建语法分析器的Flex</strong>及<strong>创建解析器的Bison</strong>（你可能接触过Lex和Yacc）。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p><p>稍微总结：HTML 解析器按照 HTML DTD 文法定义进行 HTML 解析，可以认为解析生成的 DOM 树与解析树一一映射，DOM 树就是解析树。</p><h4 id="1-1-4-解析算法"><a href="#1-1-4-解析算法" class="headerlink" title="1.1.4 解析算法"></a>1.1.4 解析算法</h4><p>HTML 不能被一般的自顶向下或自底向上的解析器所解析，不能使用正则解析技术，浏览器为 HTML 定制了专属的解析器，原因是：</p><ol><li><p>这门语言本身的宽容特性</p></li><li><p>浏览器对一些常见的非法html有容错机制</p></li><li><p>解析过程是往复的，通常源码不会在解析过程中发生改变，但在 HTML 中，脚本标签包含的 “document.write” 可能添加标签，这说明在解析过程中实际上修改了输入，所以不能使用正则解析技术</p></li></ol><p>HTML5 规范中描述了这个解析算法，算法包括两个阶段——符号化及构建树。</p><p>符号化是<strong>词法分析</strong>的过程，将输入解析为符号，HTML 的符号包括开始标签、结束标签、属性名及属性值。符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，以识别下一个符号，直到处理完所有输入。</p><p><strong>符号识别算法（The tokenization algorithm）</strong></p><p>算法输出 HTML 符号，该算法用状态机表示。每次读取输入流中的一个或多个字符，并根据这些字符转移到下一个状态，当前的符号状态及构建树状态共同影响结果，这意味着，读取同样的字符，可能因为当前状态的不同，得到不同的结果以进入下一个正确的状态。</p><p>这个算法很复杂，这里用一个简单的例子来解释这个原理。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello world</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>初始状态为“Data State”，当遇到“&lt;”字符，状态变为“Tag open state”，读取一个a－z的字符将产生一个开始标签符号，状态相应变为“Tag name state”，一直保持这个状态直到读取到“&gt;”，每个字符都附加到这个符号名上，例子中创建的是一个html符号。</p><p>当读取到“&gt;”，当前的符号就完成了，此时状态回到“Data state”，“<body>”重复这一处理过程。到这里，html和body标签都识别出来了。现在，回到“Data state”，读取“Hello world”中的字符“H”将创建并识别出一个字符符号，这里会<strong>为“Hello world”中的每个字符生成一个字符符号</strong>。</p><p>这样直到遇到“</body>”中的“&lt;”。现在，又回到了“Tag open state”，读取下一个字符“&#x2F;”将创建一个闭合标签符号，并且状态转移到“Tag name state”，还是保持这一状态，直到遇到“&gt;”。然后，产生一个新的标签符号并回到“Data state”。后面的“</html>”将和“</body>”一样处理。</p><p><img src="/assets/image-20220903152441-lnzo21q.png" alt="image.png"></p><p><strong>简单总结：</strong>因为 HTML 符号包括开始标签、结束标签、属性名及属性值，所以解析每一个符号都需要三个状态来决定。状态机+符号化+树构建器。<strong>符号并不仅仅只是一个字符</strong>，可以是标签符号包括标签名、属性等，除标签符号外，为每一个内容字符创建一个字符符号（Data State）。</p><p><strong>树的构建算法（Tree construction algorithm）</strong></p><p>在树的构建阶段，将<strong>修改</strong>以Document为根的DOM树，将元素附加到树上。每个由符号识别器识别生成的节点将会被树构造器进行处理，规范中定义了每个符号相对应的Dom元素，<strong>对应的Dom元素将会被创建</strong>。这些元素除了会被添加到Dom树上，还将被添加到开放元素堆栈中。这个堆栈用来纠正嵌套的未匹配和未闭合标签，这个算法也是用状态机来描述，所有的状态采用插入模式。</p><p>首先是“initial mode”，接收到html符号后将转换为“before html”模式，在这个模式中对这个符号进行再处理。此时，创建了一个HTMLHtmlElement元素，并将其附加到根Document对象上。</p><p>状态此时变为“before head”，接收到body符号时，即使这里没有head符号，也将自动创建一个HTMLHeadElement元素并附加到树上。</p><p>现在，转到“in head”模式，然后是“after head”。到这里，body符号会被再次处理，将创建一个HTMLBodyElement并插入到树中，同时，转移到“in body”模式。</p><p>然后，接收到字符串“Hello world”的字符符号，第一个字符将导致创建并插入一个text节点，其他字符将附加到该节点。</p><p>接收到body结束符号时，转移到“after body”模式，接着接收到html结束符号，这个符号意味着转移到了“after after body”模式，当接收到文件结束符时，整个解析过程结束。</p><p><img src="/assets/image-20220903152422-pm7uawo.png" alt="image.png"></p><p><strong>简单总结：</strong>树构建器根据符号创建对应的DOM元素，附加到以Document为根的DOM树上，并对一些常见的 HTML 错误进行处理。</p><h4 id="1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）"><a href="#1-1-5-解析结束时的处理（Action-when-the-parsing-is-finished）" class="headerlink" title="1.1.5 解析结束时的处理（Action when the parsing is finished）"></a>1.1.5 解析结束时的处理（Action when the parsing is finished）</h4><p>在这个阶段，浏览器将文档标记为可交互的，并开始解析处于延时模式中的脚本——这些脚本在文档解析后执行。文档状态将被设置为完成，同时触发一个 <strong>load</strong> 事件。</p><p>HTML5 规范中有符号化及构建树的完整算法：<a href="http://www.w3.org/TR/html5/syntax.html#html-parser">链接</a>。</p><h4 id="1-1-6-浏览器容错（Browsers-error-tolerance）"><a href="#1-1-6-浏览器容错（Browsers-error-tolerance）" class="headerlink" title="1.1.6 浏览器容错（Browsers error tolerance）"></a>1.1.6 浏览器容错（Browsers error tolerance）</h4><p>详细可查看原文：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><h3 id="1-2-CSS-Parser"><a href="#1-2-CSS-Parser" class="headerlink" title="1.2 CSS Parser"></a>1.2 CSS Parser</h3><p>CSS 的加载并不会阻塞 DOM 的解析，但是会阻塞 DOM 的渲染。因为加载 CSS 时，可能会修改当前解析位置以后的 DOM 节点的样式，如果 CSS 加载不阻塞 DOM 树渲染，那么当 CSS 加载完之后，DOM 树可能又得重新重排 layout（回流reflow）或者重绘了，这就造成了一些没有必要的损耗。</p><p>不同于HTML，CSS属于上下文无关文法，可以用前面所描述的解析器来解析。CSS规范定义了CSS的词法及语法文法。可以参考词汇表和语法规则：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a>。</p><p>每个符号都由正则表达式定义了词法文法（词汇表）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comment<span class="comment">///*[^*]*/*+([^/*][^*]*/*+)*//</span></span><br><span class="line">num[<span class="number">0</span>-<span class="number">9</span>]+|[<span class="number">0</span>-<span class="number">9</span>]*<span class="string">&quot;.&quot;</span>[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">nonascii[<span class="regexp">/200-/</span><span class="number">377</span>]</span><br><span class="line">nmstart[_a-z]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">nmchar[_a-z0-<span class="number">9</span>-]|&#123;nonascii&#125;|&#123;<span class="built_in">escape</span>&#125;</span><br><span class="line">name&#123;nmchar&#125;+</span><br><span class="line">ident&#123;nmstart&#125;&#123;nmchar&#125;*</span><br></pre></td></tr></table></figure><p>“ident”是识别器的缩写，相当于一个class名，“name”是一个元素id（用“＃”引用）。</p><p>语法用BNF进行描述：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">: selector [ <span class="string">&#x27;,&#x27;</span> S* selector ]*</span><br><span class="line"><span class="string">&#x27;&#123;&#x27;</span> S* declaration [ <span class="string">&#x27;;&#x27;</span> S* declaration ]* <span class="string">&#x27;&#125;&#x27;</span> S*</span><br><span class="line">;</span><br><span class="line">selector</span><br><span class="line">: simple_selector [ combinator selector | S+ [ combinator selector ] ]</span><br><span class="line">;</span><br><span class="line"><span class="keyword">class</span></span><br><span class="line">: <span class="string">&#x27;.&#x27;</span> <span class="variable constant_">IDENT</span></span><br><span class="line">;</span><br><span class="line">element_name</span><br><span class="line">: <span class="variable constant_">IDENT</span> | <span class="string">&#x27;*&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>一个规则集合具有一个或是可选个数的多个选择器，这些选择器以逗号和空格（S表示空格）进行分隔。每个规则集合包含大括号及大括号中的一条或多条以分号隔开的声明。声明和选择器在后面进行定义。</p><h4 id="1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）"><a href="#1-2-1-Webkit-CSS解析器（Webkit-CSS-parser）" class="headerlink" title="1.2.1 Webkit CSS解析器（Webkit CSS parser）"></a>1.2.1 Webkit CSS解析器（Webkit CSS parser）</h4><p>Webkit使用Flex和Bison解析生成器从CSS语法文件中自动生成解析器。回忆一下解析器的介绍，Bison创建一个自底向上的解析器，Firefox使用自顶向下解析器。它们都是将每个css文件解析为样式表对象，每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。</p><blockquote><p>用于创建语法分析器的Flex及创建解析器的Bison。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</p></blockquote><p><img src="/assets/image-20220903160338-wjh6j4x.png" alt="image.png"></p><p>注意：WebKit使用的是自底向上的解析器</p><blockquote><p>处理脚本及样式表的顺序（The order of processing scripts and style sheets）</p><p>脚本：web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。HTML5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。</p><p>async是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行；而Defer是在JS加载完成后，整个文档解析完成后执行。 Defer更像是将&lt;script&gt;标签放在&lt;&#x2F;body&gt;之后的效果，但是它由于是异步加载JS文件，所以可以节省时间。简单来说就是async和defer都是开启新线程（http线程）请求JS文件，和解析DOM并行不冲突，async在请求完成后就开始执行JS文件，而defer则是在整个DOM解析完成后再执行JS文件。</p><p>预解析（Speculative parsing）</p><p>Webkit和Firefox都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变Dom树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p></blockquote><p>StyleSheets样式表采用另一种模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。</p><p><strong>简单总结：</strong>WebKit用Flex生成CSS语法规则，Bison生成CSS解析器。样式表不阻塞DOM解析，但是阻塞DOM渲染，FireFox在样式文件未加载完成前阻塞JS脚本，目的是防止样式文件未加载完成而JS脚本需要获取样式文件信息的错误，Chrome只阻塞那些访问未加载完成的样式文件的JS脚本，样式加载完成即不堵塞。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> 浏览器内部工作原理-解析方向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一. 输入URL到呈现页面</title>
      <link href="/2022/09/06/%E4%B8%80-%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%91%88%E7%8E%B0%E9%A1%B5%E9%9D%A2/"/>
      <url>/2022/09/06/%E4%B8%80-%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%91%88%E7%8E%B0%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一-输入URL到呈现页面"><a href="#一-输入URL到呈现页面" class="headerlink" title="一. 输入URL到呈现页面"></a>一. 输入URL到呈现页面</h1><p>按照实现的功能我认为可以划分为三个阶段</p><ul><li>本地校验阶段</li><li>网络请求阶段</li><li>本地渲染阶段</li></ul><h2 id="1-本地校验阶段"><a href="#1-本地校验阶段" class="headerlink" title="1. 本地校验阶段"></a>1. 本地校验阶段</h2><p>本地校验阶段其实很简单，判断输入的信息是搜索还是域名(服务器地址IP)</p><ul><li>如果是搜索，浏览器将会把默认<strong>搜索引擎URL</strong> + <strong>搜索内容</strong>合并成一个新的URL</li><li>如果是网址，浏览器则会根据URL协议，将网址补全为合法的URL</li></ul><p>常见的例子</p><ul><li><p>输入Hello World：<a href="https://cn.bing.com/search?q=hello+world&amp;FORM=ANAB01&amp;PC=U531">https://cn.bing.com/search?q=hello+world&amp;FORM=ANAB01&amp;PC=U531</a></p></li><li><p>输入 image.baidu.com：<a href="https://image.baidu.com/">https://image.baidu.com/</a></p></li></ul><p>可以看出：</p><ul><li>输入搜索内容时，浏览器会将默认搜索引擎URL + 搜索内容合并成一个新的URL，并且可能会添加其他的参数。</li><li>输入网址时，浏览器会自动将原有的网址补全为合法的 URL，如加上 http&#x2F;https，特别注意当输入 <code>baidu.com</code>时，可能会跳转 <code>www.baidu.com</code>，这并不是浏览器的操作而是由服务器重定向到下级的<code>www</code>，目的是 SEO 和保证 cookie 等存储的安全。</li></ul><h2 id="2-网络请求阶段"><a href="#2-网络请求阶段" class="headerlink" title="2. 网络请求阶段"></a>2. 网络请求阶段</h2><p>网络请求阶段是一个复杂的过程，为了优化用户体验，浏览器会尽可能早的将页面呈现在用户面前，所以<strong>网络请求阶段</strong>与第三个阶段<strong>本地渲染</strong>是同步进行的，请求完成可以解析的内容就开始解析，并同时加载剩下地资源。TCP是一个全双工协议。</p><p>网络请求阶段可以细分为四个阶段</p><ul><li>DNS解析（可选）</li><li>建立TCP连接</li><li>发送HTTP请求</li><li>关闭TCP连接</li></ul><h3 id="2-1-DNS解析"><a href="#2-1-DNS解析" class="headerlink" title="2.1 DNS解析"></a>2.1 DNS解析</h3><p>DNS解析是为解析域名的IP而存在的，反向解析则是通过IP查询对应的域名。因为仅靠数字点分型的IP是很难记住的，所以在大部分时候都是通过域名访问网站，因而也需要一个地址簿即 DNS 服务器。</p><p>DNS 服务器是高可用、高并发和分布式的，它是树状结构，如图：</p><p><img src="/assets/image-20220906101312-5na6p7a.png" alt="image"></p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器：返回顶级域 DNS 服务器的 IP 地址，存储如（.com, .cn）服务器的地址</li><li>顶级域 DNS 服务器（com）：返回权威 DNS 服务器的 IP 地址</li><li>权威 DNS 服务器（<a href="http://server.com/">server.com</a>）：返回相应主机的 IP 地址，真正存储当前查询域名的地址簿，如在阿里注册的域名会给分配DNS服务器存储解析<code>dns17.hichina.com</code>，可以在阿里买域名然后转腾讯，此时的阿里服务的权威DNS就会变成腾讯服务的权威DNS</li><li>本地域名服务器（查询代理和DNS查询结果缓存）: 只是一个查询代理，可以是路由器，也可以是运营商的服务器</li></ul><p>目前流行的是递归+迭代查询方式。</p><blockquote><p>如果手机或者电脑上设置解析的DNS为114.114.114.114，那么本地服务器就是114，从设备到114之间为递归查询，其余的为迭代查询。</p></blockquote><blockquote><p>如果设备设置的解析地址为DHCP即路由器或其他自动分配，那么可以认为当前设备到路由器是递归查询，其余为迭代查询。</p></blockquote><p><img src="/assets/image-20220906093724-2b83fv1.png" alt="image.png"></p><p><img src="/assets/image-20220906103913-4kgoi13.png" alt="image"></p><blockquote><p>注：未找到本地DNS解析器缓存，这里我认为是路由器缓存</p></blockquote><p>在客户端输入 URL 后，会有一个<strong>递归+迭代</strong>的过程，<strong>浏览器缓存</strong> -&gt; <strong>系统DNS缓存</strong> -&gt; <strong>本地hosts文件</strong> -&gt; <strong>本地DNS解析器缓存</strong> ?  -&gt; <strong>本地区域DNS服务器迭代查询</strong>，这个过程中任何一步找到了都会结束查找流程。如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式（是否委托其他服务器来干这件事），则迭代查找过程如下图：</p><p><img src="/assets/image-20220906104500-rmsecj0.png" alt="image"></p><p>在查找过程中，有以下优化点：</p><ul><li>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</li><li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li></ul><h3 id="2-2-建立Tcp连接"><a href="#2-2-建立Tcp连接" class="headerlink" title="2.2 建立Tcp连接"></a>2.2 建立Tcp连接</h3><p>首先，判断是不是 <strong>https</strong> ，如果是，则请求过程其实是 HTTP + SSL &#x2F; TLS 两部分组成，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，即传输都是加密后的数据。</p><p>三次握手，建立TCP连接</p><ol><li>第一次握手：建立连接，客户端发送连接请求报文段。将SYN位置为1，此时表示客户端向服务端请求建立连接，Sequence Number为x，随机数用于校验；客户端进入SYN_SEND状态，等待服务器的确认</li><li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；发送SYN请求信息，将SYN位置为1，此时表示服务端向客户端发送建立连接的请求；Sequence Number为y，随机数用于校验；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入 <strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</li></ol><p><strong>简单总结：</strong>三次握手的原因是保证双方通信，TCP是一个全双工协议，所以链路需要分别建立，客户端向服务端请求建立连接，服务端向客户端应答同时请求建立连接，客户端向服务端应答。</p><p>SSL握手过程</p><ol><li><strong>第一步</strong> ：爱丽丝给出支持SSL协议版本号，一个客户端 <strong>随机数</strong> (Client random，第一个随机数)，客户端支持的加密方法等信息</li><li><strong>第二步：</strong> 鲍勃收到信息后，确认双方使用的加密方法，并返回数字证书，一个服务器生成的 <strong>随机数</strong> (Server random，第二个随机数)等信息</li><li><strong>第三步：</strong> 爱丽丝确认数字证书的有效性（计算机系统已默认存储相关机构的证书），然后生成一个新的 <strong>随机数</strong> (Premaster secret)，然后使用数字证书中的公钥，加密这个随机数，发给鲍勃。</li><li><strong>第四步：</strong> 鲍勃使用自己的私钥，获取爱丽丝发来的 <strong>随机数</strong> (即Premaster secret)；(第三、四步就是非对称加密的过程了)</li><li><strong>第五步：</strong> 爱丽丝和鲍勃通过约定的加密方法(通常是<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">AES算法</a>)，使用前面三个随机数，生成 <strong>对话密钥</strong> ，用来加密接下来的通信内容</li></ol><p><img src="/assets/image-20220906111112-swzpduo.png" alt="image"></p><p>完成之后，客户端和服务器端就可以开始传送数据。更多 HTTPS 的资料可以看这里：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/32513816">SSL协议之数据加密过程详解 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/26682342">深入理解HTTPS原理、过程与实践 - 知乎 (zhihu.com)</a></li><li><a href="https://segmentfault.com/a/1190000012196642">解析HTTPS - SegmentFault 思否</a></li></ul><p>简单总结：Tcp建立完成后，如果没有加密 SSL&#x2F;TLS 过程，此时可以开始 HTTP 请求，如果有加密过程，则按照五个阶段进行准备，SSL使用非对称来加密会话密钥，后期使用会话密钥对称加密会话。</p><blockquote><p>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP协议规定，只有ACK&#x3D;1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</p><p>SYN(SYNchronization)：在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN&#x3D;1和ACK&#x3D;1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</p><p>FIN(finis）即完，终结的意思， 用来释放一个连接。当 FIN &#x3D; 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</p></blockquote><h3 id="2-3-http-x2F-https请求"><a href="#2-3-http-x2F-https请求" class="headerlink" title="2.3 http&#x2F;https请求"></a>2.3 http&#x2F;https请求</h3><p>TCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200.</p><p>这里有发生一个<strong>HTTP缓存</strong>过程，是一个常考的考点，大致过程如图：</p><p><img src="/assets/image-20220906112223-hedug48.png" alt="image"></p><p>细节放到了《二. Web性能与安全》处，也可以参考 <a href="https://juejin.cn/post/6844903962216824839#heading-10">浏览器相关原理(面试题)详细总结一 - 掘金 (juejin.cn)</a> 中浏览器缓存这一部分。</p><h3 id="2-5-断开Tcp连接"><a href="#2-5-断开Tcp连接" class="headerlink" title="2.5 断开Tcp连接"></a>2.5 断开Tcp连接</h3><ul><li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li><li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我”同意”你的关闭请求；</li><li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li><li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ul><p><strong>简单总结：</strong>TCP是一个全双工协议，所以链路需要分别拆除，因为链路是双向的，所以无论是建立还是拆除，都需要分别建立，分别拆除，建立和拆除都是一问一答的形式。</p><p>在建立链路时，客户端发送请求建立，服务端应答同时也请求建立，客户端应答。</p><p>在拆除链路时，客户端发送拆除链路，服务端第一次应答，第二次发送拆除链路请求，客户端发送应答。可以是客户端先发送拆除，也可以是服务端先发送拆除，没有顺序要求但是要符合一问一答，与建立连接不同的是拆除链路的应答和发送分开发送，所以是四次挥手。</p><p>分开发送的目的是一条链路不再需要后可以<strong>及时断开</strong>，如果与建立连接类似同时发送 Ack + Fin，那么只有等到被动关闭端处理所有的信息后才会发送。</p><p>举个例子，A向B<strong>紧急</strong>借钱，B可以选择<strong>立刻</strong>给钱或者开一个借条后再给钱，立刻给钱可以<strong>及时响应</strong>，而开借条后再借钱则是<strong>耗费</strong>了A的<strong>等待时间</strong>，必须等B处理完所有借条工作后才能够拿到。</p><blockquote><p><strong>为什么需要四次挥手？</strong></p><p>因为TCP是一个全双工协议，必须单独拆除每一条信道。4次挥手的目的是终止数据传输，并回收资源，此时两个端点两个方向的序列号已经没有了任何关系，必须等待两方向都没有数据传输时才能拆除虚链路，不像初始化时那么简单，发现SYN标志就初始化一个序列号并确认SYN的序列号。因此必须单独分别在一个方向上终止该方向的数据传输。</p><p>如果是三次挥手，会怎么样？三次的话，被动关闭端在收到FIN消息之后，需要同时回复ACK和Server端的FIN消息。如果Server端在该连接上面并没有Pending的消息要处理，那么是可以的，如果Server端还需要等待一段时间才可以关闭另外一个方向的连接，那么这样的三次挥手就不能满足条件。</p><p><a href="https://www.jianshu.com/p/7ddb0e7867ac">【TCP&#x2F;IP】四次挥手的过程及原因 - 简书 (jianshu.com)</a></p></blockquote><h2 id="3-本地渲染阶段"><a href="#3-本地渲染阶段" class="headerlink" title="3. 本地渲染阶段"></a>3. 本地渲染阶段</h2><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树，CSSOM树、样式计算、布局阶段、分层、栅格化和显示。如图：</p><p><img src="/assets/image-20220906122229-s89ggsz.png" alt="image"></p><ul><li>渲染进程将 HTML 内容转换为能够读懂DOM 树结构，渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式，此时的过程是同步的，即HTML Parser 和 CSS Parser，Render Tree构建是同步的。</li><li>创建layout布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。</li><li>合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。</li></ul><h3 id="3-1-构建-DOM-树"><a href="#3-1-构建-DOM-树" class="headerlink" title="3.1 构建 DOM 树"></a>3.1 构建 DOM 树</h3><p>浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程即将字节解析为DOM树，先将HTML的原始字节数据转换为文件<strong>指定编码</strong>的字符，然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。</p><p><img src="/assets/image-20220906122855-4obxhof.png" alt="image"></p><ul><li>转码（Bytes -&gt; Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串</li><li>Tokens 化（Characters -&gt; Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则</li><li>构建 Nodes（Tokens -&gt; Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）</li><li>构建 DOM 树（Nodes -&gt; DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系</li></ul><p>具体的步骤可以参考《三. 浏览器内部工作 - 解析方向》</p><h3 id="3-2-样式计算"><a href="#3-2-样式计算" class="headerlink" title="3.2 样式计算"></a>3.2 样式计算</h3><p>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</p><p>CSS 样式来源主要有 3 种，分别是<code>通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。</code>，其样式计算过程主要为：</p><p><img src="/assets/image-20220906123225-36r2wq2.png" alt="image"></p><p>可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。处理完成后再处理样式的继承和层叠，有些文章将这个过程称为CSSOM的构建过程。</p><p>具体的可以参考：《三. 浏览器内部工作 - 解析方向》</p><h3 id="3-3-页面布局"><a href="#3-3-页面布局" class="headerlink" title="3.3 页面布局"></a>3.3 页面布局</h3><p>布局过程，即排除 <code>script、meta</code> 等功能化、非视觉节点，排除 <code>display: none</code> 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图：</p><p><img src="/assets/image-20220906123341-1ba6ky0.png" alt="image"></p><p>其中，这个过程需要注意的是<code>回流和重绘</code>，具体的可以参考《三. 浏览器内部工作 - 解析方向》</p><h3 id="3-4-生成分层树"><a href="#3-4-生成分层树" class="headerlink" title="3.4 生成分层树"></a>3.4 生成分层树</h3><p>页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），如图：</p><p><img src="/assets/image-20220906123525-cem0mn0.png" alt="image"></p><p>如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。在浏览器中，你可以打开 Chrome 的”开发者工具”，选择”Layers”标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。</p><p>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？</p><p>具体参考：<a href="https://juejin.cn/post/6844903969693646862#heading-4">浏览器相关原理(面试题)详细总结二 - 掘金 (juejin.cn)</a></p><h3 id="3-5-栅格化"><a href="#3-5-栅格化" class="headerlink" title="3.5 栅格化"></a>3.5 栅格化</h3><p>合成线程会按照视口附近的图块来<strong>优先</strong>生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。如图：</p><p><img src="/assets/image-20220906123907-bjyj2ua.png" alt="image"></p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><h3 id="3-6-显示"><a href="#3-6-显示" class="headerlink" title="3.6 显示"></a>3.6 显示</h3><p>最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。</p><h2 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4. 参考文章"></a>4. 参考文章</h2><ul><li><a href="https://juejin.cn/post/6844904054074654728">细说浏览器输入URL后发生了什么 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/6994066112203718686">输入URL到页面显示的前端体系知识 - 掘金 (juejin.cn)</a></li></ul><p>‍</p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> 输入URL到呈现页面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四. 浏览器内部工作原理-内存方向</title>
      <link href="/2022/09/06/%E5%9B%9B-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%96%B9%E5%90%91/"/>
      <url>/2022/09/06/%E5%9B%9B-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="四-浏览器内部工作原理-内存方向"><a href="#四-浏览器内部工作原理-内存方向" class="headerlink" title="四. 浏览器内部工作原理-内存方向"></a>四. 浏览器内部工作原理-内存方向</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为方便读者阅读，贴出以下参考链接，在此感谢前辈笔记。</p><p>浏览器解析过程分析：<a href="https://kb.cnblogs.com/page/129756/">前端必读：浏览器内部工作原理_知识库_博客园 (cnblogs.com)</a></p><p>浏览器工作过程分析：<a href="https://zhuanlan.zhihu.com/p/96986818">万字详文：深入理解浏览器原理 - 知乎 (zhihu.com)</a></p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> 浏览器内部工作原理-内存方向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二. Web性能与安全</title>
      <link href="/2022/09/06/%E4%BA%8C-Web%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
      <url>/2022/09/06/%E4%BA%8C-Web%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="二-Web性能与安全"><a href="#二-Web性能与安全" class="headerlink" title="二. Web性能与安全"></a>二. Web性能与安全</h1><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> Web浏览器 </tag>
            
            <tag> 浏览器内部工作 </tag>
            
            <tag> Web性能与安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Chic添加iconfont失败的临时解决方案</title>
      <link href="/2022/07/26/Hexo-Theme-Chic%E6%B7%BB%E5%8A%A0iconfont%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%B8%B4%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/07/26/Hexo-Theme-Chic%E6%B7%BB%E5%8A%A0iconfont%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%B8%B4%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>在Chic的issue中提到了很多自定义icon的解决方案，但是在2022&#x2F;07&#x2F;26查看时，有关于icon的解决方案都被删除了。</p><ul><li><p>问题：主页中自定义icon图标，在style.styl中@import “…” 加载失败，加载iconfont字体未404，还未找到原因。</p></li><li><p>解决方案：如果不嫌麻烦，直接在themes&#x2F;Chic&#x2F;Chic&#x2F;layout&#x2F;_partial&#x2F;head.ejs中加入 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/fonts/custom/iconfont.css&quot;&gt;</code> 直接加载即可，注意位置，themes&#x2F;Chic&#x2F;source&#x2F;fonts会被编译加载到public目录下。</p></li></ul><h3 id="Chic目录结构"><a href="#Chic目录结构" class="headerlink" title="Chic目录结构"></a>Chic目录结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├─languages</span><br><span class="line">├─layout</span><br><span class="line">│  ├─_page</span><br><span class="line">│  ├─_partial</span><br><span class="line">│  └─_plugins</span><br><span class="line">├─scripts</span><br><span class="line">└─source</span><br><span class="line">    ├─css</span><br><span class="line">    │  ├─_highlight</span><br><span class="line">    │  ├─_lib</span><br><span class="line">    │  ├─_page</span><br><span class="line">    │  │  └─_post</span><br><span class="line">    │  └─_partial</span><br><span class="line">    ├─fonts</span><br><span class="line">    │  ├─custom</span><br><span class="line">    │  ├─iconfont</span><br><span class="line">    │  └─lanting</span><br><span class="line">    └─js</span><br></pre></td></tr></table></figure><p> <code>source</code> 文件夹内的所有的内容都会被编译打包到项目根目录下的 <code>public</code> 文件夹。</p><p>加入 stylesheet 示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%# css list %&gt;</span><br><span class="line">&lt;% if (theme.stylesheets !== undefined &amp;&amp; theme.stylesheets.length &gt; 0) &#123; %&gt;</span><br><span class="line">    &lt;!-- stylesheets list from _config.yml --&gt;</span><br><span class="line">    &lt;% theme.stylesheets.forEach(url =&gt; &#123; %&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- url_for(url) %&gt;&quot;&gt;</span><br><span class="line">    &lt;% &#125;); %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%# 新增 %&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/fonts/custom/iconfont.css&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Chic </tag>
            
            <tag> Hexo </tag>
            
            <tag> iconfont </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/26/hello-world/"/>
      <url>/2022/07/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
